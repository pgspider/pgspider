/*-------------------------------------------------------------------------
 *
 * dynahash_thread.c
 *    src/backend/utils/hash/dynahash_thread.c
 *
 * This file is for using FDW safely in multithread by appending normalized thread id
 * to connection cache hashtable key in FDW without changes to FDW.
 *
 * Portions Copyright (c) 2019, TOSHIBA CORPERATION
 *
 *-------------------------------------------------------------------------
 */
#include <pthread.h>
#include "utils/formatting.h"
#include "catalog/pg_collation.h"

typedef int64 normalized_id_t;
#define NORMALIZED_ID_SIZE sizeof(normalized_id_t)
#define GET_ID_FROM_ENTRY(entry, htab) (normalized_id_t *)((int8 *)entry + htab->keysize)
#define HASH_TABLE_NAME_LEN 64
/* Advance key or entry pointer to hide normalized id from caller */
#define ADJUST_KEY_OFFSET(keyptr) (keyptr += NORMALIZED_ID_SIZE)

 /*
  * True if appending thread id to key is OK for option and hashfunc. We
  * cannot suport hashfunc and compare func users provide because we append
  * integer id to key
  */
#ifdef PGSPIDER
#define SUPPORT_MULTITHREAD(option, hashfunc)  ((option & HASH_BLOBS || (option & HASH_FUNCTION && hashfunc==tag_hash)) && \
						!(option & HASH_SHARED_MEM) && (option & HASH_ELEM) && !(option & HASH_COMPARE))
#else
#define SUPPORT_MULTITHREAD(option, hashfunc)  ((option & HASH_BLOBS || (option & HASH_FUNCTION && hashfunc==tag_hash)) && \
						!(option & HASH_SHARED_MEM) && (option & HASH_ELEM))
#endif
 /*
  * In PGSPider, if hash create with same name we will return the existed hash.
  * But with some case can create new hash with same name. All of it will list
  * in the array bellow.
  */
static const char fdw_tabname_allow_dupplicate_array[][HASH_TABLE_NAME_LEN] = {
		"griddb_fdw containers" ,
		""							/* empty string for end of array */
};

 /*
  * A list of hash table names PostgreSQL(including contrib module) uses, but
  * hash table names FDWs use are excluded. We skip code for using fdw in
  * multithread if a table name matches below names. Generated by
  * contrib/pgspider_core_fdw/tools/extract_hashname.sh
  */
static const char tabname_array[][HASH_TABLE_NAME_LEN] = {
		"Analyzed elements table" ,
		"Analyzed lexemes table" ,
		"Array distinct element count table" ,
		"Attopt cache" ,
		"Btree proof lookup cache" ,
		"bucket ctids" ,
		"CFuncHash" ,
		"Collation cache" ,
		"Combo CIDs" ,
		"CompactCheckpointerRequestQueue" ,
		"crosstab hash" ,
		"Databases hash" ,
		"db hash" ,
		"Enum value blacklist" ,
		"Event Trigger Cache" ,
		"find_all_inheritors temporary table" ,
		"Function stat entries" ,
		"gistbuild parent map" ,
		"gistbuildbuffers" ,
		"JoinRelHashTable" ,
		"json object hashtable" ,
		"keep alive" ,
		"Local Buffer Lookup Table" ,
		"Local predicate lock" ,
		"LOCALLOCK hash" ,
		"LOCK hash" ,
		"logical replication output relation cache" ,
		"Logical replication table sync worker start times" ,
		"Logical rewrite mapping" ,
		"logicalrep relation map cache" ,
		"logicalrep type map cache" ,
		"lwlock stats" ,
		"Operator class cache" ,
		"Operator lookup cache" ,
		"partition directory" ,
		"PartitionTupleRouting table" ,
		"Pending Ops Table" ,
		"Per-database function" ,
		"Per-database table" ,
		"pgstat TabStatusArray lookup hash table" ,
		"pg_stat_statements hash" ,
		"PL/Perl interpreters" ,
		"PL/Perl procedures" ,
		"PL/Perl queries" ,
		"PL/Python procedures" ,
		"PL/Python SPI exceptions" ,
		"PL/Tcl functions" ,
		"PL/Tcl interpreters" ,
		"PLpgSQL cast cache" ,
		"PLpgSQL function hash" ,
		"PLpgSQL private cast cache" ,
		"Portal hash" ,
		"PREDICATELOCK hash" ,
		"PREDICATELOCKTARGET hash" ,
		"Prepared Queries" ,
		"PrivateRefCount" ,
		"PROCLOCK hash" ,
		"Record information cache" ,
		"RecoveryLockLists" ,
		"Relcache by OID" ,
		"RelfilenodeMap cache" ,
		"Remote Con hash" ,
		"Rendezvous variable hash" ,
		"ReorderBufferByXid" ,
		"ReorderBufferToastHash" ,
		"ReorderBufferTupleCid" ,
		"Rewrite / Old to new tid map" ,
		"Rewrite / Unresolved ctids" ,
		"RI compare cache" ,
		"RI constraint cache" ,
		"RI query cache" ,
		"Sequence values" ,
		"SERIALIZABLEXID hash" ,
		"set_rtable_names names" ,
		"Shared Buffer Lookup Table" ,
		"ShmemIndex" ,
		"smgr relation table" ,
		"TableSpace cache" ,
		"Temporary table of OIDs" ,
		"Timezones" ,
		"TOAST to main relid map" ,
		"Trigram NFA" ,
		"Tsearch configuration cache" ,
		"Tsearch dictionary cache" ,
		"Tsearch parser cache" ,
		"Type information cache" ,
		"unlogged hash" ,
		"XLOG invalid-page table" ,
		"pgspider hash fdw tabname table" ,
		"pgspider hash fdw tabname allow dupplicate table" ,
		""							/* empty string for end of array */
};

/* normalized thread id of the current thread */
static __thread normalized_id_t normalized_id = 0;

 /*
  * List of normalized tables. Every time hash_create is called, we create
  * corresponding normalized tables. Normalized tables keep one max normalized
  * thread id for each key of the corresponding hash table. We use this id for
  * allocation of new normalized thread id. This max value is reset when a
  * query is finished
  */
static List *normalized_tables = NULL;

typedef struct FdwTabNameHtabEntry
{
	char key[HASH_TABLE_NAME_LEN]; /* Tabname */
	HTAB *htab;
} FdwTabNameHtabEntry;

/* Pgspider hash table of fdw tabname array */
static HTAB* fdw_tabname_htab = NULL;
static HTAB* fdw_tabname_allow_dupplicate_htab = NULL;

/* hash table of tabname_array */
static HTAB *tabname_htab = NULL;
static pthread_mutex_t hash_mutex = PTHREAD_MUTEX_INITIALIZER;
static bool registered_callback = false;

static void hash_reset_id(void *arg);
static void *get_key_with_id(HTAB *hashp, const void *keyPtr);

/**
 * Initialize and return a hash table which save htab and tabname
 *
 * @return hash table
 */
static HTAB*
hash_fdw_tabname_htab_init()
{
	HASHCTL		ctl;
	HTAB	   *htab = NULL;

	MemSet(&ctl, 0, sizeof(ctl));
	ctl.keysize = HASH_TABLE_NAME_LEN;
	ctl.entrysize = sizeof(FdwTabNameHtabEntry);
	ctl.hcxt = TopMemoryContext;

	htab = hash_create_orig("pgspider hash fdw tabname table", 32, &ctl, HASH_ELEM);
	return htab;
}

/**
 * Initialize and return a hash table which has same data as tabname_array
 *
 * @return hash table
 */
static HTAB *
hash_tabname_allow_dupplicate_init()
{
	HASHCTL		ctl;
	HTAB	   *htab = NULL;
	int			i;

	MemSet(&ctl, 0, sizeof(ctl));
	ctl.keysize = HASH_TABLE_NAME_LEN;
	ctl.entrysize = HASH_TABLE_NAME_LEN;
	ctl.hcxt = TopMemoryContext;

	htab = hash_create_orig("pgspider hash fdw tabname allow dupplicate table", 32, &ctl, HASH_ELEM);

	for (i = 0; fdw_tabname_allow_dupplicate_array[i][0] != '\0'; i++)
	{
		bool		found;

		hash_search(htab, fdw_tabname_allow_dupplicate_array[i], HASH_ENTER, &found);
		if (found)
		{
			elog(ERROR, "hash name duplicated %s", fdw_tabname_allow_dupplicate_array[i]);
		}
	}
	return htab;
}

/**
 * Initialize and return a hash table which has same data as tabname_array
 *
 * @return hash table
 */
static HTAB *
hash_tabname_init()
{
	HASHCTL		ctl;
	HTAB	   *htab = NULL;
	int			i;

	MemSet(&ctl, 0, sizeof(ctl));
	ctl.keysize = HASH_TABLE_NAME_LEN;
	ctl.entrysize = HASH_TABLE_NAME_LEN;
	ctl.hcxt = TopMemoryContext;

	htab = hash_create_orig("pgspider hash table name", 32, &ctl, HASH_ELEM);

	for (i = 0; tabname_array[i][0] != '\0'; i++)
	{
		bool		found;

		hash_search(htab, tabname_array[i], HASH_ENTER, &found);
		if (found)
		{
			elog(ERROR, "hash name duplicated %s", tabname_array[i]);
		}
	}
	return htab;
}

HTAB *
hash_create(const char *tabname, long nelem, HASHCTL *info, int flags)
{
	HTAB	   *htab;
	volatile MemoryContext old = NULL;

	pthread_mutex_lock(&hash_mutex);

	PG_TRY();
	{
		bool		found = true;
		bool		is_allow_found = true;
		bool		isfdw = true;

		if (strlen(tabname) >= HASH_TABLE_NAME_LEN)
			elog(ERROR, "exceed HASH_TABLE_NAME_LEN");

		if (fdw_tabname_allow_dupplicate_htab == NULL)
			fdw_tabname_allow_dupplicate_htab = hash_tabname_allow_dupplicate_init();

		if (fdw_tabname_htab == NULL)
			fdw_tabname_htab = hash_fdw_tabname_htab_init();

		if (tabname_htab == NULL)
			tabname_htab = hash_tabname_init();


		hash_search_orig(tabname_htab, tabname, HASH_FIND, &found);

		if (!found)
			elog(DEBUG3, "Hash table used in FDW: %s", tabname);

#if HASH_CHECK
		if (!found)
		{
			if (strstr(str_tolower(tabname, strlen(tabname), C_COLLATION_OID), "fdw") == NULL && strcmp(tabname, "Shippability cache") != 0)
			{
				elog(ERROR, "Not exist in tabname_array and not match FDW hash table name: %s", tabname);
			}

			if (!SUPPORT_MULTITHREAD(flags, info->hash))
				elog(ERROR, "This hash option cannot be used in FDW: %d %s", flags, tabname);

		}
		else
		{
			if (!SUPPORT_MULTITHREAD(flags, info->hash))
				isfdw = false;
		}
#else
		if (found || !SUPPORT_MULTITHREAD(flags, info->hash))
		{
			/*
			 * If found is false, it may be FDW or other extensions. If
			 * SUPPORT_MULTITHREAD returns false, we assume it is extensions
			 */
			isfdw = false;
		}
#endif
		if (isfdw)
		{
			FdwTabNameHtabEntry* hvalue;
			/* Expand size to store normalized id */
			info->keysize += NORMALIZED_ID_SIZE;
			info->entrysize += NORMALIZED_ID_SIZE;

			/*
			 * Find the tabname from fdw_tabname_htab
			 * If found return the exist htab.
			 * If not found, create new fdw_tabname_htab which key is tabname
			 */
			hvalue = (FdwTabNameHtabEntry*)hash_search_orig(fdw_tabname_htab, tabname, HASH_FIND, &found);
			hash_search_orig(fdw_tabname_allow_dupplicate_htab, tabname, HASH_FIND, &is_allow_found);

			if (found && !is_allow_found)
			{
				htab = hvalue->htab;
			}
			else
			{

				FdwTabNameHtabEntry *hvalue;
				HASHCTL		ctl;
				HTAB	   *id_htab;

				htab = hash_create_orig(tabname, nelem, info, flags);
				htab->isfdw = isfdw;
				MemSet(&ctl, 0, sizeof(ctl));

				/* Key: same as the caller specifies / value: normalized id */

				ctl.keysize = info->keysize - NORMALIZED_ID_SIZE;
				ctl.entrysize = ctl.keysize + NORMALIZED_ID_SIZE;
				ctl.hcxt = TopMemoryContext;
				id_htab = hash_create_orig("pgspider normalized id tables", 8,
										&ctl,
										HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);

				htab->nomralized_id_htab = id_htab;
				old = MemoryContextSwitchTo(TopMemoryContext);
				normalized_tables = lappend(normalized_tables, id_htab);
				MemoryContextSwitchTo(old);

				/* Save tabname as key to fdw_tabname_htab */
				if(!is_allow_found)
				{
					hvalue = (FdwTabNameHtabEntry*)hash_search(fdw_tabname_htab, tabname, HASH_ENTER, &found);
					Assert(!found);
					hvalue->htab = htab;
				}
			}
		}
		else
		{
			htab = hash_create_orig(tabname, nelem, info, flags);
			htab->isfdw = isfdw;
		}
	}
	PG_CATCH();
	{
		if (old)
			MemoryContextSwitchTo(old);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (old)
		MemoryContextSwitchTo(old);
	pthread_mutex_unlock(&hash_mutex);
	return htab;
}

uint32
get_hash_value(HTAB *hashp, const void *keyPtr)
{
	const void *volatile keyId = NULL;
	uint32		hashValue;

	if (!hashp->isfdw)
	{
		return get_hash_value_orig(hashp, keyPtr);
	}

	PG_TRY();
	{
		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, keyPtr);
		hashValue = get_hash_value_orig(hashp, keyPtr);
	}
	PG_CATCH();
	{
		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();
	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	return hashValue;
}


void *
hash_search_with_hash_value(HTAB *hashp,
							const void *keyPtr,
							uint32 hashvalue,
							HASHACTION action,
							bool *foundPtr)
{
	int8	   *entry;
	const void *volatile keyId = NULL;

	if (!hashp->isfdw)
	{
		return hash_search_with_hash_value_orig(hashp,
												keyPtr,
												hashvalue,
												action,
												foundPtr);
	}

	PG_TRY();
	{
		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, keyPtr);

		/*
		 * Recalculate hash value because we cannot assume hashvalue is
		 * calculated based on key with normalized id
		 */
		entry = hash_search_with_hash_value_orig(hashp,
												 keyPtr,
												 hashp->hash(keyId, hashp->keysize),
												 action,
												 foundPtr);
	}
	PG_CATCH();
	{

		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	if (entry != NULL)
		ADJUST_KEY_OFFSET(entry);

	return entry;
}

extern bool
hash_update_hash_key(HTAB *hashp, void *existingEntry,
					 const void *newKeyPtr)
{
	bool		ret;
	const void *volatile keyId = NULL;

	if (!hashp->isfdw)
	{
		return hash_update_hash_key_orig(hashp, existingEntry, newKeyPtr);
	}

	PG_TRY();
	{
		int8	   *entry = existingEntry;

		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, newKeyPtr);
		entry -= NORMALIZED_ID_SIZE;
		ret = hash_update_hash_key_orig(hashp, entry, keyId);
	}
	PG_CATCH();
	{
		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	return ret;
}

void *
hash_search(HTAB *hashp,
			const void *keyPtr,
			HASHACTION action,
			bool *foundPtr)
{
	int8	   *entry;
	const void *volatile keyId = NULL;

	if (!hashp->isfdw)
	{
		return hash_search_orig(hashp,
								keyPtr,
								action,
								foundPtr);
	}

	/* This cache shares entries with multi threads. An entry does not has normalized_id. */
	if (strcmp(hashp->tabname, "parquet_fdw file reader cache") == 0)
	{
		pthread_mutex_lock(&hash_mutex);
		hashp->keysize -= NORMALIZED_ID_SIZE;
		hashp->hctl->entrysize -= NORMALIZED_ID_SIZE;
		hashp->hctl->keysize -= NORMALIZED_ID_SIZE;
		entry = hash_search_orig(hashp,
								keyPtr,
								action,
								foundPtr);
		hashp->keysize += NORMALIZED_ID_SIZE;
		hashp->hctl->entrysize += NORMALIZED_ID_SIZE;
		hashp->hctl->keysize += NORMALIZED_ID_SIZE;
		pthread_mutex_unlock(&hash_mutex);
		return entry;
	}

	PG_TRY();
	{
		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, keyPtr);
		entry = hash_search_orig(hashp,
								 keyId,
								 action,
								 foundPtr);
	}
	PG_CATCH();
	{

		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	if (entry != NULL)
		ADJUST_KEY_OFFSET(entry);
	return entry;
}

void
hash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)
{
	if (!hashp->isfdw)
	{
		hash_seq_init_orig(status, hashp);
		return;
	}

	pthread_mutex_lock(&hash_mutex);
	/* TRY CATCH is not necessary because this does not cause error */
	hash_seq_init_orig(status, hashp);

	pthread_mutex_unlock(&hash_mutex);
}

void *
hash_seq_search(HASH_SEQ_STATUS *status)
{
	int8	   *key;

	if (!status->hashp->isfdw)
	{
		return hash_seq_search_orig(status);
	}

	pthread_mutex_lock(&hash_mutex);
	/* TRY CATCH is not necessary because this does not cause error */
	key = hash_seq_search_orig(status);
	if (key != NULL)
		ADJUST_KEY_OFFSET(key);

	pthread_mutex_unlock(&hash_mutex);
	return key;
}

void
hash_destroy(HTAB *hashp)
{
	bool	is_allow_found = true;
	if (hashp != NULL)
	{
		if (!hashp->isfdw)
		{
			hash_destroy_orig(hashp);
			return;
		}

		pthread_mutex_lock(&hash_mutex);

		/* Remove fdw tabname hashtab from fdw_tabname_htab */
		hash_search_orig(fdw_tabname_allow_dupplicate_htab, hashp->tabname, HASH_FIND, &is_allow_found);
		if(!is_allow_found)
		{
			Assert(fdw_tabname_htab);
			hash_search_orig(fdw_tabname_htab, hashp->tabname, HASH_REMOVE, NULL);
		}

		hash_destroy_orig(hashp->nomralized_id_htab);
		normalized_tables = list_delete_ptr(normalized_tables, hashp->nomralized_id_htab);

		hash_destroy_orig(hashp);

		pthread_mutex_unlock(&hash_mutex);
	}
}

/**
 * Reset all normalized id tables.
 *
 * @param[in] arg - Not use this variable. MemoryContextRegisterResetCallback requires this
 *
 * @return none
 */
static void
hash_reset_id(void *arg)
{
	HASH_SEQ_STATUS scan;
	ListCell   *lc;

	foreach(lc, (List *) normalized_tables)
	{
		HTAB	   *htab = (HTAB *) lfirst(lc);
		void	   *entry;

		hash_seq_init_orig(&scan, htab);
		while ((entry = (void *) hash_seq_search_orig(&scan)))
		{
			normalized_id_t *id = GET_ID_FROM_ENTRY(entry, htab);

			*id = 0;
		}
	}

	registered_callback = false;

	/*
	 * Reset normalized_id of main thread. No need to reset normalized_id of
	 * child thread because it is destroyed at the end of query
	 */
	normalized_id = 0;
}

/**
 * Regsiters hash_reset_id function to query memory context
 *
 * @param[in] query_context - query memory context
 *
 * @return none
 */
void
hash_register_reset_callback(MemoryContext query_context)
{
	if (!registered_callback)
	{
		MemoryContextCallback *cb = MemoryContextAlloc(query_context, sizeof(MemoryContextCallback));

		registered_callback = true;

		cb->arg = NULL;
		cb->func = hash_reset_id;
		MemoryContextRegisterResetCallback(query_context, cb);
	}
}

/**
 * Return key pointer which is created by appending normalized id in front of keyPtr
 *
 * @param[in] hashp - hash table
 * @param[in] keyPtr - hash table key
 *
 * @return key
 */
static void *
get_key_with_id(HTAB *hashp, const void *keyPtr)
{
	int8	   *key = NULL;

	if (normalized_id == 0)
	{
		bool		found;
		void	   *entry = hash_search_orig(hashp->nomralized_id_htab, keyPtr, HASH_ENTER, &found);
		normalized_id_t *maxid = GET_ID_FROM_ENTRY(entry, hashp->nomralized_id_htab);

		if (!found)
			*maxid = 0;
		++*maxid;
		normalized_id = *maxid;
		elog(DEBUG3, "id assigned: %d", (int) normalized_id);
	}

	key = palloc(hashp->keysize);
	memcpy(key, &normalized_id, NORMALIZED_ID_SIZE);
	memcpy(key + NORMALIZED_ID_SIZE, keyPtr, hashp->keysize - NORMALIZED_ID_SIZE);
	return key;
}
