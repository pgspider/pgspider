/*-------------------------------------------------------------------------
 *
 * dynahash_thread.c
 *    src/backend/utils/hash/dynahash_thread.c
 *
 * This file is for using FDW safely in multithread by appending normalized thread id
 * to connection cache hashtable key in FDW without changes to FDW.
 *
 * Portions Copyright (c) 2018-2021, TOSHIBA CORPORATION
 *
 *-------------------------------------------------------------------------
 */

#include <pthread.h>
#include "utils/formatting.h"
#include "catalog/pg_collation.h"

typedef int64 normalized_id_t;
#define NORMALIZED_ID_SIZE sizeof(normalized_id_t)
#define GET_ID_FROM_ENTRY(entry, htab) (normalized_id_t *)((int8 *)entry + htab->keysize)
#define HASH_TABLE_NAME_LEN 64
/* Advance key or entry pointer to hide normalized id from caller */
#define ADJUST_KEY_OFFSET(keyptr) (keyptr += NORMALIZED_ID_SIZE)

/*
 * True if appending thread id to key is OK for option and hashfunc. We
 * cannot suport hashfunc and compare func users provide because we append
 * integer id to key
 */
#ifdef PGSPIDER
#define SUPPORT_MULTITHREAD(option, hashfunc)  ((option & HASH_BLOBS || (option & HASH_FUNCTION && hashfunc==tag_hash)) && \
						!(option & HASH_SHARED_MEM) && (option & HASH_ELEM) && !(option & HASH_COMPARE))
#else
#define SUPPORT_MULTITHREAD(option, hashfunc)  ((option & HASH_BLOBS || (option & HASH_FUNCTION && hashfunc==tag_hash)) && \
						!(option & HASH_SHARED_MEM) && (option & HASH_ELEM))
#endif

 /*
  * In PGSPider, if hash create with same name we will return the existed
  * hash. But with some case can create new hash with same name. All of it
  * will list in the array bellow.
  */
static const char fdw_tabname_allow_dupplicate_array[][HASH_TABLE_NAME_LEN] = {
	"griddb_fdw containers",
	""							/* empty string for end of array */
};

 /*
  * A list of hash table names PostgreSQL(including contrib module) uses, but
  * hash table names FDWs use are excluded. We skip code for using fdw in
  * multithread if a table name matches below names. Generated by
  * contrib/pgspider_core_fdw/tools/extract_hashname.sh
  */
static const char tabname_array[][HASH_TABLE_NAME_LEN] = {
	"Analyzed elements table",
	"Analyzed lexemes table",
	"Array distinct element count table",
	"Attopt cache",
	"Btree proof lookup cache",
	"bucket ctids",
	"CFuncHash",
	"CheckForSessionAndXactLocks table",
	"Collation cache",
	"Combo CIDs",
	"CompactCheckpointerRequestQueue",
	"crosstab hash",
	"Databases hash",
	"db hash",
	"Event Trigger Cache",
	"find_all_inheritors temporary table",
	"Function stat entries",
	"gistbuild parent map",
	"gistbuildbuffers",
	"JoinRelHashTable",
	"json object hashtable",
	"keep alive",
	"Local Buffer Lookup Table",
	"Local predicate lock",
	"LOCALLOCK hash",
	"LOCK hash",
	"logical replication output relation cache",
	"Logical replication table sync worker start times",
	"Logical rewrite mapping",
	"logicalrep partition map cache",
	"logicalrep relation map cache",
	"lwlock stats",
	"ModifyTable target hash",
	"Operator class cache",
	"Operator lookup cache",
	"partition directory",
	"Pending Notifies",
	"Pending Ops Table",
	"pending sync hash",
	"Per-database function",
	"Per-database table",
	"pgstat TabStatusArray lookup hash table",
	"pg_stat_statements hash",
	"PL/Perl interpreters",
	"PL/Perl procedures",
	"PL/Perl queries",
	"PL/Python procedures",
	"PL/Python SPI exceptions",
	"PL/Tcl functions",
	"PL/Tcl interpreters",
	"PLpgSQL cast cache",
	"PLpgSQL function hash",
	"PLpgSQL private cast cache",
	"Portal hash",
	"PREDICATELOCK hash",
	"PREDICATELOCKTARGET hash",
	"Prepared Queries",
	"PrivateRefCount",
	"PROCLOCK hash",
	"Record information cache",
	"RecoveryLockLists",
	"Relcache by OID",
	"RelfilenodeMap cache",
	"Remote Con hash",
	"Rendezvous variable hash",
	"ReorderBufferByXid",
	"ReorderBufferToastHash",
	"ReorderBufferTupleCid",
	"Replication slots hash",
	"Rewrite / Old to new tid map",
	"Rewrite / Unresolved ctids",
	"RI compare cache",
	"RI constraint cache",
	"RI query cache",
	"Sequence values",
	"SERIALIZABLEXID hash",
	"set_rtable_names names",
	"Shared Buffer Lookup Table",
	"ShmemIndex",
	"smgr relation table",
	"StreamXidHash",
	"TableSpace cache",
	"Temporary table of OIDs",
	"Timezones",
	"tmp relfilenodes",
	"TOAST to main relid map",
	"Trigram NFA",
	"TRUNCATE for Foreign Tables",
	"Tsearch configuration cache",
	"Tsearch dictionary cache",
	"Tsearch parser cache",
	"Type information cache",
	"Uncommitted enums",
	"unlogged relation OIDs",
	"XLOG invalid-page table",
	"pgspider hash fdw tabname table",
	"pgspider hash fdw tabname allow dupplicate table",
	"pgspider hash table name",
	"pgspider normalized id tables",
	""							/* empty string for end of array */
};

/* normalized thread id of the current thread */
static __thread normalized_id_t normalized_id = 0;

 /*
  * List of normalized tables. Every time hash_create is called, we create
  * corresponding normalized tables. Normalized tables keep one max normalized
  * thread id for each key of the corresponding hash table. We use this id for
  * allocation of new normalized thread id. This max value is reset when a
  * query is finished
  */
static List *normalized_tables = NULL;

typedef struct FdwTabNameHtabEntry
{
	char		key[HASH_TABLE_NAME_LEN];	/* Tabname */
	HTAB	   *htab;
}			FdwTabNameHtabEntry;

/* Pgspider hash table of fdw tabname array */
static HTAB *fdw_tabname_htab = NULL;
static HTAB *fdw_tabname_allow_dupplicate_htab = NULL;

/* hash table of tabname_array */
static HTAB *tabname_htab = NULL;
static pthread_mutex_t hash_mutex = PTHREAD_MUTEX_INITIALIZER;
static bool registered_callback = false;

static void hash_reset_id(void *arg);
static void *get_key_with_id(HTAB *hashp, const void *keyPtr);

/**
 * Initialize and return a hash table which save htab and tabname
 *
 * @return hash table
 */
static HTAB *
hash_fdw_tabname_htab_init()
{
	HASHCTL		ctl;
	HTAB	   *htab = NULL;

	MemSet(&ctl, 0, sizeof(ctl));
	ctl.keysize = HASH_TABLE_NAME_LEN;
	ctl.entrysize = sizeof(FdwTabNameHtabEntry);
	ctl.hcxt = TopMemoryContext;

	htab = hash_create_orig("pgspider hash fdw tabname table", 32, &ctl, HASH_ELEM | HASH_STRINGS);
	return htab;
}

/**
 * Initialize and return a hash table which has same data as tabname_array
 *
 * @return hash table
 */
static HTAB *
hash_tabname_allow_dupplicate_init()
{
	HASHCTL		ctl;
	HTAB	   *htab = NULL;
	int			i;

	MemSet(&ctl, 0, sizeof(ctl));
	ctl.keysize = HASH_TABLE_NAME_LEN;
	ctl.entrysize = HASH_TABLE_NAME_LEN;
	ctl.hcxt = TopMemoryContext;

	htab = hash_create_orig("pgspider hash fdw tabname allow dupplicate table", 32, &ctl, HASH_ELEM | HASH_STRINGS);

	for (i = 0; fdw_tabname_allow_dupplicate_array[i][0] != '\0'; i++)
	{
		bool		found;

		hash_search(htab, fdw_tabname_allow_dupplicate_array[i], HASH_ENTER, &found);
		if (found)
		{
			elog(ERROR, "hash name duplicated %s", fdw_tabname_allow_dupplicate_array[i]);
		}
	}
	return htab;
}

/**
 * Initialize and return a hash table which has same data as tabname_array
 *
 * @return hash table
 */
static HTAB *
hash_tabname_init()
{
	HASHCTL		ctl;
	HTAB	   *htab = NULL;
	int			i;

	MemSet(&ctl, 0, sizeof(ctl));
	ctl.keysize = HASH_TABLE_NAME_LEN;
	ctl.entrysize = HASH_TABLE_NAME_LEN;
	ctl.hcxt = TopMemoryContext;

	htab = hash_create_orig("pgspider hash table name", 32, &ctl, HASH_ELEM | HASH_STRINGS);

	for (i = 0; tabname_array[i][0] != '\0'; i++)
	{
		bool		found;

		hash_search(htab, tabname_array[i], HASH_ENTER, &found);
		if (found)
		{
			elog(ERROR, "hash name duplicated %s", tabname_array[i]);
		}
	}
	return htab;
}

HTAB *
hash_create(const char *tabname, long nelem, HASHCTL *info, int flags)
{
	HTAB	   *htab;
	volatile MemoryContext old = NULL;

	pthread_mutex_lock(&hash_mutex);

	PG_TRY();
	{
		bool		found = true;
		bool		is_allow_found = true;
		bool		isfdw = true;

		if (strlen(tabname) >= HASH_TABLE_NAME_LEN)
			elog(ERROR, "exceed HASH_TABLE_NAME_LEN");

		if (fdw_tabname_allow_dupplicate_htab == NULL)
			fdw_tabname_allow_dupplicate_htab = hash_tabname_allow_dupplicate_init();

		if (fdw_tabname_htab == NULL)
			fdw_tabname_htab = hash_fdw_tabname_htab_init();

		if (tabname_htab == NULL)
			tabname_htab = hash_tabname_init();


		hash_search_orig(tabname_htab, tabname, HASH_FIND, &found);

		if (!found)
			elog(DEBUG3, "Hash table used in FDW: %s", tabname);

#if HASH_CHECK
		if (!found)
		{
			if (strstr(str_tolower(tabname, strlen(tabname), C_COLLATION_OID), "fdw") == NULL && strcmp(tabname, "Shippability cache") != 0)
			{
				elog(ERROR, "Not exist in tabname_array and not match FDW hash table name: %s", tabname);
			}

			if (!SUPPORT_MULTITHREAD(flags, info->hash))
				elog(ERROR, "This hash option cannot be used in FDW: %d %s", flags, tabname);

		}
		else
		{
			if (!SUPPORT_MULTITHREAD(flags, info->hash))
				isfdw = false;
		}
#else
		if (found || !SUPPORT_MULTITHREAD(flags, info->hash))
		{
			/*
			 * If found is false, it may be FDW or other extensions. If
			 * SUPPORT_MULTITHREAD returns false, we assume it is extensions
			 */
			isfdw = false;
		}
#endif
		if (isfdw)
		{
			FdwTabNameHtabEntry *hvalue;

			/* Expand size to store normalized id */
			info->keysize += NORMALIZED_ID_SIZE;
			info->entrysize += NORMALIZED_ID_SIZE;

			/*
			 * Find the tabname from fdw_tabname_htab If found return the
			 * exist htab. If not found, create new fdw_tabname_htab which key
			 * is tabname
			 */
			hvalue = (FdwTabNameHtabEntry *) hash_search_orig(fdw_tabname_htab, tabname, HASH_FIND, &found);
			hash_search_orig(fdw_tabname_allow_dupplicate_htab, tabname, HASH_FIND, &is_allow_found);

			if (found && !is_allow_found)
			{
				htab = hvalue->htab;
			}
			else
			{

				FdwTabNameHtabEntry *hvalue;
				HASHCTL		ctl;
				HTAB	   *id_htab;

				htab = hash_create_orig(tabname, nelem, info, flags);
				htab->isfdw = isfdw;
				MemSet(&ctl, 0, sizeof(ctl));

				/* Key: same as the caller specifies / value: normalized id */

				ctl.keysize = info->keysize - NORMALIZED_ID_SIZE;
				ctl.entrysize = ctl.keysize + NORMALIZED_ID_SIZE;
				ctl.hcxt = TopMemoryContext;
				id_htab = hash_create_orig("pgspider normalized id tables", 8,
										   &ctl,
										   HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);

				htab->nomralized_id_htab = id_htab;
				old = MemoryContextSwitchTo(TopMemoryContext);
				normalized_tables = lappend(normalized_tables, id_htab);
				MemoryContextSwitchTo(old);

				/* Save tabname as key to fdw_tabname_htab */
				if (!is_allow_found)
				{
					hvalue = (FdwTabNameHtabEntry *) hash_search(fdw_tabname_htab, tabname, HASH_ENTER, &found);
					Assert(!found);
					hvalue->htab = htab;
				}
			}
		}
		else
		{
			htab = hash_create_orig(tabname, nelem, info, flags);
			htab->isfdw = isfdw;
		}
	}
	PG_CATCH();
	{
		if (old)
			MemoryContextSwitchTo(old);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (old)
		MemoryContextSwitchTo(old);
	pthread_mutex_unlock(&hash_mutex);
	return htab;
}

uint32
get_hash_value(HTAB *hashp, const void *keyPtr)
{
	const void *volatile keyId = NULL;
	uint32		hashValue;

	if (!hashp->isfdw)
	{
		return get_hash_value_orig(hashp, keyPtr);
	}

	PG_TRY();
	{
		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, keyPtr);
		hashValue = get_hash_value_orig(hashp, keyPtr);
	}
	PG_CATCH();
	{
		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();
	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	return hashValue;
}


void *
hash_search_with_hash_value(HTAB *hashp,
							const void *keyPtr,
							uint32 hashvalue,
							HASHACTION action,
							bool *foundPtr)
{
	int8	   *entry;
	const void *volatile keyId = NULL;

	if (!hashp->isfdw)
	{
		return hash_search_with_hash_value_orig(hashp,
												keyPtr,
												hashvalue,
												action,
												foundPtr);
	}

	PG_TRY();
	{
		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, keyPtr);

		/*
		 * Recalculate hash value because we cannot assume hashvalue is
		 * calculated based on key with normalized id
		 */
		entry = hash_search_with_hash_value_orig(hashp,
												 keyPtr,
												 hashp->hash(keyId, hashp->keysize),
												 action,
												 foundPtr);
	}
	PG_CATCH();
	{

		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	if (entry != NULL)
		ADJUST_KEY_OFFSET(entry);

	return entry;
}

extern bool
hash_update_hash_key(HTAB *hashp, void *existingEntry,
					 const void *newKeyPtr)
{
	bool		ret;
	const void *volatile keyId = NULL;

	if (!hashp->isfdw)
	{
		return hash_update_hash_key_orig(hashp, existingEntry, newKeyPtr);
	}

	PG_TRY();
	{
		int8	   *entry = existingEntry;

		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, newKeyPtr);
		entry -= NORMALIZED_ID_SIZE;
		ret = hash_update_hash_key_orig(hashp, entry, keyId);
	}
	PG_CATCH();
	{
		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	return ret;
}

void *
hash_search(HTAB *hashp,
			const void *keyPtr,
			HASHACTION action,
			bool *foundPtr)
{
	int8	   *entry;
	const void *volatile keyId = NULL;

	if (!hashp->isfdw)
	{
		return hash_search_orig(hashp,
								keyPtr,
								action,
								foundPtr);
	}

	/*
	 * This cache shares entries with multi threads. An entry does not has
	 * normalized_id.
	 */
	if (strcmp(hashp->tabname, "parquet_fdw file reader cache") == 0)
	{
		pthread_mutex_lock(&hash_mutex);
		hashp->keysize -= NORMALIZED_ID_SIZE;
		hashp->hctl->entrysize -= NORMALIZED_ID_SIZE;
		hashp->hctl->keysize -= NORMALIZED_ID_SIZE;
		entry = hash_search_orig(hashp,
								 keyPtr,
								 action,
								 foundPtr);
		hashp->keysize += NORMALIZED_ID_SIZE;
		hashp->hctl->entrysize += NORMALIZED_ID_SIZE;
		hashp->hctl->keysize += NORMALIZED_ID_SIZE;
		pthread_mutex_unlock(&hash_mutex);
		return entry;
	}

	PG_TRY();
	{
		pthread_mutex_lock(&hash_mutex);
		keyId = get_key_with_id(hashp, keyPtr);
		entry = hash_search_orig(hashp,
								 keyId,
								 action,
								 foundPtr);
	}
	PG_CATCH();
	{

		if (keyId)
			pfree((void *) keyId);
		pthread_mutex_unlock(&hash_mutex);
		PG_RE_THROW();
	}
	PG_END_TRY();

	if (keyId)
		pfree((void *) keyId);
	pthread_mutex_unlock(&hash_mutex);

	if (entry != NULL)
		ADJUST_KEY_OFFSET(entry);
	return entry;
}

void
hash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)
{
	if (!hashp->isfdw)
	{
		hash_seq_init_orig(status, hashp);
		return;
	}

	pthread_mutex_lock(&hash_mutex);
	/* TRY CATCH is not necessary because this does not cause error */
	hash_seq_init_orig(status, hashp);

	pthread_mutex_unlock(&hash_mutex);
}

void *
hash_seq_search(HASH_SEQ_STATUS *status)
{
	int8	   *key;

	if (!status->hashp->isfdw)
	{
		return hash_seq_search_orig(status);
	}

	pthread_mutex_lock(&hash_mutex);
	/* TRY CATCH is not necessary because this does not cause error */
	key = hash_seq_search_orig(status);
	if (key != NULL)
		ADJUST_KEY_OFFSET(key);

	pthread_mutex_unlock(&hash_mutex);
	return key;
}

void
hash_destroy(HTAB *hashp)
{
	bool		is_allow_found = true;

	if (hashp != NULL)
	{
		if (!hashp->isfdw)
		{
			hash_destroy_orig(hashp);
			return;
		}

		pthread_mutex_lock(&hash_mutex);

		/* Remove fdw tabname hashtab from fdw_tabname_htab */
		hash_search_orig(fdw_tabname_allow_dupplicate_htab, hashp->tabname, HASH_FIND, &is_allow_found);
		if (!is_allow_found)
		{
			Assert(fdw_tabname_htab);
			hash_search_orig(fdw_tabname_htab, hashp->tabname, HASH_REMOVE, NULL);
		}

		hash_destroy_orig(hashp->nomralized_id_htab);
		normalized_tables = list_delete_ptr(normalized_tables, hashp->nomralized_id_htab);

		hash_destroy_orig(hashp);

		pthread_mutex_unlock(&hash_mutex);
	}
}

/**
 * Reset all normalized id tables.
 *
 * @param[in] arg - Not use this variable. MemoryContextRegisterResetCallback requires this
 *
 * @return none
 */
static void
hash_reset_id(void *arg)
{
	HASH_SEQ_STATUS scan;
	ListCell   *lc;

	foreach(lc, (List *) normalized_tables)
	{
		HTAB	   *htab = (HTAB *) lfirst(lc);
		void	   *entry;

		hash_seq_init_orig(&scan, htab);
		while ((entry = (void *) hash_seq_search_orig(&scan)))
		{
			normalized_id_t *id = GET_ID_FROM_ENTRY(entry, htab);

			*id = 0;
		}
	}

	registered_callback = false;

	/*
	 * Reset normalized_id of main thread. No need to reset normalized_id of
	 * child thread because it is destroyed at the end of query
	 */
	normalized_id = 0;
}

/**
 * Regsiters hash_reset_id function to query memory context
 *
 * @param[in] query_context - query memory context
 *
 * @return none
 */
void
hash_register_reset_callback(MemoryContext query_context)
{
	if (!registered_callback)
	{
		MemoryContextCallback *cb = MemoryContextAlloc(query_context, sizeof(MemoryContextCallback));

		registered_callback = true;

		cb->arg = NULL;
		cb->func = hash_reset_id;
		MemoryContextRegisterResetCallback(query_context, cb);
	}
}

/**
 * Return key pointer which is created by appending normalized id in front of keyPtr
 *
 * @param[in] hashp - hash table
 * @param[in] keyPtr - hash table key
 *
 * @return key
 */
static void *
get_key_with_id(HTAB *hashp, const void *keyPtr)
{
	int8	   *key = NULL;

	if (normalized_id == 0)
	{
		bool		found;
		void	   *entry = hash_search_orig(hashp->nomralized_id_htab, keyPtr, HASH_ENTER, &found);
		normalized_id_t *maxid = GET_ID_FROM_ENTRY(entry, hashp->nomralized_id_htab);

		if (!found)
			*maxid = 0;
		++*maxid;
		normalized_id = *maxid;
		elog(DEBUG3, "id assigned: %d", (int) normalized_id);
	}

	key = palloc(hashp->keysize);
	memcpy(key, &normalized_id, NORMALIZED_ID_SIZE);
	memcpy(key + NORMALIZED_ID_SIZE, keyPtr, hashp->keysize - NORMALIZED_ID_SIZE);
	return key;
}
