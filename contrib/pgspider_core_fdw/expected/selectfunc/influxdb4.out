--Testcase 1:
SET datestyle=ISO;
--Testcase 2:
SET timezone='Japan';
--Testcase 3:
CREATE EXTENSION pgspider_core_fdw;
--Testcase 4:
CREATE SERVER pgspider_core_svr FOREIGN DATA WRAPPER pgspider_core_fdw OPTIONS (host '127.0.0.1');
--Testcase 5:
CREATE USER MAPPING FOR CURRENT_USER SERVER pgspider_core_svr;
----------------------------------------------------------
-- test structure
-- PGSpider Top Node -+-> Child PGSpider Node -> Data source
--                    +-> Child PGSpider Node -> Data source
-- stub functions are provided by pgspider_fdw and/or Data source FDW (mix use)
----------------------------------------------------------
-- Data source: influxdb
--Testcase 6:
CREATE FOREIGN TABLE s3 (time timestamp with time zone, tag1 text, value1 float8, value2 bigint, value3 float8, value4 bigint, __spd_url text) SERVER pgspider_core_svr;
--Testcase 7:
CREATE EXTENSION pgspider_fdw;
--Testcase 8:
CREATE SERVER pgspider_svr1 FOREIGN DATA WRAPPER pgspider_fdw OPTIONS (host '127.0.0.1', port '5433', dbname 'postgres');
--Testcase 9:
CREATE USER MAPPING FOR CURRENT_USER SERVER pgspider_svr1;
--Testcase 10:
CREATE FOREIGN TABLE s3__pgspider_svr1__0 (time timestamp with time zone, tag1 text, value1 float8, value2 bigint, value3 float8, value4 bigint, __spd_url text) SERVER pgspider_svr1 OPTIONS (table_name 's31influx');
--Testcase 11:
CREATE SERVER pgspider_svr2 FOREIGN DATA WRAPPER pgspider_fdw OPTIONS (host '127.0.0.1', port '5434', dbname 'postgres');
--Testcase 12:
CREATE USER MAPPING FOR CURRENT_USER SERVER pgspider_svr2;
--Testcase 13:
CREATE FOREIGN TABLE s3__pgspider_svr2__0 (time timestamp with time zone, tag1 text, value1 float8, value2 bigint, value3 float8, value4 bigint, __spd_url text) SERVER pgspider_svr2 OPTIONS (table_name 's32influx');
-- s3 (value1,3 as float8, value2,4 as bigint)
--Testcase 14:
\d s3;
                              Foreign table "public.s3"
  Column   |           Type           | Collation | Nullable | Default | FDW options 
-----------+--------------------------+-----------+----------+---------+-------------
 time      | timestamp with time zone |           |          |         | 
 tag1      | text                     |           |          |         | 
 value1    | double precision         |           |          |         | 
 value2    | bigint                   |           |          |         | 
 value3    | double precision         |           |          |         | 
 value4    | bigint                   |           |          |         | 
 __spd_url | text                     |           |          |         | 
Server: pgspider_core_svr

--Testcase 15:
SELECT * FROM s3 ORDER BY 1,2,3,4,5,6,7;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 | a    |    0.1 |    100 |   -0.1 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 | a    |    0.2 |    100 |   -0.2 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 | a    |    0.3 |    100 |   -0.3 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 | b    |    1.1 |    200 |   -1.1 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 | b    |    2.2 |    200 |   -2.2 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 | b    |    3.3 |    200 |   -3.3 |   -200 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select float8() (not pushdown, remove float8, explain)
--Testcase 16:
EXPLAIN VERBOSE
SELECT float8(value1), float8(value2), float8(value3), float8(value4) FROM s3 ORDER BY 1,2,3,4;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=32)
   Output: value1, (float8(value2)), value3, (float8(value4))
   Sort Key: s3.value1, (float8(s3.value2)), s3.value3, (float8(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=32)
         Output: value1, (float8(value2)), value3, (float8(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, float8(value2), value3, float8(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, float8(value2), value3, float8(value4) FROM public.s32influx
(9 rows)

-- select float8() (not pushdown, remove float8, result)
--Testcase 17:
SELECT * FROM (
SELECT float8(value1), float8(value2), float8(value3), float8(value4) FROM s3
) AS t ORDER BY 1,2,3,4;
 float8 | float8 | float8 | float8 
--------+--------+--------+--------
    0.1 |    100 |   -0.1 |   -100
    0.2 |    100 |   -0.2 |   -100
    0.3 |    100 |   -0.3 |   -100
    1.1 |    200 |   -1.1 |   -200
    2.2 |    200 |   -2.2 |   -200
    3.3 |    200 |   -3.3 |   -200
(6 rows)

-- select sqrt (builtin function, explain)
--Testcase 18:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2) FROM s3 ORDER BY 1,2;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Sort  (cost=910.68..927.75 rows=6826 width=16)
   Output: (sqrt(value1)), (sqrt((value2)::double precision))
   Sort Key: (sqrt(s3.value1)), (sqrt((s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..475.97 rows=6826 width=16)
         Output: (sqrt(value1)), (sqrt((value2)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sqrt(value1), sqrt(value2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sqrt(value1), sqrt(value2) FROM public.s32influx
(9 rows)

-- select sqrt (buitin function, result)
--Testcase 19:
SELECT * FROM (
SELECT sqrt(value1), sqrt(value2) FROM s3
) AS t ORDER BY 1,2;
        sqrt         |        sqrt        
---------------------+--------------------
 0.31622776601683794 |                 10
  0.4472135954999579 |                 10
  0.5477225575051661 |                 10
  1.0488088481701516 | 14.142135623730951
  1.4832396974191326 | 14.142135623730951
   1.816590212458495 | 14.142135623730951
(6 rows)

-- select sqrt (builtin function, not pushdown constraints, explain)
--Testcase 20:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1,2;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Sort  (cost=942.15..959.13 rows=6792 width=16)
   Output: (sqrt(value1)), (sqrt((value2)::double precision))
   Sort Key: (sqrt(s3.value1)), (sqrt((s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..509.85 rows=6792 width=16)
         Output: (sqrt(value1)), (sqrt((value2)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sqrt(value1), sqrt(value2), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sqrt(value1), sqrt(value2), value2 FROM public.s32influx
(10 rows)

-- select sqrt (builtin function, not pushdown constraints, result)
--Testcase 21:
SELECT * FROM (
SELECT sqrt(value1), sqrt(value2) FROM s3 WHERE to_hex(value2) != '64'
) AS t ORDER BY 1,2;
        sqrt        |        sqrt        
--------------------+--------------------
 1.0488088481701516 | 14.142135623730951
 1.4832396974191326 | 14.142135623730951
  1.816590212458495 | 14.142135623730951
(3 rows)

-- select sqrt (builtin function, pushdown constraints, explain)
--Testcase 22:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2) FROM s3 WHERE value2 != 200 ORDER BY 1,2;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort  (cost=924.40..941.38 rows=6792 width=16)
   Output: (sqrt(value1)), (sqrt((value2)::double precision))
   Sort Key: (sqrt(s3.value1)), (sqrt((s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..492.11 rows=6792 width=16)
         Output: (sqrt(value1)), (sqrt((value2)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sqrt(value1), sqrt(value2) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sqrt(value1), sqrt(value2) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select sqrt (builtin function, pushdown constraints, result)
--Testcase 23:
SELECT * FROM (
SELECT sqrt(value1), sqrt(value2) FROM s3 WHERE value2 != 200
) AS t ORDER BY 1,2;
        sqrt         | sqrt 
---------------------+------
 0.31622776601683794 |   10
  0.4472135954999579 |   10
  0.5477225575051661 |   10
(3 rows)

-- select sqrt(*) (stub function, explain)
--Testcase 24:
EXPLAIN VERBOSE
SELECT sqrt_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (sqrt_all())
   Sort Key: (sqrt_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (sqrt_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.sqrt_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.sqrt_all() FROM public.s32influx
(9 rows)

-- select sqrt(*) (stub function, result)
--Testcase 25:
SELECT * FROM (
SELECT sqrt_all() from s3
) AS t ORDER BY 1;
                                           sqrt_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.31622776601683794,10,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.4472135954999579,10,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.5477225575051661,10,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.0488088481701516,14.142135623730951,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.4832396974191326,14.142135623730951,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.816590212458495,14.142135623730951,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select sqrt(*) (stub function and group by tag only) (explain)
--Testcase 26:
EXPLAIN VERBOSE
SELECT sqrt_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (sqrt_all()), tag1
   Sort Key: (sqrt_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (sqrt_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.sqrt_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.sqrt_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select sqrt(*) (stub function and group by tag only) (result)
--Testcase 27:
SELECT sqrt_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                           sqrt_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.31622776601683794,10,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.4472135954999579,10,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.5477225575051661,10,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.0488088481701516,14.142135623730951,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.4832396974191326,14.142135623730951,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select abs (builtin function, explain)
--Testcase 28:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 ORDER BY 1,2,3,4;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort  (cost=927.75..944.81 rows=6826 width=32)
   Output: (abs(value1)), (abs(value2)), (abs(value3)), (abs(value4))
   Sort Key: (abs(s3.value1)), (abs(s3.value2)), (abs(s3.value3)), (abs(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..493.04 rows=6826 width=32)
         Output: (abs(value1)), (abs(value2)), (abs(value3)), (abs(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM public.s32influx
(9 rows)

-- ABS() returns negative values if integer (https://github.com/influxdata/influxdb/issues/10261)
-- select abs (buitin function, result)
--Testcase 29:
SELECT * FROM (
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3
) AS t ORDER BY 1,2,3,4;
 abs | abs | abs | abs 
-----+-----+-----+-----
 0.1 | 100 | 0.1 | 100
 0.2 | 100 | 0.2 | 100
 0.3 | 100 | 0.3 | 100
 1.1 | 200 | 1.1 | 200
 2.2 | 200 | 2.2 | 200
 3.3 | 200 | 3.3 | 200
(6 rows)

-- select abs (builtin function, not pushdown constraints, explain)
--Testcase 30:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1,2,3,4;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort  (cost=959.13..976.11 rows=6792 width=32)
   Output: (abs(value1)), (abs(value2)), (abs(value3)), (abs(value4))
   Sort Key: (abs(s3.value1)), (abs(s3.value2)), (abs(s3.value3)), (abs(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..526.83 rows=6792 width=32)
         Output: (abs(value1)), (abs(value2)), (abs(value3)), (abs(value4))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT abs(value1), abs(value2), abs(value3), abs(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT abs(value1), abs(value2), abs(value3), abs(value4), value2 FROM public.s32influx
(10 rows)

-- select abs (builtin function, not pushdown constraints, result)
--Testcase 31:
SELECT * FROM (
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE to_hex(value2) != '64'
) AS t ORDER BY 1,2,3,4;
 abs | abs | abs | abs 
-----+-----+-----+-----
 1.1 | 200 | 1.1 | 200
 2.2 | 200 | 2.2 | 200
 3.3 | 200 | 3.3 | 200
(3 rows)

-- select abs (builtin function, pushdown constraints, explain)
--Testcase 32:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE value2 != 200 ORDER BY 1,2,3,4;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=941.38..958.36 rows=6792 width=32)
   Output: (abs(value1)), (abs(value2)), (abs(value3)), (abs(value4))
   Sort Key: (abs(s3.value1)), (abs(s3.value2)), (abs(s3.value3)), (abs(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..509.09 rows=6792 width=32)
         Output: (abs(value1)), (abs(value2)), (abs(value3)), (abs(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select abs (builtin function, pushdown constraints, result)
--Testcase 33:
SELECT * FROM (
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE value2 != 200
) AS t ORDER BY 1,2,3,4;
 abs | abs | abs | abs 
-----+-----+-----+-----
 0.1 | 100 | 0.1 | 100
 0.2 | 100 | 0.2 | 100
 0.3 | 100 | 0.3 | 100
(3 rows)

-- select log (builtin function, need to swap arguments, numeric cast, explain)
-- log_<base>(v) : postgresql (base, v), influxdb (v, base)
--Testcase 34:
EXPLAIN VERBOSE
SELECT log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1 ORDER BY 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=924.40..941.38 rows=6792 width=32)
   Output: (log((value1)::numeric, (value2)::numeric))
   Sort Key: (log((s3.value1)::numeric, (s3.value2)::numeric))
   ->  Foreign Scan on public.s3  (cost=200.00..492.11 rows=6792 width=32)
         Output: (log((value1)::numeric, (value2)::numeric))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT log(value1::numeric, value2::numeric) FROM public.s31influx WHERE ((value1 <> 1::double precision))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT log(value1::numeric, value2::numeric) FROM public.s32influx WHERE ((value1 <> 1::double precision))
(9 rows)

-- select log (builtin function, need to swap arguments, numeric cast, result)
--Testcase 35:
SELECT * FROM (
SELECT log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1
) AS t ORDER BY 1;
         log         
---------------------
  -3.824978578786397
 -2.8613531161467867
 -2.0000000000000004
    4.43773989221174
   6.719852756654074
  55.590256753535286
(6 rows)

-- select log (builtin function, need to swap arguments, float8, explain)
--Testcase 36:
EXPLAIN VERBOSE
SELECT log(value1::numeric, 0.1) FROM s3 WHERE value1 != 1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=907.42..924.40 rows=6792 width=32)
   Output: (log((value1)::numeric, 0.1))
   Sort Key: (log((s3.value1)::numeric, 0.1))
   ->  Foreign Scan on public.s3  (cost=200.00..475.12 rows=6792 width=32)
         Output: (log((value1)::numeric, 0.1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT log(value1::numeric, 0.1) FROM public.s31influx WHERE ((value1 <> 1::double precision))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT log(value1::numeric, 0.1) FROM public.s32influx WHERE ((value1 <> 1::double precision))
(9 rows)

-- select log (builtin function, need to swap arguments, float8, result)
--Testcase 37:
SELECT * FROM (
SELECT log(value1::numeric, 0.1) FROM s3 WHERE value1 != 1
) AS t ORDER BY 1;
         log         
---------------------
 -24.158857928096783
   -2.92036730043365
 -1.9285884584617043
                   1
   1.430676558073393
   1.912489289393198
(6 rows)

-- select log (builtin function, need to swap arguments, bigint, explain)
--Testcase 38:
EXPLAIN VERBOSE
SELECT log(value2::numeric, 3) FROM s3 WHERE value1 != 1 ORDER BY 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=907.42..924.40 rows=6792 width=32)
   Output: (log((value2)::numeric, '3'::numeric))
   Sort Key: (log((s3.value2)::numeric, '3'::numeric))
   ->  Foreign Scan on public.s3  (cost=200.00..475.12 rows=6792 width=32)
         Output: (log((value2)::numeric, '3'::numeric))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT log(value2::numeric, 3::numeric) FROM public.s31influx WHERE ((value1 <> 1::double precision))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT log(value2::numeric, 3::numeric) FROM public.s32influx WHERE ((value1 <> 1::double precision))
(9 rows)

-- select log (builtin function, need to swap arguments, bigint, result)
--Testcase 39:
SELECT * FROM (
SELECT log(value2::numeric, 3) FROM s3 WHERE value1 != 1
) AS t ORDER BY 1;
         log         
---------------------
  0.2073511669203535
  0.2073511669203535
  0.2073511669203535
 0.23856062735983116
 0.23856062735983116
 0.23856062735983116
(6 rows)

-- select log (builtin function, need to swap arguments, mix type, explain)
--Testcase 40:
EXPLAIN VERBOSE
SELECT log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1 ORDER BY 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=924.40..941.38 rows=6792 width=32)
   Output: (log((value1)::numeric, (value2)::numeric))
   Sort Key: (log((s3.value1)::numeric, (s3.value2)::numeric))
   ->  Foreign Scan on public.s3  (cost=200.00..492.11 rows=6792 width=32)
         Output: (log((value1)::numeric, (value2)::numeric))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT log(value1::numeric, value2::numeric) FROM public.s31influx WHERE ((value1 <> 1::double precision))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT log(value1::numeric, value2::numeric) FROM public.s32influx WHERE ((value1 <> 1::double precision))
(9 rows)

-- select log (builtin function, need to swap arguments, mix type, result)
--Testcase 41:
SELECT * FROM (
SELECT log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1
) AS t ORDER BY 1;
         log         
---------------------
  -3.824978578786397
 -2.8613531161467867
 -2.0000000000000004
    4.43773989221174
   6.719852756654074
  55.590256753535286
(6 rows)

-- select log(*) (stub function, explain)
--Testcase 42:
EXPLAIN VERBOSE
SELECT log_all(50) FROM s3 ORDER BY 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (log_all('50'::double precision))
   Sort Key: (log_all('50'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (log_all('50'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.log_all(50::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.log_all(50::double precision) FROM public.s32influx
(9 rows)

-- select log(*) (stub function, result)
--Testcase 43:
SELECT * FROM (
SELECT log_all(50) FROM s3
) AS t ORDER BY 1;
                                            log_all                                             
------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-0.5885919100677789,1.177183820135558,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-0.41140808993222105,1.177183820135558,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-0.3077621994183976,1.177183820135558,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.024363399620113902,1.3543676402711158,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.20154721975567183,1.3543676402711158,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,0.3051931102694953,1.3543676402711158,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select log(*) (stub function, explain)
--Testcase 44:
EXPLAIN VERBOSE
SELECT log_all(70.5) FROM s3 ORDER BY 1;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (log_all('70.5'::double precision))
   Sort Key: (log_all('70.5'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (log_all('70.5'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.log_all(70.5::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.log_all(70.5::double precision) FROM public.s32influx
(9 rows)

-- select log(*) (stub function, result)
--Testcase 45:
SELECT * FROM (
SELECT log_all(70.5) FROM s3
) AS t ORDER BY 1;
                                            log_all                                             
------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-0.5410701701500463,1.0821403403000929,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-0.3781918191758683,1.0821403403000929,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-0.28291409167667503,1.0821403403000929,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.02239634720152814,1.2450186912742707,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.18527469817570616,1.2450186912742707,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,0.28055242567489946,1.2450186912742707,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select log(*) (stub function and group by tag only) (explain)
--Testcase 46:
EXPLAIN VERBOSE
SELECT log_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (log_all('50'::double precision)), tag1
   Sort Key: (log_all('50'::double precision))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (log_all('50'::double precision)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.log_all(50::double precision), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.log_all(50::double precision), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select log(*) (stub function and group by tag only) (result)
--Testcase 47:
SELECT log_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                            log_all                                             
------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-0.5885919100677789,1.177183820135558,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-0.41140808993222105,1.177183820135558,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-0.3077621994183976,1.177183820135558,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.024363399620113902,1.3543676402711158,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.20154721975567183,1.3543676402711158,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--SELECT ln_all(),log10_all(),log_all(50) FROM s3 ORDER BY 1;
-- select log2 (stub function, explain)
--Testcase 48:
EXPLAIN VERBOSE
SELECT log2(value1),log2(value2) FROM s3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3854.84 rows=6826 width=16)
   Output: (log2(value1)), (log2((value2)::double precision))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT public.log2(value1), public.log2(value2) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT public.log2(value1), public.log2(value2) FROM public.s32influx
(6 rows)

-- select log2 (stub function, result)
--Testcase 49:
SELECT * FROM (
SELECT log2(value1),log2(value2) FROM s3
) AS t ORDER BY 1,2;
        log2         |       log2        
---------------------+-------------------
  -3.321928094887362 | 6.643856189774724
  -2.321928094887362 | 6.643856189774724
  -1.736965594166206 | 6.643856189774724
 0.13750352374993502 | 7.643856189774724
  1.1375035237499351 | 7.643856189774724
   1.722466024471091 | 7.643856189774724
(6 rows)

-- select log2(*) (stub function, explain)
--Testcase 50:
EXPLAIN VERBOSE
SELECT log2_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (log2_all())
   Sort Key: (log2_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (log2_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.log2_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.log2_all() FROM public.s32influx
(9 rows)

-- select log2(*) (stub function, result)
--Testcase 51:
SELECT * FROM (
SELECT log2_all() from s3
) AS t ORDER BY 1;
                                           log2_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-3.321928094887362,6.643856189774724,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-2.321928094887362,6.643856189774724,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-1.736965594166206,6.643856189774724,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.13750352374993502,7.643856189774724,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1375035237499351,7.643856189774724,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.722466024471091,7.643856189774724,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select log2(*) (stub function and group by tag only) (explain)
--Testcase 52:
EXPLAIN VERBOSE
SELECT log2_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (log2_all()), tag1
   Sort Key: (log2_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (log2_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.log2_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.log2_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select log2(*) (stub function and group by tag only) (result)
--Testcase 53:
SELECT log2_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                           log2_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-3.321928094887362,6.643856189774724,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-2.321928094887362,6.643856189774724,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-1.736965594166206,6.643856189774724,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.13750352374993502,7.643856189774724,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1375035237499351,7.643856189774724,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select log10 (stub function, explain)
--Testcase 54:
EXPLAIN VERBOSE
SELECT log10(value1), log10(value2) FROM s3 ORDER BY 1, 2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort  (cost=910.68..927.75 rows=6826 width=16)
   Output: (log10(value1)), (log10((value2)::double precision))
   Sort Key: (log10(s3.value1)), (log10((s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..475.97 rows=6826 width=16)
         Output: (log10(value1)), (log10((value2)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT log10(value1), log10(value2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT log10(value1), log10(value2) FROM public.s32influx
(9 rows)

-- select log10 (stub function, result)
--Testcase 55:
SELECT * FROM (
SELECT log10(value1), log10(value2) FROM s3
) AS t ORDER BY 1, 2;
        log10        |       log10       
---------------------+-------------------
 -0.9999999999999999 |                 2
 -0.6989700043360187 |                 2
 -0.5228787452803376 |                 2
 0.04139268515822507 | 2.301029995663981
  0.3424226808222063 | 2.301029995663981
  0.5185139398778875 | 2.301029995663981
(6 rows)

-- select log10(*) (stub function, explain)
--Testcase 56:
EXPLAIN VERBOSE
SELECT log10_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (log10_all())
   Sort Key: (log10_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (log10_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.log10_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.log10_all() FROM public.s32influx
(9 rows)

-- select log10(*) (stub function, result)
--Testcase 57:
SELECT * FROM (
SELECT log10_all() from s3
) AS t ORDER BY 1;
                                          log10_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-0.9999999999999999,2,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-0.6989700043360187,2,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-0.5228787452803376,2,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.04139268515822507,2.301029995663981,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.3424226808222063,2.301029995663981,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,0.5185139398778875,2.301029995663981,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select log10(*) (stub function and group by tag only) (explain)
--Testcase 58:
EXPLAIN VERBOSE
SELECT log10_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (log10_all()), tag1
   Sort Key: (log10_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (log10_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.log10_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.log10_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select log10(*) (stub function and group by tag only) (result)
--Testcase 59:
SELECT log10_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                          log10_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-0.9999999999999999,2,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-0.6989700043360187,2,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-0.5228787452803376,2,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.04139268515822507,2.301029995663981,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.3424226808222063,2.301029995663981,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--SELECT log2_all(), log10_all() FROM s3 ORDER BY 1;
-- select spread (stub agg function, explain)
--Testcase 60:
EXPLAIN VERBOSE
SELECT spread(value1),spread(value2),spread(value3),spread(value4) FROM s3 ORDER BY 1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (spread(value1)), (spread(value2)), (spread(value3)), (spread(value4))
   Sort Key: (spread(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (spread(value1)), (spread(value2)), (spread(value3)), (spread(value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT min(value1), max(value1), min(value2), max(value2), min(value3), max(value3), min(value4), max(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT min(value1), max(value1), min(value2), max(value2), min(value3), max(value3), min(value4), max(value4) FROM public.s32influx
(13 rows)

-- select spread (stub agg function, result)
--Testcase 61:
SELECT * FROM (
SELECT spread(value1),spread(value2),spread(value3),spread(value4) FROM s3
) AS t ORDER BY 1,2,3,4;
       spread       | spread |       spread       | spread 
--------------------+--------+--------------------+--------
 3.1999999999999997 |    100 | 3.1999999999999997 |    100
(1 row)

-- select spread (stub agg function, raise exception if not expected type)
--Testcase 62:
SELECT * FROM (
SELECT spread(value1::numeric),spread(value2::numeric),spread(value3::numeric),spread(value4::numeric) FROM s3
) AS t ORDER BY 1,2,3,4;
       spread       | spread |       spread       | spread 
--------------------+--------+--------------------+--------
 3.1999999999999997 |    100 | 3.1999999999999997 |    100
(1 row)

-- select abs as nest function with agg (pushdown, explain)
--Testcase 63:
EXPLAIN VERBOSE
SELECT sum(value3),abs(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (abs((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), abs((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select abs as nest function with agg (pushdown, result)
--Testcase 64:
SELECT * FROM (
SELECT sum(value3),abs(sum(value3)) FROM s3
) AS t ORDER BY 1,2;
        sum         |        abs        
--------------------+-------------------
 -7.199999999999999 | 7.199999999999999
(1 row)

-- select abs as nest with log2 (pushdown, explain)
--Testcase 65:
EXPLAIN VERBOSE
SELECT abs(log2(value1)),abs(log2(1/value1)) FROM s3;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (abs(log2(value1))), (abs(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT abs(public.log2(value1)), abs(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT abs(public.log2(value1)), abs(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select abs as nest with log2 (pushdown, result)
--Testcase 66:
SELECT * FROM (
SELECT abs(log2(value1)),abs(log2(1/value1)) FROM s3
) AS t ORDER BY 1,2;
         abs         |         abs         
---------------------+---------------------
 0.13750352374993502 | 0.13750352374993496
  1.1375035237499351 |   1.137503523749935
   1.722466024471091 |   1.722466024471091
   1.736965594166206 |   1.736965594166206
   2.321928094887362 |   2.321928094887362
   3.321928094887362 |   3.321928094887362
(6 rows)

-- select abs with non pushdown func and explicit constant (explain)
--Testcase 67:
EXPLAIN VERBOSE
SELECT abs(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (abs(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (abs(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (abs(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT abs(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT abs(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select abs with non pushdown func and explicit constant (result)
--Testcase 68:
SELECT * FROM (
SELECT abs(value3), pi(), 4.1 FROM s3
) AS t ORDER BY 1,2,3;
 abs |        pi         | ?column? 
-----+-------------------+----------
 0.1 | 3.141592653589793 |      4.1
 0.2 | 3.141592653589793 |      4.1
 0.3 | 3.141592653589793 |      4.1
 1.1 | 3.141592653589793 |      4.1
 2.2 | 3.141592653589793 |      4.1
 3.3 | 3.141592653589793 |      4.1
(6 rows)

-- select sqrt as nest function with agg and explicit constant (pushdown, explain)
--Testcase 69:
EXPLAIN VERBOSE
SELECT sqrt(count(value1)), pi(), 4.1 FROM s3 ORDER BY 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=48)
   Output: (sqrt(((count(value1)))::double precision)), '3.141592653589793'::double precision, 4.1
   Sort Key: (sqrt(((count(s3.value1)))::double precision))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=48)
         Output: sqrt(((count(value1)))::double precision), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT count(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT count(value1) FROM public.s32influx
(13 rows)

-- select sqrt as nest function with agg and explicit constant (pushdown, result)
--Testcase 70:
SELECT * FROM (
SELECT sqrt(count(value1)), pi(), 4.1 FROM s3
) AS t ORDER BY 1,2,3;
       sqrt        |        pi         | ?column? 
-------------------+-------------------+----------
 2.449489742783178 | 3.141592653589793 |      4.1
(1 row)

-- select sqrt as nest function with agg and explicit constant and tag (error, explain)
--Testcase 71:
EXPLAIN VERBOSE
SELECT sqrt(count(value1)), pi(), 4.1, tag1 FROM s3 ORDER BY 1;
ERROR:  column "s3.tag1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 2: SELECT sqrt(count(value1)), pi(), 4.1, tag1 FROM s3 ORDER BY...
                                               ^
-- select spread (stub agg function and group by influx_time() and tag) (explain)
--Testcase 72:
EXPLAIN VERBOSE
SELECT spread("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=48)
   Output: (spread(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (spread(s3.value1))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=48)
         Output: spread(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=48)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1, value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=48)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select spread (stub agg function and group by influx_time() and tag) (result)
--Testcase 73:
SELECT * FROM (
SELECT spread("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1
) AS t ORDER BY 1,2,3;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select spread (stub agg function and group by tag only) (result)
--Testcase 74:
SELECT * FROM (
SELECT tag1,spread("value1") FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1
) AS t ORDER BY 1,2;
 tag1 |       spread        
------+---------------------
 a    | 0.19999999999999998
 b    |                 1.1
(2 rows)

-- select spread (stub agg function and other aggs) (result)
--Testcase 75:
SELECT sum("value1"),spread("value1"),count("value1") FROM s3 ORDER BY 1;
        sum        |       spread       | count 
-------------------+--------------------+-------
 7.199999999999999 | 3.1999999999999997 |     6
(1 row)

-- select abs with order by (explain)
--Testcase 76:
EXPLAIN VERBOSE
SELECT value1, abs(1-value1) FROM s3 ORDER BY abs(1-value1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (abs(('1'::double precision - value1)))
   Sort Key: (abs(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (abs(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, abs((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, abs((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select abs with order by (result)
--Testcase 77:
SELECT value1, abs(1-value1) FROM s3 ORDER BY abs(1-value1);
 value1 |         abs         
--------+---------------------
    1.1 | 0.10000000000000009
    0.3 |                 0.7
    0.2 |                 0.8
    0.1 |                 0.9
    2.2 |  1.2000000000000002
    3.3 |                 2.3
(6 rows)

-- select abs with order by index (result)
--Testcase 78:
SELECT value1, abs(1-value1) FROM s3 ORDER BY 2,1;
 value1 |         abs         
--------+---------------------
    1.1 | 0.10000000000000009
    0.3 |                 0.7
    0.2 |                 0.8
    0.1 |                 0.9
    2.2 |  1.2000000000000002
    3.3 |                 2.3
(6 rows)

-- select abs with order by index (result)
--Testcase 79:
SELECT value1, abs(1-value1) FROM s3 ORDER BY 1,2;
 value1 |         abs         
--------+---------------------
    0.1 |                 0.9
    0.2 |                 0.8
    0.3 |                 0.7
    1.1 | 0.10000000000000009
    2.2 |  1.2000000000000002
    3.3 |                 2.3
(6 rows)

-- select abs and as
--Testcase 80:
SELECT * FROM (
SELECT abs(value3) as abs1 FROM s3
) AS t ORDER BY 1;
 abs1 
------
  0.1
  0.2
  0.3
  1.1
  2.2
  3.3
(6 rows)

-- select abs(*) (stub function, explain)
--Testcase 81:
EXPLAIN VERBOSE
SELECT abs_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (abs_all())
   Sort Key: (abs_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (abs_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.abs_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.abs_all() FROM public.s32influx
(9 rows)

-- select abs(*) (stub function, result)
--Testcase 82:
SELECT * FROM (
SELECT abs_all() from s3
) AS t ORDER BY 1;
                               abs_all                                
----------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,100,0.1,100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.2,100,0.2,100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.3,100,0.3,100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,200,1.1,200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.2,200,2.2,200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.3,200,3.3,200,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select abs(*) (stub function and group by tag only) (explain)
--Testcase 83:
EXPLAIN VERBOSE
SELECT abs_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (abs_all()), tag1
   Sort Key: (abs_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (abs_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.abs_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.abs_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select abs(*) (stub function and group by tag only) (result)
--Testcase 84:
SELECT abs_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                               abs_all                                
----------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,100,0.1,100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.2,100,0.2,100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.3,100,0.3,100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,200,1.1,200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.2,200,2.2,200,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select abs(*) (stub function, expose data, explain)
--Testcase 85:
EXPLAIN VERBOSE
SELECT (abs_all()::s3).* from s3 ORDER BY 1;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((abs_all()))::s3)."time"), ((((abs_all()))::s3).tag1), ((((abs_all()))::s3).value1), ((((abs_all()))::s3).value2), ((((abs_all()))::s3).value3), ((((abs_all()))::s3).value4), ((((abs_all()))::s3).__spd_url)
   Sort Key: ((((abs_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((abs_all()))::s3)."time", (((abs_all()))::s3).tag1, (((abs_all()))::s3).value1, (((abs_all()))::s3).value2, (((abs_all()))::s3).value3, (((abs_all()))::s3).value4, (((abs_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.abs_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.abs_all() FROM public.s32influx
(9 rows)

-- select abs(*) (stub function, expose data, result)
--Testcase 86:
SELECT * FROM (
SELECT (abs_all()::s3).* from s3
) AS t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.1 |    100 |    0.1 |    100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |    0.2 |    100 |    0.2 |    100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |    0.3 |    100 |    0.3 |    100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |    1.1 |    200 |    1.1 |    200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |    2.2 |    200 |    2.2 |    200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    3.3 |    200 |    3.3 |    200 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select spread over join query (explain)
--Testcase 87:
EXPLAIN VERBOSE
SELECT spread(t1.value1), spread(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1204.56..1204.57 rows=1 width=16)
   Output: (spread(t1.value1)), (spread(t2.value1))
   Sort Key: (spread(t1.value1))
   ->  Aggregate  (cost=1204.54..1204.55 rows=1 width=16)
         Output: spread(t1.value1), spread(t2.value1)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=16)
               Output: t1.value1, t2.value1
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select spread over join query (result, stub call error)
--Testcase 88:
SELECT spread(t1.value1), spread(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub spread_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function spread_sfunc(double precision,double precision) line 3 at RAISE
-- select spread with having (explain)
--Testcase 89:
EXPLAIN VERBOSE
SELECT spread(value1) FROM s3 HAVING spread(value1) > 100 ORDER BY 1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (spread(value1))
   Sort Key: (spread(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (spread(value1))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT min(value1), max(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT min(value1), max(value1) FROM public.s32influx
(13 rows)

-- select spread with having (result, not pushdown, stub call error)
--Testcase 90:
SELECT spread(value1) FROM s3 HAVING spread(value1) > 100 ORDER BY 1;
 spread 
--------
(0 rows)

-- select spread(*) (stub agg function, explain)
--Testcase 91:
EXPLAIN VERBOSE
SELECT spread_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (spread_all(*))
   Sort Key: (spread_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: spread_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select spread(*) (stub agg function, result)
--Testcase 92:
SELECT spread_all(*) from s3 ORDER BY 1;
ERROR:  stub spread_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function spread_all_sfunc(text) line 3 at RAISE
-- select spread(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 93:
EXPLAIN VERBOSE
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (spread_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (spread_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: spread_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select spread(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 94:
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select spread(*) (stub agg function and group by tag only) (explain)
--Testcase 95:
EXPLAIN VERBOSE
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (spread_all(*)), tag1
   Sort Key: (spread_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: spread_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select spread(*) (stub agg function and group by tag only) (result)
--Testcase 96:
SELECT spread_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub spread_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function spread_all_sfunc(text) line 3 at RAISE
-- select spread(*) (stub agg function, expose data, explain)
--Testcase 97:
EXPLAIN VERBOSE
SELECT (spread_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((spread_all(*))::s3)."time"), (((spread_all(*))::s3).tag1), (((spread_all(*))::s3).value1), (((spread_all(*))::s3).value2), (((spread_all(*))::s3).value3), (((spread_all(*))::s3).value4), (((spread_all(*))::s3).__spd_url)
   Sort Key: (((spread_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((spread_all(*))::s3)."time", ((spread_all(*))::s3).tag1, ((spread_all(*))::s3).value1, ((spread_all(*))::s3).value2, ((spread_all(*))::s3).value3, ((spread_all(*))::s3).value4, ((spread_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select spread(*) (stub agg function, expose data, result)
--Testcase 98:
SELECT (spread_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub spread_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function spread_all_sfunc(text) line 3 at RAISE
-- select spread(regex) (stub agg function, explain)
--Testcase 99:
EXPLAIN VERBOSE
SELECT spread('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (spread('/value[1,4]/'::text))
   Sort Key: (spread('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: spread('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select spread(regex) (stub agg function, result)
--Testcase 100:
SELECT spread('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub spread_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function spread_sfunc(text,text) line 3 at RAISE
-- select spread(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 101:
EXPLAIN VERBOSE
SELECT spread('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (spread('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (spread('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: spread('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select spread(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 102:
SELECT spread('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select spread(regex) (stub agg function and group by tag only) (explain)
--Testcase 103:
EXPLAIN VERBOSE
SELECT spread('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (spread('/value[1,4]/'::text)), tag1
   Sort Key: (spread('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: spread('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select spread(regex) (stub agg function and group by tag only) (result)
--Testcase 104:
SELECT spread('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub spread_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function spread_sfunc(text,text) line 3 at RAISE
-- select spread(regex) (stub agg function, expose data, explain)
--Testcase 105:
EXPLAIN VERBOSE
SELECT (spread('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((spread('/value[1,4]/'::text))::s3)."time"), (((spread('/value[1,4]/'::text))::s3).tag1), (((spread('/value[1,4]/'::text))::s3).value1), (((spread('/value[1,4]/'::text))::s3).value2), (((spread('/value[1,4]/'::text))::s3).value3), (((spread('/value[1,4]/'::text))::s3).value4), (((spread('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((spread('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((spread('/value[1,4]/'::text))::s3)."time", ((spread('/value[1,4]/'::text))::s3).tag1, ((spread('/value[1,4]/'::text))::s3).value1, ((spread('/value[1,4]/'::text))::s3).value2, ((spread('/value[1,4]/'::text))::s3).value3, ((spread('/value[1,4]/'::text))::s3).value4, ((spread('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select spread(regex) (stub agg function, expose data, result)
--Testcase 106:
SELECT (spread('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub spread_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function spread_sfunc(text,text) line 3 at RAISE
-- select abs with arithmetic and tag in the middle (explain)
--Testcase 107:
EXPLAIN VERBOSE
SELECT abs(value1) + 1, value2, tag1, sqrt(value2) FROM s3 ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=927.75..944.81 rows=6826 width=56)
   Output: ((abs(value1) + '1'::double precision)), value2, tag1, (sqrt((value2)::double precision))
   Sort Key: ((abs(s3.value1) + '1'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..493.04 rows=6826 width=56)
         Output: ((abs(value1) + '1'::double precision)), value2, tag1, (sqrt((value2)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT (abs(value1) + 1::double precision), value2, tag1, sqrt(value2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT (abs(value1) + 1::double precision), value2, tag1, sqrt(value2) FROM public.s32influx
(9 rows)

-- select abs with arithmetic and tag in the middle (result)
--Testcase 108:
SELECT * FROM (
SELECT abs(value1) + 1, value2, tag1, sqrt(value2) FROM s3
) AS t ORDER BY 1,2,3,4;
 ?column? | value2 | tag1 |        sqrt        
----------+--------+------+--------------------
      1.1 |    100 | a    |                 10
      1.2 |    100 | a    |                 10
      1.3 |    100 | a    |                 10
      2.1 |    200 | b    | 14.142135623730951
      3.2 |    200 | b    | 14.142135623730951
      4.3 |    200 | b    | 14.142135623730951
(6 rows)

-- select with order by limit (explain)
--Testcase 109:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value3), sqrt(value2) FROM s3 ORDER BY abs(value3) LIMIT 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit  (cost=527.17..527.17 rows=1 width=24)
   Output: (abs(value1)), (abs(value3)), (sqrt((value2)::double precision))
   ->  Sort  (cost=527.17..544.24 rows=6826 width=24)
         Output: (abs(value1)), (abs(value3)), (sqrt((value2)::double precision))
         Sort Key: (abs(s3.value3))
         ->  Foreign Scan on public.s3  (cost=200.00..493.04 rows=6826 width=24)
               Output: (abs(value1)), (abs(value3)), (sqrt((value2)::double precision))
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT abs(value1), abs(value3), sqrt(value2) FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT abs(value1), abs(value3), sqrt(value2) FROM public.s32influx
(11 rows)

-- select with order by limit (result)
--Testcase 110:
SELECT abs(value1), abs(value3), sqrt(value2) FROM s3 ORDER BY abs(value3) LIMIT 1;
 abs | abs | sqrt 
-----+-----+------
 0.1 | 0.1 |   10
(1 row)

-- select mixing with non pushdown func (all not pushdown, explain)
--Testcase 111:
EXPLAIN VERBOSE
SELECT abs(value1), sqrt(value2), upper(tag1) FROM s3 ORDER BY 1;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Sort  (cost=927.75..944.81 rows=6826 width=48)
   Output: (abs(value1)), (sqrt((value2)::double precision)), (upper(tag1))
   Sort Key: (abs(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..493.04 rows=6826 width=48)
         Output: (abs(value1)), (sqrt((value2)::double precision)), (upper(tag1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT abs(value1), sqrt(value2), upper(tag1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT abs(value1), sqrt(value2), upper(tag1) FROM public.s32influx
(9 rows)

-- select mixing with non pushdown func (result)
--Testcase 112:
SELECT * FROM (
SELECT abs(value1), sqrt(value2), upper(tag1) FROM s3
) AS t ORDER BY 1,2,3;
 abs |        sqrt        | upper 
-----+--------------------+-------
 0.1 |                 10 | A
 0.2 |                 10 | A
 0.3 |                 10 | A
 1.1 | 14.142135623730951 | B
 2.2 | 14.142135623730951 | B
 3.3 | 14.142135623730951 | B
(6 rows)

-- nested function in where clause (explain)
--Testcase 113:
EXPLAIN VERBOSE
SELECT sqrt(abs(value3)),min(value1) FROM s3 GROUP BY value3 HAVING sqrt(abs(value3)) > 0 ORDER BY 1,2;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=24)
   Output: (sqrt(abs(value3))), (min(value1)), value3
   Sort Key: (sqrt(abs(s3.value3))), (min(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=24)
         Output: sqrt(abs(value3)), (min(value1)), value3
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT min(value1), value3 FROM public.s31influx WHERE ((sqrt(abs(value3)) > 0::double precision)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT min(value1), value3 FROM public.s32influx WHERE ((sqrt(abs(value3)) > 0::double precision)) GROUP BY 2
(13 rows)

-- nested function in where clause (result)
--Testcase 114:
SELECT sqrt(abs(value3)),min(value1) FROM s3 GROUP BY value3 HAVING sqrt(abs(value3)) > 0 ORDER BY 1,2;
        sqrt         | min 
---------------------+-----
 0.31622776601683794 | 0.1
  0.4472135954999579 | 0.2
  0.5477225575051661 | 0.3
  1.0488088481701516 | 1.1
  1.4832396974191326 | 2.2
   1.816590212458495 | 3.3
(6 rows)

--Testcase 115:
EXPLAIN VERBOSE
SELECT first(time, value1), first(time, value2), first(time, value3), first(time, value4) FROM s3 ORDER BY 1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (first("time", value1)), (first("time", value2)), (first("time", value3)), (first("time", value4))
   Sort Key: (first(s3."time", s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (first("time", value1)), (first("time", value2)), (first("time", value3)), (first("time", value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.first("time", value1), public.first("time", value2), public.first("time", value3), public.first("time", value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.first("time", value1), public.first("time", value2), public.first("time", value3), public.first("time", value4) FROM public.s32influx
(13 rows)

--Testcase 116:
SELECT first(time, value1), first(time, value2), first(time, value3), first(time, value4) FROM s3 ORDER BY 1;
       first        | first |        first        | first 
--------------------+-------+---------------------+-------
 1.2000000000000002 |   300 | -1.2000000000000002 |  -300
(1 row)

-- select first(*) (stub agg function, explain)
--Testcase 117:
EXPLAIN VERBOSE
SELECT first_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (first_all(*))
   Sort Key: (first_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: first_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select first(*) (stub agg function, result)
--Testcase 118:
SELECT * FROM (
SELECT first_all(*) from s3
) AS t ORDER BY 1;
ERROR:  stub first_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function first_all_sfunc(text) line 3 at RAISE
-- select first(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 119:
EXPLAIN VERBOSE
SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (first_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (first_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: first_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select first(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 120:
SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- -- select first(*) (stub agg function and group by tag only) (explain)
-- -- EXPLAIN VERBOSE
-- SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- -- select first(*) (stub agg function and group by tag only) (result)
-- -- SELECT first_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- select first(*) (stub agg function, expose data, explain)
--Testcase 121:
EXPLAIN VERBOSE
SELECT (first_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((first_all(*))::s3)."time"), (((first_all(*))::s3).tag1), (((first_all(*))::s3).value1), (((first_all(*))::s3).value2), (((first_all(*))::s3).value3), (((first_all(*))::s3).value4), (((first_all(*))::s3).__spd_url)
   Sort Key: (((first_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((first_all(*))::s3)."time", ((first_all(*))::s3).tag1, ((first_all(*))::s3).value1, ((first_all(*))::s3).value2, ((first_all(*))::s3).value3, ((first_all(*))::s3).value4, ((first_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select first(*) (stub agg function, expose data, result)
--Testcase 122:
SELECT * FROM (
SELECT (first_all(*)::s3).* from s3
) AS t ORDER BY 1;
ERROR:  stub first_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function first_all_sfunc(text) line 3 at RAISE
-- select first(regex) (stub function, explain)
--Testcase 123:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (first('/value[1,4]/'::text))
   Sort Key: (first('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: first('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select first(regex) (stub function, explain)
--Testcase 124:
SELECT first('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub first_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function first_sfunc(text,text) line 3 at RAISE
-- select multiple regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 125:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/'), first('/^v.*/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=3837.80..3837.81 rows=1 width=64)
   Output: (first('/value[1,4]/'::text)), (first('/^v.*/'::text))
   Sort Key: (first('/value[1,4]/'::text))
   ->  Aggregate  (cost=3837.78..3837.79 rows=1 width=64)
         Output: first('/value[1,4]/'::text), first('/^v.*/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select multiple regex functions (do not push down, raise warning and stub error) (result)
--Testcase 126:
SELECT first('/value[1,4]/'), first('/^v.*/') from s3 ORDER BY 1;
ERROR:  stub first_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function first_sfunc(text,text) line 3 at RAISE
-- select first(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 127:
EXPLAIN VERBOSE
SELECT first('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (first('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (first('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: first('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select first(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 128:
SELECT first('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- -- select first(regex) (stub agg function and group by tag only) (explain)
-- -- EXPLAIN VERBOSE
-- SELECT first('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- -- select first(regex) (stub agg function and group by tag only) (result)
-- -- SELECT first('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- select first(regex) (stub agg function, expose data, explain)
--Testcase 129:
EXPLAIN VERBOSE
SELECT (first('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((first('/value[1,4]/'::text))::s3)."time"), (((first('/value[1,4]/'::text))::s3).tag1), (((first('/value[1,4]/'::text))::s3).value1), (((first('/value[1,4]/'::text))::s3).value2), (((first('/value[1,4]/'::text))::s3).value3), (((first('/value[1,4]/'::text))::s3).value4), (((first('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((first('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((first('/value[1,4]/'::text))::s3)."time", ((first('/value[1,4]/'::text))::s3).tag1, ((first('/value[1,4]/'::text))::s3).value1, ((first('/value[1,4]/'::text))::s3).value2, ((first('/value[1,4]/'::text))::s3).value3, ((first('/value[1,4]/'::text))::s3).value4, ((first('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select first(regex) (stub agg function, expose data, result)
--Testcase 130:
SELECT * FROM (
SELECT (first('/value[1,4]/')::s3).* from s3
) AS t ORDER BY 1;
ERROR:  stub first_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function first_sfunc(text,text) line 3 at RAISE
--Testcase 131:
EXPLAIN VERBOSE
SELECT last(time, value1), last(time, value2), last(time, value3), last(time, value4) FROM s3 ORDER BY 1;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (last("time", value1)), (last("time", value2)), (last("time", value3)), (last("time", value4))
   Sort Key: (last(s3."time", s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (last("time", value1)), (last("time", value2)), (last("time", value3)), (last("time", value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.last("time", value1), public.last("time", value2), public.last("time", value3), public.last("time", value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.last("time", value1), public.last("time", value2), public.last("time", value3), public.last("time", value4) FROM public.s32influx
(13 rows)

--Testcase 132:
SELECT last(time, value1), last(time, value2), last(time, value3), last(time, value4) FROM s3 ORDER BY 1;
 last | last | last | last 
------+------+------+------
  3.3 |  200 | -0.3 | -100
(1 row)

-- select last(*) (stub agg function, explain)
--Testcase 133:
EXPLAIN VERBOSE
SELECT last_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (last_all(*))
   Sort Key: (last_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: last_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select last(*) (stub agg function, result)
--Testcase 134:
SELECT * FROM (
SELECT last_all(*) from s3
) AS t ORDER BY 1;
ERROR:  stub last_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function last_all_sfunc(text) line 3 at RAISE
-- select last(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 135:
EXPLAIN VERBOSE
SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (last_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (last_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: last_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select last(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 136:
SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- -- select last(*) (stub agg function and group by tag only) (explain)
-- -- EXPLAIN VERBOSE
-- SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- -- select last(*) (stub agg function and group by tag only) (result)
-- -- SELECT last_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- select last(*) (stub agg function, expose data, explain)
--Testcase 137:
EXPLAIN VERBOSE
SELECT (last_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((last_all(*))::s3)."time"), (((last_all(*))::s3).tag1), (((last_all(*))::s3).value1), (((last_all(*))::s3).value2), (((last_all(*))::s3).value3), (((last_all(*))::s3).value4), (((last_all(*))::s3).__spd_url)
   Sort Key: (((last_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((last_all(*))::s3)."time", ((last_all(*))::s3).tag1, ((last_all(*))::s3).value1, ((last_all(*))::s3).value2, ((last_all(*))::s3).value3, ((last_all(*))::s3).value4, ((last_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select last(*) (stub agg function, expose data, result)
--Testcase 138:
SELECT * FROM (
SELECT (last_all(*)::s3).* from s3
) AS t ORDER BY 1;
ERROR:  stub last_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function last_all_sfunc(text) line 3 at RAISE
-- select last(regex) (stub function, explain)
--Testcase 139:
EXPLAIN VERBOSE
SELECT last('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (last('/value[1,4]/'::text))
   Sort Key: (last('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: last('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select last(regex) (stub function, result)
--Testcase 140:
SELECT last('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub last_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function last_sfunc(text,text) line 3 at RAISE
-- select multiple regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 141:
EXPLAIN VERBOSE
SELECT first('/value[1,4]/'), first('/^v.*/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=3837.80..3837.81 rows=1 width=64)
   Output: (first('/value[1,4]/'::text)), (first('/^v.*/'::text))
   Sort Key: (first('/value[1,4]/'::text))
   ->  Aggregate  (cost=3837.78..3837.79 rows=1 width=64)
         Output: first('/value[1,4]/'::text), first('/^v.*/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select multiple regex functions (do not push down, raise warning and stub error) (result)
--Testcase 142:
SELECT first('/value[1,4]/'), first('/^v.*/') from s3 ORDER BY 1;
ERROR:  stub first_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function first_sfunc(text,text) line 3 at RAISE
-- select last(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 143:
EXPLAIN VERBOSE
SELECT last('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (last('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (last('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: last('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select last(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 144:
SELECT last('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- -- select last(regex) (stub agg function and group by tag only) (explain)
-- -- EXPLAIN VERBOSE
-- SELECT last('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- -- select last(regex) (stub agg function and group by tag only) (result)
-- -- SELECT last('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- select last(regex) (stub agg function, expose data, explain)
--Testcase 145:
EXPLAIN VERBOSE
SELECT (last('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                              QUERY PLAN                                                                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((last('/value[1,4]/'::text))::s3)."time"), (((last('/value[1,4]/'::text))::s3).tag1), (((last('/value[1,4]/'::text))::s3).value1), (((last('/value[1,4]/'::text))::s3).value2), (((last('/value[1,4]/'::text))::s3).value3), (((last('/value[1,4]/'::text))::s3).value4), (((last('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((last('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((last('/value[1,4]/'::text))::s3)."time", ((last('/value[1,4]/'::text))::s3).tag1, ((last('/value[1,4]/'::text))::s3).value1, ((last('/value[1,4]/'::text))::s3).value2, ((last('/value[1,4]/'::text))::s3).value3, ((last('/value[1,4]/'::text))::s3).value4, ((last('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select last(regex) (stub agg function, expose data, result)
--Testcase 146:
SELECT * FROM (
SELECT (last('/value[1,4]/')::s3).* from s3
) AS t ORDER BY 1;
ERROR:  stub last_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function last_sfunc(text,text) line 3 at RAISE
--Testcase 147:
EXPLAIN VERBOSE
SELECT sample(value2, 3) FROM s3 WHERE value2 < 200 ORDER BY 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (sample(value2, 3))
   Sort Key: (sample(s3.value2, 3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (sample(value2, 3))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.sample(value2, 3) FROM public.s31influx WHERE ((value2 < 200))
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.sample(value2, 3) FROM public.s32influx WHERE ((value2 < 200))
(13 rows)

--Testcase 148:
SELECT sample(value2, 3) FROM s3 WHERE value2 < 200 ORDER BY 1;
 sample 
--------
    300
(1 row)

--Testcase 149:
EXPLAIN VERBOSE
SELECT sample(value2, 1) FROM s3 WHERE time >= to_timestamp(0) AND time <= to_timestamp(5) GROUP BY influx_time(time, interval '3s') ORDER BY 1;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.22..350.30 rows=32 width=16)
   Output: (sample(value2, 1)), (influx_time("time", '@ 3 secs'::interval))
   Sort Key: (sample(s3.value2, 1))
   ->  GroupAggregate  (cost=332.43..349.42 rows=32 width=16)
         Output: sample(value2, 1), (influx_time("time", '@ 3 secs'::interval))
         Group Key: (influx_time(s3."time", '@ 3 secs'::interval))
         ->  Sort  (cost=332.43..332.52 rows=34 width=16)
               Output: (influx_time("time", '@ 3 secs'::interval)), value2
               Sort Key: (influx_time(s3."time", '@ 3 secs'::interval))
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=16)
                     Output: influx_time("time", '@ 3 secs'::interval), value2
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", value2 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:05+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", value2 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:05+09'::timestamp with time zone))
(15 rows)

--Testcase 150:
SELECT sample(value2, 1) FROM s3 WHERE time >= to_timestamp(0) AND time <= to_timestamp(5) GROUP BY influx_time(time, interval '3s') ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select sample(*, int) (stub agg function, explain)
--Testcase 151:
EXPLAIN VERBOSE
SELECT sample_all(50) from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (sample_all(50))
   Sort Key: (sample_all(50))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (sample_all(50))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.sample_all(50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.sample_all(50) FROM public.s32influx
(9 rows)

-- select sample(*, int) (stub agg function, result)
--Testcase 152:
SELECT * FROM (
SELECT sample_all(50) from s3
) AS t ORDER BY 1;
                               sample_all                               
------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,100,-0.1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.2,100,-0.2,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.3,100,-0.3,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,200,-1.1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.2,200,-2.2,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.3,200,-3.3,-200,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select sample(*, int) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 153:
EXPLAIN VERBOSE
SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.49..349.57 rows=32 width=72)
   Output: (sample_all(50)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (sample_all(50))
   ->  Group  (cost=332.43..348.69 rows=32 width=72)
         Output: sample_all(50), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select sample(*, int) (stub agg function and group by influx_time() and tag) (result)
--Testcase 154:
SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- -- select sample(*, int) (stub agg function and group by tag only) (explain)
-- -- EXPLAIN VERBOSE
-- SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- -- select sample(*, int) (stub agg function and group by tag only) (result)
-- -- SELECT sample_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- select sample(*, int) (stub agg function, expose data, explain)
--Testcase 155:
EXPLAIN VERBOSE
SELECT (sample_all(50)::s3).* from s3 ORDER BY 1;
                                                                                                                           QUERY PLAN                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((sample_all(50)))::s3)."time"), ((((sample_all(50)))::s3).tag1), ((((sample_all(50)))::s3).value1), ((((sample_all(50)))::s3).value2), ((((sample_all(50)))::s3).value3), ((((sample_all(50)))::s3).value4), ((((sample_all(50)))::s3).__spd_url)
   Sort Key: ((((sample_all(50)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((sample_all(50)))::s3)."time", (((sample_all(50)))::s3).tag1, (((sample_all(50)))::s3).value1, (((sample_all(50)))::s3).value2, (((sample_all(50)))::s3).value3, (((sample_all(50)))::s3).value4, (((sample_all(50)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.sample_all(50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.sample_all(50) FROM public.s32influx
(9 rows)

-- select sample(*, int) (stub agg function, expose data, result)
--Testcase 156:
SELECT * FROM (
SELECT (sample_all(50)::s3).* from s3
) AS t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.1 |    100 |   -0.1 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |    0.2 |    100 |   -0.2 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |    0.3 |    100 |   -0.3 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |    1.1 |    200 |   -1.1 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |    2.2 |    200 |   -2.2 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    3.3 |    200 |   -3.3 |   -200 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select sample(regex) (stub agg function, explain)
--Testcase 157:
EXPLAIN VERBOSE
SELECT sample('/value[1,4]/', 50) from s3 ORDER BY 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (sample('/value[1,4]/'::text, 50))
   Sort Key: (sample('/value[1,4]/'::text, 50))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (sample('/value[1,4]/'::text, 50))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.sample('/value[1,4]/'::text, 50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.sample('/value[1,4]/'::text, 50) FROM public.s32influx
(9 rows)

-- select sample(regex) (stub agg function, result)
--Testcase 158:
SELECT sample('/value[1,4]/', 50) from s3 ORDER BY 1;
                             sample                              
-----------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.2,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.3,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.2,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.3,,,-200,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select sample(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 159:
EXPLAIN VERBOSE
SELECT sample('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.49..349.57 rows=32 width=72)
   Output: (sample('/^v.*/'::text, 50)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (sample('/^v.*/'::text, 50))
   ->  Group  (cost=332.43..348.69 rows=32 width=72)
         Output: sample('/^v.*/'::text, 50), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select sample(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 160:
SELECT sample('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- -- select sample(regex) (stub agg function and group by tag only) (explain)
-- -- EXPLAIN VERBOSE
-- SELECT sample('/value[1,4]/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- -- select sample(regex) (stub agg function and group by tag only) (result)
-- -- SELECT sample('/value[1,4]/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1;
-- select sample(regex) (stub agg function, expose data, explain)
--Testcase 161:
EXPLAIN VERBOSE
SELECT (sample('/value[1,4]/', 50)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((sample('/value[1,4]/'::text, 50)))::s3)."time"), ((((sample('/value[1,4]/'::text, 50)))::s3).tag1), ((((sample('/value[1,4]/'::text, 50)))::s3).value1), ((((sample('/value[1,4]/'::text, 50)))::s3).value2), ((((sample('/value[1,4]/'::text, 50)))::s3).value3), ((((sample('/value[1,4]/'::text, 50)))::s3).value4), ((((sample('/value[1,4]/'::text, 50)))::s3).__spd_url)
   Sort Key: ((((sample('/value[1,4]/'::text, 50)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((sample('/value[1,4]/'::text, 50)))::s3)."time", (((sample('/value[1,4]/'::text, 50)))::s3).tag1, (((sample('/value[1,4]/'::text, 50)))::s3).value1, (((sample('/value[1,4]/'::text, 50)))::s3).value2, (((sample('/value[1,4]/'::text, 50)))::s3).value3, (((sample('/value[1,4]/'::text, 50)))::s3).value4, (((sample('/value[1,4]/'::text, 50)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.sample('/value[1,4]/'::text, 50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.sample('/value[1,4]/'::text, 50) FROM public.s32influx
(9 rows)

-- select sample(regex) (stub agg function, expose data, result)
--Testcase 162:
SELECT * FROM (
SELECT (sample('/value[1,4]/', 50)::s3).* from s3
) AS t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.1 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |    0.2 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |    0.3 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |    1.1 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |    2.2 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    3.3 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
(6 rows)

--Testcase 163:
EXPLAIN VERBOSE
SELECT cumulative_sum(value1),cumulative_sum(value2),cumulative_sum(value3),cumulative_sum(value4) FROM s3 ORDER BY 1, 2, 3, 4;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (cumulative_sum(value1)), (cumulative_sum(value2)), (cumulative_sum(value3)), (cumulative_sum(value4))
   Sort Key: (cumulative_sum(s3.value1)), (cumulative_sum(s3.value2)), (cumulative_sum(s3.value3)), (cumulative_sum(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (cumulative_sum(value1)), (cumulative_sum(value2)), (cumulative_sum(value3)), (cumulative_sum(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum(value1), public.cumulative_sum(value2), public.cumulative_sum(value3), public.cumulative_sum(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum(value1), public.cumulative_sum(value2), public.cumulative_sum(value3), public.cumulative_sum(value4) FROM public.s32influx
(9 rows)

--Testcase 164:
SELECT cumulative_sum(value1),cumulative_sum(value2),cumulative_sum(value3),cumulative_sum(value4) FROM s3 ORDER BY 1, 2, 3, 4;
   cumulative_sum    | cumulative_sum |    cumulative_sum    | cumulative_sum 
---------------------+----------------+----------------------+----------------
                 0.1 |            100 |                 -0.1 |           -100
 0.30000000000000004 |            200 | -0.30000000000000004 |           -200
  0.6000000000000001 |            300 |  -0.6000000000000001 |           -300
                 1.1 |            200 |                 -1.1 |           -200
  3.3000000000000003 |            400 |  -3.3000000000000003 |           -400
                 6.6 |            600 |                 -6.6 |           -600
(6 rows)

-- select cumulative_sum(*) (stub function, explain)
--Testcase 165:
EXPLAIN VERBOSE
SELECT cumulative_sum_all() from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (cumulative_sum_all())
   Sort Key: (cumulative_sum_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (cumulative_sum_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum_all() FROM public.s32influx
(9 rows)

-- select cumulative_sum(*) (stub function, result)
--Testcase 166:
SELECT * FROM (
SELECT cumulative_sum_all() from s3
) AS t ORDER BY 1;
                                           cumulative_sum_all                                           
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,100,-0.1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.30000000000000004,200,-0.30000000000000004,-200,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.6000000000000001,300,-0.6000000000000001,-300,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,200,-1.1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,3.3000000000000003,400,-3.3000000000000003,-400,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,6.6,600,-6.6,-600,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select cumulative_sum(regex) (stub function, explain)
--Testcase 167:
EXPLAIN VERBOSE
SELECT cumulative_sum('/value[1,4]/') from s3 ORDER BY 1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (cumulative_sum('/value[1,4]/'::text))
   Sort Key: (cumulative_sum('/value[1,4]/'::text))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (cumulative_sum('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select cumulative_sum(regex) (stub function, result)
--Testcase 168:
SELECT cumulative_sum('/value[1,4]/') from s3 ORDER BY 1;
                                 cumulative_sum                                  
---------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.30000000000000004,,,-200,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.6000000000000001,,,-300,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,3.3000000000000003,,,-400,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,6.6,,,-600,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select multiple star and regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 169:
EXPLAIN VERBOSE
SELECT cumulative_sum_all(), cumulative_sum('/value[1,4]/') from s3 ORDER BY 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=4272.49..4289.55 rows=6826 width=64)
   Output: (cumulative_sum_all()), (cumulative_sum('/value[1,4]/'::text))
   Sort Key: (cumulative_sum_all())
   ->  Foreign Scan on public.s3  (cost=200.00..3837.78 rows=6826 width=64)
         Output: (cumulative_sum_all()), (cumulative_sum('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum_all(), public.cumulative_sum('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum_all(), public.cumulative_sum('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select multiple star and regex functions (do not push down, raise warning and stub error) (result)
--SELECT cumulative_sum_all(), cumulative_sum('/value[1,4]/') from s3 ORDER BY 1;
-- select cumulative_sum(*) (stub function and group by tag only) (explain)
--Testcase 170:
EXPLAIN VERBOSE
SELECT cumulative_sum_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                 QUERY PLAN                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (cumulative_sum_all()), tag1
   Sort Key: (cumulative_sum_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (cumulative_sum_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.cumulative_sum_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.cumulative_sum_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select cumulative_sum(*) (stub function and group by tag only) (result)
--Testcase 171:
SELECT cumulative_sum_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                           cumulative_sum_all                                           
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,100,-0.1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.30000000000000004,200,-0.30000000000000004,-200,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.6000000000000001,300,-0.6000000000000001,-300,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,200,-1.1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,3.3000000000000003,400,-3.3000000000000003,-400,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select cumulative_sum(regex) (stub function and group by tag only) (explain)
--Testcase 172:
EXPLAIN VERBOSE
SELECT cumulative_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                         QUERY PLAN                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (cumulative_sum('/value[1,4]/'::text)), tag1
   Sort Key: (cumulative_sum('/value[1,4]/'::text))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (cumulative_sum('/value[1,4]/'::text)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.cumulative_sum('/value[1,4]/'::text), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.cumulative_sum('/value[1,4]/'::text), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select cumulative_sum(regex) (stub function and group by tag only) (result)
--Testcase 173:
SELECT cumulative_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                 cumulative_sum                                  
---------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.30000000000000004,,,-200,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.6000000000000001,,,-300,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.1,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,3.3000000000000003,,,-400,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select cumulative_sum(*), cumulative_sum(regex) (stub function, expose data, explain)
--Testcase 174:
EXPLAIN VERBOSE
SELECT (cumulative_sum_all()::s3).*, (cumulative_sum('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                                                                                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=25228.31..25245.37 rows=6826 width=208)
   Output: ((((cumulative_sum_all()))::s3)."time"), ((((cumulative_sum_all()))::s3).tag1), ((((cumulative_sum_all()))::s3).value1), ((((cumulative_sum_all()))::s3).value2), ((((cumulative_sum_all()))::s3).value3), ((((cumulative_sum_all()))::s3).value4), ((((cumulative_sum_all()))::s3).__spd_url), ((((cumulative_sum('/value[1,4]/'::text)))::s3)."time"), ((((cumulative_sum('/value[1,4]/'::text)))::s3).tag1), ((((cumulative_sum('/value[1,4]/'::text)))::s3).value1), ((((cumulative_sum('/value[1,4]/'::text)))::s3).value2), ((((cumulative_sum('/value[1,4]/'::text)))::s3).value3), ((((cumulative_sum('/value[1,4]/'::text)))::s3).value4), ((((cumulative_sum('/value[1,4]/'::text)))::s3).__spd_url)
   Sort Key: ((((cumulative_sum_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..24793.60 rows=6826 width=208)
         Output: (((cumulative_sum_all()))::s3)."time", (((cumulative_sum_all()))::s3).tag1, (((cumulative_sum_all()))::s3).value1, (((cumulative_sum_all()))::s3).value2, (((cumulative_sum_all()))::s3).value3, (((cumulative_sum_all()))::s3).value4, (((cumulative_sum_all()))::s3).__spd_url, (((cumulative_sum('/value[1,4]/'::text)))::s3)."time", (((cumulative_sum('/value[1,4]/'::text)))::s3).tag1, (((cumulative_sum('/value[1,4]/'::text)))::s3).value1, (((cumulative_sum('/value[1,4]/'::text)))::s3).value2, (((cumulative_sum('/value[1,4]/'::text)))::s3).value3, (((cumulative_sum('/value[1,4]/'::text)))::s3).value4, (((cumulative_sum('/value[1,4]/'::text)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum_all(), public.cumulative_sum('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.cumulative_sum_all(), public.cumulative_sum('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select cumulative_sum(*), cumulative_sum(regex) (stub function, expose data, result)
--SELECT (cumulative_sum_all()::s3).*, (cumulative_sum('/value[1,4]/')::s3).* from s3 ORDER BY 1;
--Testcase 175:
EXPLAIN VERBOSE
SELECT derivative(value1),derivative(value2),derivative(value3),derivative(value4) FROM s3 ORDER BY 1, 2, 3, 4;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (derivative(value1)), (derivative(value2)), (derivative(value3)), (derivative(value4))
   Sort Key: (derivative(s3.value1)), (derivative(s3.value2)), (derivative(s3.value3)), (derivative(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (derivative(value1)), (derivative(value2)), (derivative(value3)), (derivative(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative(value1), public.derivative(value2), public.derivative(value3), public.derivative(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative(value1), public.derivative(value2), public.derivative(value3), public.derivative(value4) FROM public.s32influx
(9 rows)

--Testcase 176:
SELECT * FROM (
SELECT derivative(value1),derivative(value2),derivative(value3),derivative(value4) FROM s3
) as t ORDER BY 1, 2, 3, 4;
     derivative      | derivative |      derivative      | derivative 
---------------------+------------+----------------------+------------
 0.09999999999999998 |          0 | -0.09999999999999998 |          0
                 0.1 |          0 |                 -0.1 |          0
  1.0999999999999996 |          0 |  -1.0999999999999996 |          0
                 1.1 |          0 |                 -1.1 |          0
(4 rows)

--Testcase 177:
EXPLAIN VERBOSE
SELECT derivative(value1, interval '0.5s'),derivative(value2, interval '0.2s'),derivative(value3, interval '0.1s'),derivative(value4, interval '2s') FROM s3 ORDER BY 1;
                                                                                                                         QUERY PLAN                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (derivative(value1, '@ 0.5 secs'::interval)), (derivative(value2, '@ 0.2 secs'::interval)), (derivative(value3, '@ 0.1 secs'::interval)), (derivative(value4, '@ 2 secs'::interval))
   Sort Key: (derivative(s3.value1, '@ 0.5 secs'::interval))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (derivative(value1, '@ 0.5 secs'::interval)), (derivative(value2, '@ 0.2 secs'::interval)), (derivative(value3, '@ 0.1 secs'::interval)), (derivative(value4, '@ 2 secs'::interval))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative(value1, '@ 0.5 secs'::interval), public.derivative(value2, '@ 0.2 secs'::interval), public.derivative(value3, '@ 0.1 secs'::interval), public.derivative(value4, '@ 2 secs'::interval) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative(value1, '@ 0.5 secs'::interval), public.derivative(value2, '@ 0.2 secs'::interval), public.derivative(value3, '@ 0.1 secs'::interval), public.derivative(value4, '@ 2 secs'::interval) FROM public.s32influx
(9 rows)

--Testcase 178:
SELECT derivative(value1, interval '0.5s'),derivative(value2, interval '0.2s'),derivative(value3, interval '0.1s'),derivative(value4, interval '2s') FROM s3 ORDER BY 1;
     derivative      | derivative |      derivative       | derivative 
---------------------+------------+-----------------------+------------
 0.04999999999999999 |          0 | -0.009999999999999998 |          0
                0.05 |          0 |                 -0.01 |          0
  0.5499999999999998 |          0 |  -0.10999999999999996 |          0
                0.55 |          0 |  -0.11000000000000001 |          0
(4 rows)

-- select derivative(*) (stub function, explain)
--Testcase 179:
EXPLAIN VERBOSE
SELECT derivative_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (derivative_all())
   Sort Key: (derivative_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (derivative_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative_all() FROM public.s32influx
(9 rows)

-- select derivative(*) (stub function, result)
--Testcase 180:
SELECT * FROM (
SELECT derivative_all() from s3
) as t ORDER BY 1;
                                          derivative_all                                           
---------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,-0.1,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,-0.09999999999999998,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,-1.1,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,0,-1.0999999999999996,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select derivative(regex) (stub function, explain)
--Testcase 181:
EXPLAIN VERBOSE
SELECT derivative('/value[1,4]/') from s3 ORDER BY 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (derivative('/value[1,4]/'::text))
   Sort Key: (derivative('/value[1,4]/'::text))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (derivative('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select derivative(regex) (stub function, result)
--Testcase 182:
SELECT derivative('/value[1,4]/') from s3 ORDER BY 1;
                                  derivative                                  
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select multiple star and regex functions (do not push down, raise warning and stub error) (explain)
--Testcase 183:
EXPLAIN VERBOSE
SELECT derivative_all(), derivative('/value[1,4]/') from s3 ORDER BY 1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=4272.49..4289.55 rows=6826 width=64)
   Output: (derivative_all()), (derivative('/value[1,4]/'::text))
   Sort Key: (derivative_all())
   ->  Foreign Scan on public.s3  (cost=200.00..3837.78 rows=6826 width=64)
         Output: (derivative_all()), (derivative('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative_all(), public.derivative('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative_all(), public.derivative('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select multiple star and regex functions (do not push down, raise warning and stub error) (explain)
--SELECT derivative_all(), derivative('/value[1,4]/') from s3 ORDER BY 1;
-- select derivative(*) (stub function and group by tag only) (explain)
--Testcase 184:
EXPLAIN VERBOSE
SELECT derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                               QUERY PLAN                                                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (derivative_all()), tag1
   Sort Key: (derivative_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (derivative_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.derivative_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.derivative_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select derivative(*) (stub function and group by tag only) (result)
--Testcase 185:
SELECT derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                          derivative_all                                           
---------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,-0.1,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,-0.09999999999999998,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,-1.1,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select derivative(regex) (stub function and group by tag only) (explain)
--Testcase 186:
EXPLAIN VERBOSE
SELECT derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (derivative('/value[1,4]/'::text)), tag1
   Sort Key: (derivative('/value[1,4]/'::text))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (derivative('/value[1,4]/'::text)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.derivative('/value[1,4]/'::text), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.derivative('/value[1,4]/'::text), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select derivative(regex) (stub function and group by tag only) (result)
--Testcase 187:
SELECT derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                  derivative                                  
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select derivative(*) (stub function, expose data, explain)
--Testcase 188:
EXPLAIN VERBOSE
SELECT (derivative_all()::s3).* from s3 ORDER BY 1;
                                                                                                                                  QUERY PLAN                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((derivative_all()))::s3)."time"), ((((derivative_all()))::s3).tag1), ((((derivative_all()))::s3).value1), ((((derivative_all()))::s3).value2), ((((derivative_all()))::s3).value3), ((((derivative_all()))::s3).value4), ((((derivative_all()))::s3).__spd_url)
   Sort Key: ((((derivative_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((derivative_all()))::s3)."time", (((derivative_all()))::s3).tag1, (((derivative_all()))::s3).value1, (((derivative_all()))::s3).value2, (((derivative_all()))::s3).value3, (((derivative_all()))::s3).value4, (((derivative_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative_all() FROM public.s32influx
(9 rows)

-- select derivative(*) (stub function, expose data, result)
--Testcase 189:
SELECT * FROM (
SELECT (derivative_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 |        value3        | value4 |          __spd_url           
------------------------+------+---------------------+--------+----------------------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |      0 |                 -0.1 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |      0 | -0.09999999999999998 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |      0 |                 -1.1 |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |      0 |  -1.0999999999999996 |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select derivative(regex) (stub function, expose data, explain)
--Testcase 190:
EXPLAIN VERBOSE
SELECT (derivative('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((derivative('/value[1,4]/'::text)))::s3)."time"), ((((derivative('/value[1,4]/'::text)))::s3).tag1), ((((derivative('/value[1,4]/'::text)))::s3).value1), ((((derivative('/value[1,4]/'::text)))::s3).value2), ((((derivative('/value[1,4]/'::text)))::s3).value3), ((((derivative('/value[1,4]/'::text)))::s3).value4), ((((derivative('/value[1,4]/'::text)))::s3).__spd_url)
   Sort Key: ((((derivative('/value[1,4]/'::text)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((derivative('/value[1,4]/'::text)))::s3)."time", (((derivative('/value[1,4]/'::text)))::s3).tag1, (((derivative('/value[1,4]/'::text)))::s3).value1, (((derivative('/value[1,4]/'::text)))::s3).value2, (((derivative('/value[1,4]/'::text)))::s3).value3, (((derivative('/value[1,4]/'::text)))::s3).value4, (((derivative('/value[1,4]/'::text)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.derivative('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.derivative('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select derivative(regex) (stub function, expose data, result)
--Testcase 191:
SELECT * FROM (
SELECT (derivative('/value[1,4]/')::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |        |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 192:
EXPLAIN VERBOSE
SELECT non_negative_derivative(value1),non_negative_derivative(value2),non_negative_derivative(value3),non_negative_derivative(value4) FROM s3 ORDER BY 1, 2, 3, 4;
                                                                                                    QUERY PLAN                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (non_negative_derivative(value1)), (non_negative_derivative(value2)), (non_negative_derivative(value3)), (non_negative_derivative(value4))
   Sort Key: (non_negative_derivative(s3.value1)), (non_negative_derivative(s3.value2)), (non_negative_derivative(s3.value3)), (non_negative_derivative(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (non_negative_derivative(value1)), (non_negative_derivative(value2)), (non_negative_derivative(value3)), (non_negative_derivative(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative(value1), public.non_negative_derivative(value2), public.non_negative_derivative(value3), public.non_negative_derivative(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative(value1), public.non_negative_derivative(value2), public.non_negative_derivative(value3), public.non_negative_derivative(value4) FROM public.s32influx
(9 rows)

--Testcase 193:
SELECT * FROM (
SELECT non_negative_derivative(value1),non_negative_derivative(value2),non_negative_derivative(value3),non_negative_derivative(value4) FROM s3
) as t ORDER BY 1, 2, 3, 4;
 non_negative_derivative | non_negative_derivative | non_negative_derivative | non_negative_derivative 
-------------------------+-------------------------+-------------------------+-------------------------
     0.09999999999999998 |                       0 |                         |                       0
                     0.1 |                       0 |                         |                       0
      1.0999999999999996 |                       0 |                         |                       0
                     1.1 |                       0 |                         |                       0
(4 rows)

--Testcase 194:
EXPLAIN VERBOSE
SELECT non_negative_derivative(value1, interval '0.5s'),non_negative_derivative(value2, interval '0.2s'),non_negative_derivative(value3, interval '0.1s'),non_negative_derivative(value4, interval '2s') FROM s3 ORDER BY 1, 2, 3, 4;
                                                                                                                                                   QUERY PLAN                                                                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (non_negative_derivative(value1, '@ 0.5 secs'::interval)), (non_negative_derivative(value2, '@ 0.2 secs'::interval)), (non_negative_derivative(value3, '@ 0.1 secs'::interval)), (non_negative_derivative(value4, '@ 2 secs'::interval))
   Sort Key: (non_negative_derivative(s3.value1, '@ 0.5 secs'::interval)), (non_negative_derivative(s3.value2, '@ 0.2 secs'::interval)), (non_negative_derivative(s3.value3, '@ 0.1 secs'::interval)), (non_negative_derivative(s3.value4, '@ 2 secs'::interval))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (non_negative_derivative(value1, '@ 0.5 secs'::interval)), (non_negative_derivative(value2, '@ 0.2 secs'::interval)), (non_negative_derivative(value3, '@ 0.1 secs'::interval)), (non_negative_derivative(value4, '@ 2 secs'::interval))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative(value1, '@ 0.5 secs'::interval), public.non_negative_derivative(value2, '@ 0.2 secs'::interval), public.non_negative_derivative(value3, '@ 0.1 secs'::interval), public.non_negative_derivative(value4, '@ 2 secs'::interval) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative(value1, '@ 0.5 secs'::interval), public.non_negative_derivative(value2, '@ 0.2 secs'::interval), public.non_negative_derivative(value3, '@ 0.1 secs'::interval), public.non_negative_derivative(value4, '@ 2 secs'::interval) FROM public.s32influx
(9 rows)

--Testcase 195:
SELECT non_negative_derivative(value1, interval '0.5s'),non_negative_derivative(value2, interval '0.2s'),non_negative_derivative(value3, interval '0.1s'),non_negative_derivative(value4, interval '2s') FROM s3 ORDER BY 1, 2, 3, 4;
 non_negative_derivative | non_negative_derivative | non_negative_derivative | non_negative_derivative 
-------------------------+-------------------------+-------------------------+-------------------------
     0.04999999999999999 |                       0 |                         |                       0
                    0.05 |                       0 |                         |                       0
      0.5499999999999998 |                       0 |                         |                       0
                    0.55 |                       0 |                         |                       0
(4 rows)

-- select non_negative_derivative(*) (stub function, explain)
--Testcase 196:
EXPLAIN VERBOSE
SELECT non_negative_derivative_all() from s3 ORDER BY 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (non_negative_derivative_all())
   Sort Key: (non_negative_derivative_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (non_negative_derivative_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative_all() FROM public.s32influx
(9 rows)

-- select non_negative_derivative(*) (stub function, result)
--Testcase 197:
SELECT * FROM (
SELECT non_negative_derivative_all() from s3
) as t ORDER BY 1;
                          non_negative_derivative_all                          
-------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,0,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select non_negative_derivative(regex) (stub function, explain)
--Testcase 198:
EXPLAIN VERBOSE
SELECT non_negative_derivative('/value[1,4]/') from s3 ORDER BY 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (non_negative_derivative('/value[1,4]/'::text))
   Sort Key: (non_negative_derivative('/value[1,4]/'::text))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (non_negative_derivative('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select non_negative_derivative(regex) (stub function, result)
--Testcase 199:
SELECT non_negative_derivative('/value[1,4]/') from s3 ORDER BY 1;
                           non_negative_derivative                            
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select non_negative_derivative(*) (stub function and group by tag only) (explain)
--Testcase 200:
EXPLAIN VERBOSE
SELECT non_negative_derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (non_negative_derivative_all()), tag1
   Sort Key: (non_negative_derivative_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (non_negative_derivative_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_derivative_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_derivative_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select non_negative_derivative(*) (stub function and group by tag only) (result)
--Testcase 201:
SELECT non_negative_derivative_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                          non_negative_derivative_all                          
-------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select non_negative_derivative(regex) (stub function and group by tag only) (explain)
--Testcase 202:
EXPLAIN VERBOSE
SELECT non_negative_derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (non_negative_derivative('/value[1,4]/'::text)), tag1
   Sort Key: (non_negative_derivative('/value[1,4]/'::text))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (non_negative_derivative('/value[1,4]/'::text)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_derivative('/value[1,4]/'::text), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_derivative('/value[1,4]/'::text), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select non_negative_derivative(regex) (stub function and group by tag only) (result)
--Testcase 203:
SELECT non_negative_derivative('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                           non_negative_derivative                            
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select non_negative_derivative(*) (stub function, expose data, explain)
--Testcase 204:
EXPLAIN VERBOSE
SELECT (non_negative_derivative_all()::s3).* from s3 ORDER BY 1;
                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((non_negative_derivative_all()))::s3)."time"), ((((non_negative_derivative_all()))::s3).tag1), ((((non_negative_derivative_all()))::s3).value1), ((((non_negative_derivative_all()))::s3).value2), ((((non_negative_derivative_all()))::s3).value3), ((((non_negative_derivative_all()))::s3).value4), ((((non_negative_derivative_all()))::s3).__spd_url)
   Sort Key: ((((non_negative_derivative_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((non_negative_derivative_all()))::s3)."time", (((non_negative_derivative_all()))::s3).tag1, (((non_negative_derivative_all()))::s3).value1, (((non_negative_derivative_all()))::s3).value2, (((non_negative_derivative_all()))::s3).value3, (((non_negative_derivative_all()))::s3).value4, (((non_negative_derivative_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative_all() FROM public.s32influx
(9 rows)

-- select non_negative_derivative(*) (stub function, expose data, result)
--Testcase 205:
SELECT * FROM (
SELECT (non_negative_derivative_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |      0 |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |      0 |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |      0 |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |      0 |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select non_negative_derivative(regex) (stub function, expose data, explain)
--Testcase 206:
EXPLAIN VERBOSE
SELECT (non_negative_derivative('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((non_negative_derivative('/value[1,4]/'::text)))::s3)."time"), ((((non_negative_derivative('/value[1,4]/'::text)))::s3).tag1), ((((non_negative_derivative('/value[1,4]/'::text)))::s3).value1), ((((non_negative_derivative('/value[1,4]/'::text)))::s3).value2), ((((non_negative_derivative('/value[1,4]/'::text)))::s3).value3), ((((non_negative_derivative('/value[1,4]/'::text)))::s3).value4), ((((non_negative_derivative('/value[1,4]/'::text)))::s3).__spd_url)
   Sort Key: ((((non_negative_derivative('/value[1,4]/'::text)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((non_negative_derivative('/value[1,4]/'::text)))::s3)."time", (((non_negative_derivative('/value[1,4]/'::text)))::s3).tag1, (((non_negative_derivative('/value[1,4]/'::text)))::s3).value1, (((non_negative_derivative('/value[1,4]/'::text)))::s3).value2, (((non_negative_derivative('/value[1,4]/'::text)))::s3).value3, (((non_negative_derivative('/value[1,4]/'::text)))::s3).value4, (((non_negative_derivative('/value[1,4]/'::text)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_derivative('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select non_negative_derivative(regex) (stub function, expose data, result)
--Testcase 207:
SELECT * FROM (
SELECT (non_negative_derivative('/value[1,4]/')::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |        |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 208:
EXPLAIN VERBOSE
SELECT difference(value1),difference(value2),difference(value3),difference(value4) FROM s3 ORDER BY 1, 2, 3, 4;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (difference(value1)), (difference(value2)), (difference(value3)), (difference(value4))
   Sort Key: (difference(s3.value1)), (difference(s3.value2)), (difference(s3.value3)), (difference(s3.value4))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (difference(value1)), (difference(value2)), (difference(value3)), (difference(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.difference(value1), public.difference(value2), public.difference(value3), public.difference(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.difference(value1), public.difference(value2), public.difference(value3), public.difference(value4) FROM public.s32influx
(9 rows)

--Testcase 209:
SELECT difference(value1),difference(value2),difference(value3),difference(value4) FROM s3 ORDER BY 1, 2, 3, 4;
     difference      | difference |      difference      | difference 
---------------------+------------+----------------------+------------
 0.09999999999999998 |          0 | -0.09999999999999998 |          0
                 0.1 |          0 |                 -0.1 |          0
  1.0999999999999996 |          0 |  -1.0999999999999996 |          0
                 1.1 |          0 |                 -1.1 |          0
(4 rows)

-- select difference(*) (stub function, explain)
--Testcase 210:
EXPLAIN VERBOSE
SELECT difference_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (difference_all())
   Sort Key: (difference_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (difference_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.difference_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.difference_all() FROM public.s32influx
(9 rows)

-- select difference(*) (stub function, result)
--Testcase 211:
SELECT * FROM (
SELECT difference_all() from s3
) as t ORDER BY 1;
                                          difference_all                                           
---------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,-0.1,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,-0.09999999999999998,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,-1.1,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,0,-1.0999999999999996,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select difference(regex) (stub function, explain)
--Testcase 212:
EXPLAIN VERBOSE
SELECT difference('/value[1,4]/') from s3 ORDER BY 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (difference('/value[1,4]/'::text))
   Sort Key: (difference('/value[1,4]/'::text))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (difference('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.difference('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.difference('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select difference(regex) (stub function, result)
--Testcase 213:
SELECT difference('/value[1,4]/') from s3 ORDER BY 1;
                                  difference                                  
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select difference(*) (stub function and group by tag only) (explain)
--Testcase 214:
EXPLAIN VERBOSE
SELECT difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                               QUERY PLAN                                                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (difference_all()), tag1
   Sort Key: (difference_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (difference_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.difference_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.difference_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select difference(*) (stub function and group by tag only) (result)
--Testcase 215:
SELECT difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                          difference_all                                           
---------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,-0.1,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,-0.09999999999999998,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,-1.1,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select difference(regex) (stub function and group by tag only) (explain)
--Testcase 216:
EXPLAIN VERBOSE
SELECT difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (difference('/value[1,4]/'::text)), tag1
   Sort Key: (difference('/value[1,4]/'::text))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (difference('/value[1,4]/'::text)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.difference('/value[1,4]/'::text), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.difference('/value[1,4]/'::text), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select difference(regex) (stub function and group by tag only) (result)
--Testcase 217:
SELECT difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                  difference                                  
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select difference(*) (stub function, expose data, explain)
--Testcase 218:
EXPLAIN VERBOSE
SELECT (difference_all()::s3).* from s3 ORDER BY 1;
                                                                                                                                  QUERY PLAN                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((difference_all()))::s3)."time"), ((((difference_all()))::s3).tag1), ((((difference_all()))::s3).value1), ((((difference_all()))::s3).value2), ((((difference_all()))::s3).value3), ((((difference_all()))::s3).value4), ((((difference_all()))::s3).__spd_url)
   Sort Key: ((((difference_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((difference_all()))::s3)."time", (((difference_all()))::s3).tag1, (((difference_all()))::s3).value1, (((difference_all()))::s3).value2, (((difference_all()))::s3).value3, (((difference_all()))::s3).value4, (((difference_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.difference_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.difference_all() FROM public.s32influx
(9 rows)

-- select difference(*) (stub function, expose data, result)
--Testcase 219:
SELECT * FROM (
SELECT (difference_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 |        value3        | value4 |          __spd_url           
------------------------+------+---------------------+--------+----------------------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |      0 |                 -0.1 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |      0 | -0.09999999999999998 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |      0 |                 -1.1 |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |      0 |  -1.0999999999999996 |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select difference(regex) (stub function, expose data, explain)
--Testcase 220:
EXPLAIN VERBOSE
SELECT (difference('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((difference('/value[1,4]/'::text)))::s3)."time"), ((((difference('/value[1,4]/'::text)))::s3).tag1), ((((difference('/value[1,4]/'::text)))::s3).value1), ((((difference('/value[1,4]/'::text)))::s3).value2), ((((difference('/value[1,4]/'::text)))::s3).value3), ((((difference('/value[1,4]/'::text)))::s3).value4), ((((difference('/value[1,4]/'::text)))::s3).__spd_url)
   Sort Key: ((((difference('/value[1,4]/'::text)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((difference('/value[1,4]/'::text)))::s3)."time", (((difference('/value[1,4]/'::text)))::s3).tag1, (((difference('/value[1,4]/'::text)))::s3).value1, (((difference('/value[1,4]/'::text)))::s3).value2, (((difference('/value[1,4]/'::text)))::s3).value3, (((difference('/value[1,4]/'::text)))::s3).value4, (((difference('/value[1,4]/'::text)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.difference('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.difference('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select difference(regex) (stub function, expose data, result)
--Testcase 221:
SELECT * FROM (
SELECT (difference('/value[1,4]/')::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |        |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 222:
EXPLAIN VERBOSE
SELECT non_negative_difference(value1),non_negative_difference(value2),non_negative_difference(value3),non_negative_difference(value4) FROM s3 ORDER BY 1;
                                                                                                    QUERY PLAN                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (non_negative_difference(value1)), (non_negative_difference(value2)), (non_negative_difference(value3)), (non_negative_difference(value4))
   Sort Key: (non_negative_difference(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (non_negative_difference(value1)), (non_negative_difference(value2)), (non_negative_difference(value3)), (non_negative_difference(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference(value1), public.non_negative_difference(value2), public.non_negative_difference(value3), public.non_negative_difference(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference(value1), public.non_negative_difference(value2), public.non_negative_difference(value3), public.non_negative_difference(value4) FROM public.s32influx
(9 rows)

--Testcase 223:
SELECT non_negative_difference(value1),non_negative_difference(value2),non_negative_difference(value3),non_negative_difference(value4) FROM s3 ORDER BY 1;
 non_negative_difference | non_negative_difference | non_negative_difference | non_negative_difference 
-------------------------+-------------------------+-------------------------+-------------------------
     0.09999999999999998 |                       0 |                         |                       0
                     0.1 |                       0 |                         |                       0
      1.0999999999999996 |                       0 |                         |                       0
                     1.1 |                       0 |                         |                       0
(4 rows)

-- select non_negative_difference(*) (stub function, explain)
--Testcase 224:
EXPLAIN VERBOSE
SELECT non_negative_difference_all() from s3 ORDER BY 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (non_negative_difference_all())
   Sort Key: (non_negative_difference_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (non_negative_difference_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference_all() FROM public.s32influx
(9 rows)

-- select non_negative_difference(*) (stub function, result)
--Testcase 225:
SELECT * FROM (
SELECT non_negative_difference_all() from s3
) as t ORDER BY 1;
                          non_negative_difference_all                          
-------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,0,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select non_negative_difference(regex) (stub function, explain)
--Testcase 226:
EXPLAIN VERBOSE
SELECT non_negative_difference('/value[1,4]/') from s3 ORDER BY 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (non_negative_difference('/value[1,4]/'::text))
   Sort Key: (non_negative_difference('/value[1,4]/'::text))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (non_negative_difference('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select non_negative_difference(*), non_negative_difference(regex) (stub function, result)
--Testcase 227:
SELECT non_negative_difference('/value[1,4]/') from s3 ORDER BY 1;
                           non_negative_difference                            
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.0999999999999996,,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select non_negative_difference(*) (stub function and group by tag only) (explain)
--Testcase 228:
EXPLAIN VERBOSE
SELECT non_negative_difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (non_negative_difference_all()), tag1
   Sort Key: (non_negative_difference_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (non_negative_difference_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_difference_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_difference_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select non_negative_difference(*) (stub function and group by tag only) (result)
--Testcase 229:
SELECT non_negative_difference_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                          non_negative_difference_all                          
-------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,0,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,0,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select non_negative_difference(regex) (stub function and group by tag only) (explain)
--Testcase 230:
EXPLAIN VERBOSE
SELECT non_negative_difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (non_negative_difference('/value[1,4]/'::text)), tag1
   Sort Key: (non_negative_difference('/value[1,4]/'::text))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (non_negative_difference('/value[1,4]/'::text)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_difference('/value[1,4]/'::text), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.non_negative_difference('/value[1,4]/'::text), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select non_negative_difference(regex) (stub function and group by tag only) (result)
--Testcase 231:
SELECT non_negative_difference('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                           non_negative_difference                            
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09999999999999998,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1,,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select non_negative_difference(*) (stub function, expose data, explain)
--Testcase 232:
EXPLAIN VERBOSE
SELECT (non_negative_difference_all()::s3).* from s3 ORDER BY 1;
                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((non_negative_difference_all()))::s3)."time"), ((((non_negative_difference_all()))::s3).tag1), ((((non_negative_difference_all()))::s3).value1), ((((non_negative_difference_all()))::s3).value2), ((((non_negative_difference_all()))::s3).value3), ((((non_negative_difference_all()))::s3).value4), ((((non_negative_difference_all()))::s3).__spd_url)
   Sort Key: ((((non_negative_difference_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((non_negative_difference_all()))::s3)."time", (((non_negative_difference_all()))::s3).tag1, (((non_negative_difference_all()))::s3).value1, (((non_negative_difference_all()))::s3).value2, (((non_negative_difference_all()))::s3).value3, (((non_negative_difference_all()))::s3).value4, (((non_negative_difference_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference_all() FROM public.s32influx
(9 rows)

-- select non_negative_difference(*) (stub function, expose data, result)
--Testcase 233:
SELECT * FROM (
SELECT (non_negative_difference_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |      0 |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |      0 |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |      0 |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |      0 |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select non_negative_difference(regex) (stub function, expose data, explain)
--Testcase 234:
EXPLAIN VERBOSE
SELECT (non_negative_difference('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((non_negative_difference('/value[1,4]/'::text)))::s3)."time"), ((((non_negative_difference('/value[1,4]/'::text)))::s3).tag1), ((((non_negative_difference('/value[1,4]/'::text)))::s3).value1), ((((non_negative_difference('/value[1,4]/'::text)))::s3).value2), ((((non_negative_difference('/value[1,4]/'::text)))::s3).value3), ((((non_negative_difference('/value[1,4]/'::text)))::s3).value4), ((((non_negative_difference('/value[1,4]/'::text)))::s3).__spd_url)
   Sort Key: ((((non_negative_difference('/value[1,4]/'::text)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((non_negative_difference('/value[1,4]/'::text)))::s3)."time", (((non_negative_difference('/value[1,4]/'::text)))::s3).tag1, (((non_negative_difference('/value[1,4]/'::text)))::s3).value1, (((non_negative_difference('/value[1,4]/'::text)))::s3).value2, (((non_negative_difference('/value[1,4]/'::text)))::s3).value3, (((non_negative_difference('/value[1,4]/'::text)))::s3).value4, (((non_negative_difference('/value[1,4]/'::text)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.non_negative_difference('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select non_negative_difference(regex) (stub function, expose data, result)
--Testcase 235:
SELECT * FROM (
SELECT (non_negative_difference('/value[1,4]/')::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |                 0.1 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 0.09999999999999998 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                 1.1 |        |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |  1.0999999999999996 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 236:
EXPLAIN VERBOSE
SELECT elapsed(value1),elapsed(value2),elapsed(value3),elapsed(value4) FROM s3 ORDER BY 1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (elapsed(value1)), (elapsed(value2)), (elapsed(value3)), (elapsed(value4))
   Sort Key: (elapsed(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (elapsed(value1)), (elapsed(value2)), (elapsed(value3)), (elapsed(value4))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.elapsed(value1), public.elapsed(value2), public.elapsed(value3), public.elapsed(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.elapsed(value1), public.elapsed(value2), public.elapsed(value3), public.elapsed(value4) FROM public.s32influx
(9 rows)

--Testcase 237:
SELECT elapsed(value1),elapsed(value2),elapsed(value3),elapsed(value4) FROM s3 ORDER BY 1;
  elapsed   |  elapsed   |  elapsed   |  elapsed   
------------+------------+------------+------------
 1000000000 | 1000000000 | 1000000000 | 1000000000
 1000000000 | 1000000000 | 1000000000 | 1000000000
 1000000000 | 1000000000 | 1000000000 | 1000000000
 1000000000 | 1000000000 | 1000000000 | 1000000000
(4 rows)

--Testcase 238:
EXPLAIN VERBOSE
SELECT elapsed(value1, interval '0.5s'),elapsed(value2, interval '0.2s'),elapsed(value3, interval '0.1s'),elapsed(value4, interval '2s') FROM s3 ORDER BY 1;
                                                                                                                   QUERY PLAN                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (elapsed(value1, '@ 0.5 secs'::interval)), (elapsed(value2, '@ 0.2 secs'::interval)), (elapsed(value3, '@ 0.1 secs'::interval)), (elapsed(value4, '@ 2 secs'::interval))
   Sort Key: (elapsed(s3.value1, '@ 0.5 secs'::interval))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (elapsed(value1, '@ 0.5 secs'::interval)), (elapsed(value2, '@ 0.2 secs'::interval)), (elapsed(value3, '@ 0.1 secs'::interval)), (elapsed(value4, '@ 2 secs'::interval))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.elapsed(value1, '@ 0.5 secs'::interval), public.elapsed(value2, '@ 0.2 secs'::interval), public.elapsed(value3, '@ 0.1 secs'::interval), public.elapsed(value4, '@ 2 secs'::interval) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.elapsed(value1, '@ 0.5 secs'::interval), public.elapsed(value2, '@ 0.2 secs'::interval), public.elapsed(value3, '@ 0.1 secs'::interval), public.elapsed(value4, '@ 2 secs'::interval) FROM public.s32influx
(9 rows)

--Testcase 239:
SELECT elapsed(value1, interval '0.5s'),elapsed(value2, interval '0.2s'),elapsed(value3, interval '0.1s'),elapsed(value4, interval '2s') FROM s3 ORDER BY 1;
 elapsed | elapsed | elapsed | elapsed 
---------+---------+---------+---------
       2 |       5 |      10 |       0
       2 |       5 |      10 |       0
       2 |       5 |      10 |       0
       2 |       5 |      10 |       0
(4 rows)

-- select elapsed(*) (stub function, explain)
--Testcase 240:
EXPLAIN VERBOSE
SELECT elapsed_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (elapsed_all())
   Sort Key: (elapsed_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (elapsed_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.elapsed_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.elapsed_all() FROM public.s32influx
(9 rows)

-- select elapsed(*) (stub function, result)
--Testcase 241:
SELECT * FROM (
SELECT elapsed_all() from s3
) as t ORDER BY 1;
                                           elapsed_all                                            
--------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select elapsed(regex) (stub function, explain)
--Testcase 242:
EXPLAIN VERBOSE
SELECT elapsed('/value[1,4]/') from s3 ORDER BY 1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (elapsed('/value[1,4]/'::text))
   Sort Key: (elapsed('/value[1,4]/'::text))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (elapsed('/value[1,4]/'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.elapsed('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.elapsed('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select elapsed(regex) (stub function, result)
--Testcase 243:
SELECT elapsed('/value[1,4]/') from s3 ORDER BY 1;
                                   elapsed                                    
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,1000000000,,,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1000000000,,,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1000000000,,,1000000000,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1000000000,,,1000000000,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select elapsed(*) (stub function and group by tag only) (explain)
--Testcase 244:
EXPLAIN VERBOSE
SELECT elapsed_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                              QUERY PLAN                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (elapsed_all()), tag1
   Sort Key: (elapsed_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (elapsed_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.elapsed_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.elapsed_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select elapsed(*) (stub function and group by tag only) (result)
--Testcase 245:
SELECT elapsed_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                           elapsed_all                                            
--------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1000000000,1000000000,1000000000,1000000000,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select elapsed(regex) (stub function and group by tag only) (explain)
--Testcase 246:
EXPLAIN VERBOSE
SELECT elapsed('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (elapsed('/value[1,4]/'::text)), tag1
   Sort Key: (elapsed('/value[1,4]/'::text))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (elapsed('/value[1,4]/'::text)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.elapsed('/value[1,4]/'::text), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.elapsed('/value[1,4]/'::text), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select elapsed(regex) (stub function and group by tag only) (result)
--Testcase 247:
SELECT elapsed('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                   elapsed                                    
------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,1000000000,,,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1000000000,,,1000000000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1000000000,,,1000000000,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select elapsed(*) (stub function, expose data, explain)
--Testcase 248:
EXPLAIN VERBOSE
SELECT (elapsed_all()::s3).* from s3 ORDER BY 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((elapsed_all()))::s3)."time"), ((((elapsed_all()))::s3).tag1), ((((elapsed_all()))::s3).value1), ((((elapsed_all()))::s3).value2), ((((elapsed_all()))::s3).value3), ((((elapsed_all()))::s3).value4), ((((elapsed_all()))::s3).__spd_url)
   Sort Key: ((((elapsed_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((elapsed_all()))::s3)."time", (((elapsed_all()))::s3).tag1, (((elapsed_all()))::s3).value1, (((elapsed_all()))::s3).value2, (((elapsed_all()))::s3).value3, (((elapsed_all()))::s3).value4, (((elapsed_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.elapsed_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.elapsed_all() FROM public.s32influx
(9 rows)

-- select elapsed(*) (stub function, expose data, result)
--Testcase 249:
SELECT * FROM (
SELECT (elapsed_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |   value1   |   value2   |   value3   |   value4   |          __spd_url           
------------------------+------+------------+------------+------------+------------+------------------------------
 1970-01-01 09:00:01+09 |      | 1000000000 | 1000000000 | 1000000000 | 1000000000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 1000000000 | 1000000000 | 1000000000 | 1000000000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      | 1000000000 | 1000000000 | 1000000000 | 1000000000 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      | 1000000000 | 1000000000 | 1000000000 | 1000000000 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select elapsed(regex) (stub function, expose data, explain)
--Testcase 250:
EXPLAIN VERBOSE
SELECT (elapsed('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                               QUERY PLAN                                                                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((elapsed('/value[1,4]/'::text)))::s3)."time"), ((((elapsed('/value[1,4]/'::text)))::s3).tag1), ((((elapsed('/value[1,4]/'::text)))::s3).value1), ((((elapsed('/value[1,4]/'::text)))::s3).value2), ((((elapsed('/value[1,4]/'::text)))::s3).value3), ((((elapsed('/value[1,4]/'::text)))::s3).value4), ((((elapsed('/value[1,4]/'::text)))::s3).__spd_url)
   Sort Key: ((((elapsed('/value[1,4]/'::text)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((elapsed('/value[1,4]/'::text)))::s3)."time", (((elapsed('/value[1,4]/'::text)))::s3).tag1, (((elapsed('/value[1,4]/'::text)))::s3).value1, (((elapsed('/value[1,4]/'::text)))::s3).value2, (((elapsed('/value[1,4]/'::text)))::s3).value3, (((elapsed('/value[1,4]/'::text)))::s3).value4, (((elapsed('/value[1,4]/'::text)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.elapsed('/value[1,4]/'::text) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.elapsed('/value[1,4]/'::text) FROM public.s32influx
(9 rows)

-- select elapsed(regex) (stub function, expose data, result)
--Testcase 251:
SELECT * FROM (
SELECT (elapsed('/value[1,4]/')::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |   value1   | value2 | value3 |   value4   |          __spd_url           
------------------------+------+------------+--------+--------+------------+------------------------------
 1970-01-01 09:00:01+09 |      | 1000000000 |        |        | 1000000000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      | 1000000000 |        |        | 1000000000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      | 1000000000 |        |        | 1000000000 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      | 1000000000 |        |        | 1000000000 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 252:
EXPLAIN VERBOSE
SELECT moving_average(value1, 2),moving_average(value2, 2),moving_average(value3, 2),moving_average(value4, 2) FROM s3 ORDER BY 1;
                                                                                        QUERY PLAN                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (moving_average(value1, 2)), (moving_average(value2, 2)), (moving_average(value3, 2)), (moving_average(value4, 2))
   Sort Key: (moving_average(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (moving_average(value1, 2)), (moving_average(value2, 2)), (moving_average(value3, 2)), (moving_average(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.moving_average(value1, 2), public.moving_average(value2, 2), public.moving_average(value3, 2), public.moving_average(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.moving_average(value1, 2), public.moving_average(value2, 2), public.moving_average(value3, 2), public.moving_average(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 253:
SELECT moving_average(value1, 2),moving_average(value2, 2),moving_average(value3, 2),moving_average(value4, 2) FROM s3 ORDER BY 1;
   moving_average    | moving_average |    moving_average    | moving_average 
---------------------+----------------+----------------------+----------------
 0.15000000000000002 |            100 | -0.15000000000000002 |           -100
                0.25 |            100 |                -0.25 |           -100
  1.6500000000000001 |            200 |  -1.6500000000000001 |           -200
                2.75 |            200 |                -2.75 |           -200
(4 rows)

-- select moving_average(*) (stub function, explain)
--Testcase 254:
EXPLAIN VERBOSE
SELECT moving_average_all(2) from s3 ORDER BY 1;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (moving_average_all(2))
   Sort Key: (moving_average_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (moving_average_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.moving_average_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.moving_average_all(2) FROM public.s32influx
(9 rows)

-- select moving_average(*) (stub function, result)
--Testcase 255:
SELECT * FROM (
SELECT moving_average_all(2) from s3
) as t ORDER BY 1;
                                           moving_average_all                                           
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.15000000000000002,100,-0.15000000000000002,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25,100,-0.25,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.6500000000000001,200,-1.6500000000000001,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,2.75,200,-2.75,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select moving_average(regex) (stub function, explain)
--Testcase 256:
EXPLAIN VERBOSE
SELECT moving_average('/value[1,4]/', 2) from s3 ORDER BY 1;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (moving_average('/value[1,4]/'::text, 2))
   Sort Key: (moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (moving_average('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.moving_average('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.moving_average('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select moving_average(regex) (stub function, result)
--Testcase 257:
SELECT moving_average('/value[1,4]/', 2) from s3 ORDER BY 1;
                                 moving_average                                  
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.15000000000000002,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.6500000000000001,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,2.75,,,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select moving_average(*) (stub function and group by tag only) (explain)
--Testcase 258:
EXPLAIN VERBOSE
SELECT moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (moving_average_all(2)), tag1
   Sort Key: (moving_average_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (moving_average_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.moving_average_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.moving_average_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select moving_average(*) (stub function and group by tag only) (result)
--Testcase 259:
SELECT moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                           moving_average_all                                           
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.15000000000000002,100,-0.15000000000000002,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25,100,-0.25,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.6500000000000001,200,-1.6500000000000001,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 260:
EXPLAIN VERBOSE
SELECT moving_average('/value[1,4]/', 2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                           QUERY PLAN                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (moving_average('/value[1,4]/'::text, 2)), tag1
   Sort Key: (moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (moving_average('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select moving_average(regex) (stub function and group by tag only) (result)
--Testcase 261:
SELECT moving_average('/value[1,4]/', 2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                 moving_average                                  
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.15000000000000002,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.6500000000000001,,,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select moving_average(*) (stub function, expose data, explain)
--Testcase 262:
EXPLAIN VERBOSE
SELECT (moving_average_all(2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                   QUERY PLAN                                                                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((moving_average_all(2)))::s3)."time"), ((((moving_average_all(2)))::s3).tag1), ((((moving_average_all(2)))::s3).value1), ((((moving_average_all(2)))::s3).value2), ((((moving_average_all(2)))::s3).value3), ((((moving_average_all(2)))::s3).value4), ((((moving_average_all(2)))::s3).__spd_url)
   Sort Key: ((((moving_average_all(2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((moving_average_all(2)))::s3)."time", (((moving_average_all(2)))::s3).tag1, (((moving_average_all(2)))::s3).value1, (((moving_average_all(2)))::s3).value2, (((moving_average_all(2)))::s3).value3, (((moving_average_all(2)))::s3).value4, (((moving_average_all(2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.moving_average_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.moving_average_all(2) FROM public.s32influx
(9 rows)

-- select moving_average(*) (stub function, expose data, result)
--Testcase 263:
SELECT * FROM (
SELECT (moving_average_all(2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 |        value3        | value4 |          __spd_url           
------------------------+------+---------------------+--------+----------------------+--------+------------------------------
 1970-01-01 09:00:01+09 |      | 0.15000000000000002 |    100 | -0.15000000000000002 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |                0.25 |    100 |                -0.25 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |  1.6500000000000001 |    200 |  -1.6500000000000001 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |                2.75 |    200 |                -2.75 |   -200 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select moving_average(regex) (stub function, expose data, explain)
--Testcase 264:
EXPLAIN VERBOSE
SELECT (moving_average('/value[1,4]/', 2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((moving_average('/value[1,4]/'::text, 2)))::s3)."time"), ((((moving_average('/value[1,4]/'::text, 2)))::s3).tag1), ((((moving_average('/value[1,4]/'::text, 2)))::s3).value1), ((((moving_average('/value[1,4]/'::text, 2)))::s3).value2), ((((moving_average('/value[1,4]/'::text, 2)))::s3).value3), ((((moving_average('/value[1,4]/'::text, 2)))::s3).value4), ((((moving_average('/value[1,4]/'::text, 2)))::s3).__spd_url)
   Sort Key: ((((moving_average('/value[1,4]/'::text, 2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((moving_average('/value[1,4]/'::text, 2)))::s3)."time", (((moving_average('/value[1,4]/'::text, 2)))::s3).tag1, (((moving_average('/value[1,4]/'::text, 2)))::s3).value1, (((moving_average('/value[1,4]/'::text, 2)))::s3).value2, (((moving_average('/value[1,4]/'::text, 2)))::s3).value3, (((moving_average('/value[1,4]/'::text, 2)))::s3).value4, (((moving_average('/value[1,4]/'::text, 2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.moving_average('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.moving_average('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select moving_average(regex) (stub function, expose data, result)
--Testcase 265:
SELECT * FROM (
SELECT (moving_average('/value[1,4]/', 2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 | value3 | value4 |          __spd_url           
------------------------+------+---------------------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      | 0.15000000000000002 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |                0.25 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |  1.6500000000000001 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |                2.75 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 266:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator(value1, 2),chande_momentum_oscillator(value2, 2),chande_momentum_oscillator(value3, 2),chande_momentum_oscillator(value4, 2) FROM s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (chande_momentum_oscillator(value1, 2)), (chande_momentum_oscillator(value2, 2)), (chande_momentum_oscillator(value3, 2)), (chande_momentum_oscillator(value4, 2))
   Sort Key: (chande_momentum_oscillator(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (chande_momentum_oscillator(value1, 2)), (chande_momentum_oscillator(value2, 2)), (chande_momentum_oscillator(value3, 2)), (chande_momentum_oscillator(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator(value1, 2), public.chande_momentum_oscillator(value2, 2), public.chande_momentum_oscillator(value3, 2), public.chande_momentum_oscillator(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator(value1, 2), public.chande_momentum_oscillator(value2, 2), public.chande_momentum_oscillator(value3, 2), public.chande_momentum_oscillator(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 267:
SELECT chande_momentum_oscillator(value1, 2),chande_momentum_oscillator(value2, 2),chande_momentum_oscillator(value3, 2),chande_momentum_oscillator(value4, 2) FROM s3 ORDER BY 1;
 chande_momentum_oscillator | chande_momentum_oscillator | chande_momentum_oscillator | chande_momentum_oscillator 
----------------------------+----------------------------+----------------------------+----------------------------
                        100 |                          0 |                       -100 |                          0
                        100 |                          0 |                       -100 |                          0
                        100 |                          0 |                       -100 |                          0
                        100 |                          0 |                       -100 |                          0
(4 rows)

--Testcase 268:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator(value1, 2, 2),chande_momentum_oscillator(value2, 2, 2),chande_momentum_oscillator(value3, 2, 2),chande_momentum_oscillator(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (chande_momentum_oscillator(value1, 2, 2)), (chande_momentum_oscillator(value2, 2, 2)), (chande_momentum_oscillator(value3, 2, 2)), (chande_momentum_oscillator(value4, 2, 2))
   Sort Key: (chande_momentum_oscillator(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (chande_momentum_oscillator(value1, 2, 2)), (chande_momentum_oscillator(value2, 2, 2)), (chande_momentum_oscillator(value3, 2, 2)), (chande_momentum_oscillator(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator(value1, 2, 2), public.chande_momentum_oscillator(value2, 2, 2), public.chande_momentum_oscillator(value3, 2, 2), public.chande_momentum_oscillator(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator(value1, 2, 2), public.chande_momentum_oscillator(value2, 2, 2), public.chande_momentum_oscillator(value3, 2, 2), public.chande_momentum_oscillator(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 269:
SELECT chande_momentum_oscillator(value1, 2, 2),chande_momentum_oscillator(value2, 2, 2),chande_momentum_oscillator(value3, 2, 2),chande_momentum_oscillator(value4, 2, 2) FROM s3 ORDER BY 1;
 chande_momentum_oscillator | chande_momentum_oscillator | chande_momentum_oscillator | chande_momentum_oscillator 
----------------------------+----------------------------+----------------------------+----------------------------
                        100 |                          0 |                       -100 |                          0
                        100 |                          0 |                       -100 |                          0
(2 rows)

-- select chande_momentum_oscillator(*) (stub function, explain)
--Testcase 270:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator_all(2) from s3 ORDER BY 1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (chande_momentum_oscillator_all(2))
   Sort Key: (chande_momentum_oscillator_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (chande_momentum_oscillator_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator_all(2) FROM public.s32influx
(9 rows)

-- select chande_momentum_oscillator(*) (stub function, result)
--Testcase 271:
SELECT * FROM (
SELECT chande_momentum_oscillator_all(2) from s3
) as t ORDER BY 1;
                  chande_momentum_oscillator_all                   
-------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,100,0,-100,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,100,0,-100,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,100,0,-100,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,100,0,-100,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select chande_momentum_oscillator(regex) (stub function, explain)
--Testcase 272:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator('/value[1,4]/',2) from s3 ORDER BY 1;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (chande_momentum_oscillator('/value[1,4]/'::text, 2))
   Sort Key: (chande_momentum_oscillator('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (chande_momentum_oscillator('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select chande_momentum_oscillator(regex) (stub function, result)
--Testcase 273:
SELECT chande_momentum_oscillator('/value[1,4]/',2) from s3 ORDER BY 1;
                  chande_momentum_oscillator                  
--------------------------------------------------------------
 (1970-01-01T00:00:01Z,,100,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,100,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,100,,,0,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,100,,,0,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select chande_momentum_oscillator(*) (stub function and group by tag only) (explain)
--Testcase 274:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (chande_momentum_oscillator_all(2)), tag1
   Sort Key: (chande_momentum_oscillator_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (chande_momentum_oscillator_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.chande_momentum_oscillator_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.chande_momentum_oscillator_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select chande_momentum_oscillator(*) (stub function and group by tag only) (result)
--Testcase 275:
SELECT chande_momentum_oscillator_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                  chande_momentum_oscillator_all                   
-------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,100,0,-100,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,100,0,-100,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,100,0,-100,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select chande_momentum_oscillator(regex) (stub function and group by tag only) (explain)
--Testcase 276:
EXPLAIN VERBOSE
SELECT chande_momentum_oscillator('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                 QUERY PLAN                                                                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (chande_momentum_oscillator('/value[1,4]/'::text, 2)), tag1
   Sort Key: (chande_momentum_oscillator('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (chande_momentum_oscillator('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.chande_momentum_oscillator('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.chande_momentum_oscillator('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select chande_momentum_oscillator(regex) (stub function and group by tag only) (result)
--Testcase 277:
SELECT chande_momentum_oscillator('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                  chande_momentum_oscillator                  
--------------------------------------------------------------
 (1970-01-01T00:00:01Z,,100,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,100,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,100,,,0,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select chande_momentum_oscillator(*) (stub function, expose data, explain)
--Testcase 278:
EXPLAIN VERBOSE
SELECT (chande_momentum_oscillator_all(2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((chande_momentum_oscillator_all(2)))::s3)."time"), ((((chande_momentum_oscillator_all(2)))::s3).tag1), ((((chande_momentum_oscillator_all(2)))::s3).value1), ((((chande_momentum_oscillator_all(2)))::s3).value2), ((((chande_momentum_oscillator_all(2)))::s3).value3), ((((chande_momentum_oscillator_all(2)))::s3).value4), ((((chande_momentum_oscillator_all(2)))::s3).__spd_url)
   Sort Key: ((((chande_momentum_oscillator_all(2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((chande_momentum_oscillator_all(2)))::s3)."time", (((chande_momentum_oscillator_all(2)))::s3).tag1, (((chande_momentum_oscillator_all(2)))::s3).value1, (((chande_momentum_oscillator_all(2)))::s3).value2, (((chande_momentum_oscillator_all(2)))::s3).value3, (((chande_momentum_oscillator_all(2)))::s3).value4, (((chande_momentum_oscillator_all(2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator_all(2) FROM public.s32influx
(9 rows)

-- select chande_momentum_oscillator(*) (stub function, expose data, result)
--Testcase 279:
SELECT * FROM (
SELECT (chande_momentum_oscillator_all(2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |    100 |      0 |   -100 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |    100 |      0 |   -100 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |    100 |      0 |   -100 |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    100 |      0 |   -100 |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

-- select chande_momentum_oscillator(regex) (stub function, expose data, explain)
--Testcase 280:
EXPLAIN VERBOSE
SELECT (chande_momentum_oscillator('/value[1,4]/',2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3)."time"), ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).tag1), ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value1), ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value2), ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value3), ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value4), ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).__spd_url)
   Sort Key: ((((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3)."time", (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).tag1, (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value1, (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value2, (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value3, (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).value4, (((chande_momentum_oscillator('/value[1,4]/'::text, 2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.chande_momentum_oscillator('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select chande_momentum_oscillator(regex) (stub function, expose data, result)
--Testcase 281:
SELECT * FROM (
SELECT (chande_momentum_oscillator('/value[1,4]/',2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:01+09 |      |    100 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |    100 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:04+09 |      |    100 |        |        |      0 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    100 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(4 rows)

--Testcase 282:
EXPLAIN VERBOSE
SELECT exponential_moving_average(value1, 2),exponential_moving_average(value2, 2),exponential_moving_average(value3, 2),exponential_moving_average(value4, 2) FROM s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (exponential_moving_average(value1, 2)), (exponential_moving_average(value2, 2)), (exponential_moving_average(value3, 2)), (exponential_moving_average(value4, 2))
   Sort Key: (exponential_moving_average(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (exponential_moving_average(value1, 2)), (exponential_moving_average(value2, 2)), (exponential_moving_average(value3, 2)), (exponential_moving_average(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average(value1, 2), public.exponential_moving_average(value2, 2), public.exponential_moving_average(value3, 2), public.exponential_moving_average(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average(value1, 2), public.exponential_moving_average(value2, 2), public.exponential_moving_average(value3, 2), public.exponential_moving_average(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 283:
SELECT exponential_moving_average(value1, 2),exponential_moving_average(value2, 2),exponential_moving_average(value3, 2),exponential_moving_average(value4, 2) FROM s3 ORDER BY 1;
 exponential_moving_average | exponential_moving_average | exponential_moving_average | exponential_moving_average 
----------------------------+----------------------------+----------------------------+----------------------------
        0.16666666666666669 |                        100 |       -0.16666666666666669 |                       -100
        0.25555555555555554 |                        100 |       -0.25555555555555554 |                       -100
         1.8333333333333335 |                        200 |        -1.8333333333333335 |                       -200
          2.811111111111111 |                        200 |         -2.811111111111111 |                       -200
(4 rows)

--Testcase 284:
EXPLAIN VERBOSE
SELECT exponential_moving_average(value1, 2, 2),exponential_moving_average(value2, 2, 2),exponential_moving_average(value3, 2, 2),exponential_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (exponential_moving_average(value1, 2, 2)), (exponential_moving_average(value2, 2, 2)), (exponential_moving_average(value3, 2, 2)), (exponential_moving_average(value4, 2, 2))
   Sort Key: (exponential_moving_average(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (exponential_moving_average(value1, 2, 2)), (exponential_moving_average(value2, 2, 2)), (exponential_moving_average(value3, 2, 2)), (exponential_moving_average(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average(value1, 2, 2), public.exponential_moving_average(value2, 2, 2), public.exponential_moving_average(value3, 2, 2), public.exponential_moving_average(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average(value1, 2, 2), public.exponential_moving_average(value2, 2, 2), public.exponential_moving_average(value3, 2, 2), public.exponential_moving_average(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 285:
SELECT exponential_moving_average(value1, 2, 2),exponential_moving_average(value2, 2, 2),exponential_moving_average(value3, 2, 2),exponential_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
 exponential_moving_average | exponential_moving_average | exponential_moving_average | exponential_moving_average 
----------------------------+----------------------------+----------------------------+----------------------------
        0.25555555555555554 |                        100 |       -0.25555555555555554 |                       -100
          2.811111111111111 |                        200 |         -2.811111111111111 |                       -200
(2 rows)

-- select exponential_moving_average(*) (stub function, explain)
--Testcase 286:
EXPLAIN VERBOSE
SELECT exponential_moving_average_all(2) from s3 ORDER BY 1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (exponential_moving_average_all(2))
   Sort Key: (exponential_moving_average_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (exponential_moving_average_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average_all(2) FROM public.s32influx
(9 rows)

-- select exponential_moving_average(*) (stub function, result)
--Testcase 287:
SELECT * FROM (
SELECT exponential_moving_average_all(2) from s3
) as t ORDER BY 1;
                                     exponential_moving_average_all                                     
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.16666666666666669,100,-0.16666666666666669,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25555555555555554,100,-0.25555555555555554,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.8333333333333335,200,-1.8333333333333335,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,2.811111111111111,200,-2.811111111111111,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select exponential_moving_average(regex) (stub function, explain)
--Testcase 288:
EXPLAIN VERBOSE
SELECT exponential_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (exponential_moving_average('/value[1,4]/'::text, 2))
   Sort Key: (exponential_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (exponential_moving_average('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.exponential_moving_average('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select exponential_moving_average(regex) (stub function, result)
--Testcase 289:
SELECT exponential_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                           exponential_moving_average                            
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.16666666666666669,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25555555555555554,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.8333333333333335,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,2.811111111111111,,,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select exponential_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 290:
EXPLAIN VERBOSE
SELECT exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (exponential_moving_average_all(2)), tag1
   Sort Key: (exponential_moving_average_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (exponential_moving_average_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.exponential_moving_average_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.exponential_moving_average_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select exponential_moving_average(*) (stub function and group by tag only) (result)
--Testcase 291:
SELECT exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                     exponential_moving_average_all                                     
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.16666666666666669,100,-0.16666666666666669,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25555555555555554,100,-0.25555555555555554,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.8333333333333335,200,-1.8333333333333335,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select exponential_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 292:
EXPLAIN VERBOSE
SELECT exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                 QUERY PLAN                                                                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (exponential_moving_average('/value[1,4]/'::text, 2)), tag1
   Sort Key: (exponential_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (exponential_moving_average('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.exponential_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.exponential_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select exponential_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 293:
SELECT exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                           exponential_moving_average                            
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.16666666666666669,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.25555555555555554,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.8333333333333335,,,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

--Testcase 294:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average(value1, 2),double_exponential_moving_average(value2, 2),double_exponential_moving_average(value3, 2),double_exponential_moving_average(value4, 2) FROM s3 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (double_exponential_moving_average(value1, 2)), (double_exponential_moving_average(value2, 2)), (double_exponential_moving_average(value3, 2)), (double_exponential_moving_average(value4, 2))
   Sort Key: (double_exponential_moving_average(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (double_exponential_moving_average(value1, 2)), (double_exponential_moving_average(value2, 2)), (double_exponential_moving_average(value3, 2)), (double_exponential_moving_average(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average(value1, 2), public.double_exponential_moving_average(value2, 2), public.double_exponential_moving_average(value3, 2), public.double_exponential_moving_average(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average(value1, 2), public.double_exponential_moving_average(value2, 2), public.double_exponential_moving_average(value3, 2), public.double_exponential_moving_average(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 295:
SELECT double_exponential_moving_average(value1, 2),double_exponential_moving_average(value2, 2),double_exponential_moving_average(value3, 2),double_exponential_moving_average(value4, 2) FROM s3 ORDER BY 1;
 double_exponential_moving_average | double_exponential_moving_average | double_exponential_moving_average | double_exponential_moving_average 
-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------
                0.1888888888888889 |                               100 |               -0.1888888888888889 |                              -100
               0.29259259259259257 |                               100 |              -0.29259259259259257 |                              -100
                 2.077777777777778 |                               200 |                -2.077777777777778 |                              -200
                3.2185185185185183 |                               200 |               -3.2185185185185183 |                              -200
(4 rows)

--Testcase 296:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average(value1, 2, 2),double_exponential_moving_average(value2, 2, 2),double_exponential_moving_average(value3, 2, 2),double_exponential_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                                    QUERY PLAN                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (double_exponential_moving_average(value1, 2, 2)), (double_exponential_moving_average(value2, 2, 2)), (double_exponential_moving_average(value3, 2, 2)), (double_exponential_moving_average(value4, 2, 2))
   Sort Key: (double_exponential_moving_average(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (double_exponential_moving_average(value1, 2, 2)), (double_exponential_moving_average(value2, 2, 2)), (double_exponential_moving_average(value3, 2, 2)), (double_exponential_moving_average(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average(value1, 2, 2), public.double_exponential_moving_average(value2, 2, 2), public.double_exponential_moving_average(value3, 2, 2), public.double_exponential_moving_average(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average(value1, 2, 2), public.double_exponential_moving_average(value2, 2, 2), public.double_exponential_moving_average(value3, 2, 2), public.double_exponential_moving_average(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 297:
SELECT double_exponential_moving_average(value1, 2, 2),double_exponential_moving_average(value2, 2, 2),double_exponential_moving_average(value3, 2, 2),double_exponential_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
 double_exponential_moving_average | double_exponential_moving_average | double_exponential_moving_average | double_exponential_moving_average 
-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------
               0.29259259259259257 |                               100 |              -0.29259259259259257 |                              -100
                3.2185185185185183 |                               200 |               -3.2185185185185183 |                              -200
(2 rows)

-- select double_exponential_moving_average(*) (stub function, explain)
--Testcase 298:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average_all(2) from s3 ORDER BY 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (double_exponential_moving_average_all(2))
   Sort Key: (double_exponential_moving_average_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (double_exponential_moving_average_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average_all(2) FROM public.s32influx
(9 rows)

-- select double_exponential_moving_average(*) (stub function, result)
--Testcase 299:
SELECT * FROM (
SELECT double_exponential_moving_average_all(2) from s3
) as t ORDER BY 1;
                                 double_exponential_moving_average_all                                  
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1888888888888889,100,-0.1888888888888889,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.29259259259259257,100,-0.29259259259259257,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.077777777777778,200,-2.077777777777778,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.2185185185185183,200,-3.2185185185185183,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select double_exponential_moving_average(regex) (stub function, explain)
--Testcase 300:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (double_exponential_moving_average('/value[1,4]/'::text, 2))
   Sort Key: (double_exponential_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (double_exponential_moving_average('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.double_exponential_moving_average('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select double_exponential_moving_average(regex) (stub function, result)
--Testcase 301:
SELECT double_exponential_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                        double_exponential_moving_average                        
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1888888888888889,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.29259259259259257,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.077777777777778,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.2185185185185183,,,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select double_exponential_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 302:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                           QUERY PLAN                                                                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (double_exponential_moving_average_all(2)), tag1
   Sort Key: (double_exponential_moving_average_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (double_exponential_moving_average_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.double_exponential_moving_average_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.double_exponential_moving_average_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select double_exponential_moving_average(*) (stub function and group by tag only) (result)
--Testcase 303:
SELECT double_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                 double_exponential_moving_average_all                                  
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1888888888888889,100,-0.1888888888888889,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.29259259259259257,100,-0.29259259259259257,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.077777777777778,200,-2.077777777777778,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select double_exponential_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 304:
EXPLAIN VERBOSE
SELECT double_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                    QUERY PLAN                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (double_exponential_moving_average('/value[1,4]/'::text, 2)), tag1
   Sort Key: (double_exponential_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (double_exponential_moving_average('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.double_exponential_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.double_exponential_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select double_exponential_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 305:
SELECT double_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                        double_exponential_moving_average                        
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1888888888888889,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.29259259259259257,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.077777777777778,,,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

--Testcase 306:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio(value1, 2),kaufmans_efficiency_ratio(value2, 2),kaufmans_efficiency_ratio(value3, 2),kaufmans_efficiency_ratio(value4, 2) FROM s3 ORDER BY 1;
                                                                                                              QUERY PLAN                                                                                                               
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (kaufmans_efficiency_ratio(value1, 2)), (kaufmans_efficiency_ratio(value2, 2)), (kaufmans_efficiency_ratio(value3, 2)), (kaufmans_efficiency_ratio(value4, 2))
   Sort Key: (kaufmans_efficiency_ratio(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (kaufmans_efficiency_ratio(value1, 2)), (kaufmans_efficiency_ratio(value2, 2)), (kaufmans_efficiency_ratio(value3, 2)), (kaufmans_efficiency_ratio(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio(value1, 2), public.kaufmans_efficiency_ratio(value2, 2), public.kaufmans_efficiency_ratio(value3, 2), public.kaufmans_efficiency_ratio(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio(value1, 2), public.kaufmans_efficiency_ratio(value2, 2), public.kaufmans_efficiency_ratio(value3, 2), public.kaufmans_efficiency_ratio(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 307:
SELECT kaufmans_efficiency_ratio(value1, 2),kaufmans_efficiency_ratio(value2, 2),kaufmans_efficiency_ratio(value3, 2),kaufmans_efficiency_ratio(value4, 2) FROM s3 ORDER BY 1;
 kaufmans_efficiency_ratio | kaufmans_efficiency_ratio | kaufmans_efficiency_ratio | kaufmans_efficiency_ratio 
---------------------------+---------------------------+---------------------------+---------------------------
                         1 |                         0 |                         1 |                         0
                         1 |                         0 |                         1 |                         0
(2 rows)

--Testcase 308:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio(value1, 2, 2),kaufmans_efficiency_ratio(value2, 2, 2),kaufmans_efficiency_ratio(value3, 2, 2),kaufmans_efficiency_ratio(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                    QUERY PLAN                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (kaufmans_efficiency_ratio(value1, 2, 2)), (kaufmans_efficiency_ratio(value2, 2, 2)), (kaufmans_efficiency_ratio(value3, 2, 2)), (kaufmans_efficiency_ratio(value4, 2, 2))
   Sort Key: (kaufmans_efficiency_ratio(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (kaufmans_efficiency_ratio(value1, 2, 2)), (kaufmans_efficiency_ratio(value2, 2, 2)), (kaufmans_efficiency_ratio(value3, 2, 2)), (kaufmans_efficiency_ratio(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio(value1, 2, 2), public.kaufmans_efficiency_ratio(value2, 2, 2), public.kaufmans_efficiency_ratio(value3, 2, 2), public.kaufmans_efficiency_ratio(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio(value1, 2, 2), public.kaufmans_efficiency_ratio(value2, 2, 2), public.kaufmans_efficiency_ratio(value3, 2, 2), public.kaufmans_efficiency_ratio(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 309:
SELECT kaufmans_efficiency_ratio(value1, 2, 2),kaufmans_efficiency_ratio(value2, 2, 2),kaufmans_efficiency_ratio(value3, 2, 2),kaufmans_efficiency_ratio(value4, 2, 2) FROM s3 ORDER BY 1;
 kaufmans_efficiency_ratio | kaufmans_efficiency_ratio | kaufmans_efficiency_ratio | kaufmans_efficiency_ratio 
---------------------------+---------------------------+---------------------------+---------------------------
                         1 |                         0 |                         1 |                         0
                         1 |                         0 |                         1 |                         0
(2 rows)

-- select kaufmans_efficiency_ratio(*) (stub function, explain)
--Testcase 310:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio_all(2) from s3 ORDER BY 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (kaufmans_efficiency_ratio_all(2))
   Sort Key: (kaufmans_efficiency_ratio_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (kaufmans_efficiency_ratio_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio_all(2) FROM public.s32influx
(9 rows)

-- select kaufmans_efficiency_ratio(*) (stub function, result)
--Testcase 311:
SELECT * FROM (
SELECT kaufmans_efficiency_ratio_all(2) from s3
) as t ORDER BY 1;
                kaufmans_efficiency_ratio_all                 
--------------------------------------------------------------
 (1970-01-01T00:00:02Z,,1,0,1,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1,0,1,0,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function, explain)
--Testcase 312:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) from s3 ORDER BY 1;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))
   Sort Key: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function, result)
--Testcase 313:
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) from s3 ORDER BY 1;
                 kaufmans_efficiency_ratio                  
------------------------------------------------------------
 (1970-01-01T00:00:02Z,,1,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1,,,0,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select kaufmans_efficiency_ratio(*) (stub function and group by tag only) (explain)
--Testcase 314:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (kaufmans_efficiency_ratio_all(2)), tag1
   Sort Key: (kaufmans_efficiency_ratio_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (kaufmans_efficiency_ratio_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_efficiency_ratio_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_efficiency_ratio_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select kaufmans_efficiency_ratio(*) (stub function and group by tag only) (result)
--Testcase 315:
SELECT kaufmans_efficiency_ratio_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                kaufmans_efficiency_ratio_all                 
--------------------------------------------------------------
 (1970-01-01T00:00:02Z,,1,0,1,0,/pgspider_svr1/influxdb_svr/)
(1 row)

-- select kaufmans_efficiency_ratio(regex) (stub function and group by tag only) (explain)
--Testcase 316:
EXPLAIN VERBOSE
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                QUERY PLAN                                                                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)), tag1
   Sort Key: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_efficiency_ratio('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_efficiency_ratio('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function and group by tag only) (result)
--Testcase 317:
SELECT kaufmans_efficiency_ratio('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                 kaufmans_efficiency_ratio                  
------------------------------------------------------------
 (1970-01-01T00:00:02Z,,1,,,0,/pgspider_svr1/influxdb_svr/)
(1 row)

-- select kaufmans_efficiency_ratio(*) (stub function, expose data, explain)
--Testcase 318:
EXPLAIN VERBOSE
SELECT (kaufmans_efficiency_ratio_all(2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((kaufmans_efficiency_ratio_all(2)))::s3)."time"), ((((kaufmans_efficiency_ratio_all(2)))::s3).tag1), ((((kaufmans_efficiency_ratio_all(2)))::s3).value1), ((((kaufmans_efficiency_ratio_all(2)))::s3).value2), ((((kaufmans_efficiency_ratio_all(2)))::s3).value3), ((((kaufmans_efficiency_ratio_all(2)))::s3).value4), ((((kaufmans_efficiency_ratio_all(2)))::s3).__spd_url)
   Sort Key: ((((kaufmans_efficiency_ratio_all(2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((kaufmans_efficiency_ratio_all(2)))::s3)."time", (((kaufmans_efficiency_ratio_all(2)))::s3).tag1, (((kaufmans_efficiency_ratio_all(2)))::s3).value1, (((kaufmans_efficiency_ratio_all(2)))::s3).value2, (((kaufmans_efficiency_ratio_all(2)))::s3).value3, (((kaufmans_efficiency_ratio_all(2)))::s3).value4, (((kaufmans_efficiency_ratio_all(2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio_all(2) FROM public.s32influx
(9 rows)

-- select kaufmans_efficiency_ratio(*) (stub function, expose data, result)
--Testcase 319:
SELECT * FROM (
SELECT (kaufmans_efficiency_ratio_all(2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:02+09 |      |      1 |      0 |      1 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:05+09 |      |      1 |      0 |      1 |      0 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function, expose data, explain)
--Testcase 320:
EXPLAIN VERBOSE
SELECT (kaufmans_efficiency_ratio('/value[1,4]/',2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                                                         QUERY PLAN                                                                                                                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3)."time"), ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).tag1), ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value1), ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value2), ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value3), ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value4), ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).__spd_url)
   Sort Key: ((((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3)."time", (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).tag1, (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value1, (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value2, (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value3, (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).value4, (((kaufmans_efficiency_ratio('/value[1,4]/'::text, 2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_efficiency_ratio('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select kaufmans_efficiency_ratio(regex) (stub function, expose data, result)
--Testcase 321:
SELECT * FROM (
SELECT (kaufmans_efficiency_ratio('/value[1,4]/',2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:02+09 |      |      1 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:05+09 |      |      1 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(2 rows)

--Testcase 322:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average(value1, 2),kaufmans_adaptive_moving_average(value2, 2),kaufmans_adaptive_moving_average(value3, 2),kaufmans_adaptive_moving_average(value4, 2) FROM s3 ORDER BY 1;
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (kaufmans_adaptive_moving_average(value1, 2)), (kaufmans_adaptive_moving_average(value2, 2)), (kaufmans_adaptive_moving_average(value3, 2)), (kaufmans_adaptive_moving_average(value4, 2))
   Sort Key: (kaufmans_adaptive_moving_average(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (kaufmans_adaptive_moving_average(value1, 2)), (kaufmans_adaptive_moving_average(value2, 2)), (kaufmans_adaptive_moving_average(value3, 2)), (kaufmans_adaptive_moving_average(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average(value1, 2), public.kaufmans_adaptive_moving_average(value2, 2), public.kaufmans_adaptive_moving_average(value3, 2), public.kaufmans_adaptive_moving_average(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average(value1, 2), public.kaufmans_adaptive_moving_average(value2, 2), public.kaufmans_adaptive_moving_average(value3, 2), public.kaufmans_adaptive_moving_average(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 323:
SELECT kaufmans_adaptive_moving_average(value1, 2),kaufmans_adaptive_moving_average(value2, 2),kaufmans_adaptive_moving_average(value3, 2),kaufmans_adaptive_moving_average(value4, 2) FROM s3 ORDER BY 1;
 kaufmans_adaptive_moving_average | kaufmans_adaptive_moving_average | kaufmans_adaptive_moving_average | kaufmans_adaptive_moving_average 
----------------------------------+----------------------------------+----------------------------------+----------------------------------
              0.24444444444444446 |                              100 |             -0.24444444444444446 |                             -100
                2.688888888888889 |                              200 |               -2.688888888888889 |                             -200
(2 rows)

--Testcase 324:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average(value1, 2, 2),kaufmans_adaptive_moving_average(value2, 2, 2),kaufmans_adaptive_moving_average(value3, 2, 2),kaufmans_adaptive_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (kaufmans_adaptive_moving_average(value1, 2, 2)), (kaufmans_adaptive_moving_average(value2, 2, 2)), (kaufmans_adaptive_moving_average(value3, 2, 2)), (kaufmans_adaptive_moving_average(value4, 2, 2))
   Sort Key: (kaufmans_adaptive_moving_average(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (kaufmans_adaptive_moving_average(value1, 2, 2)), (kaufmans_adaptive_moving_average(value2, 2, 2)), (kaufmans_adaptive_moving_average(value3, 2, 2)), (kaufmans_adaptive_moving_average(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average(value1, 2, 2), public.kaufmans_adaptive_moving_average(value2, 2, 2), public.kaufmans_adaptive_moving_average(value3, 2, 2), public.kaufmans_adaptive_moving_average(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average(value1, 2, 2), public.kaufmans_adaptive_moving_average(value2, 2, 2), public.kaufmans_adaptive_moving_average(value3, 2, 2), public.kaufmans_adaptive_moving_average(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 325:
SELECT kaufmans_adaptive_moving_average(value1, 2, 2),kaufmans_adaptive_moving_average(value2, 2, 2),kaufmans_adaptive_moving_average(value3, 2, 2),kaufmans_adaptive_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
 kaufmans_adaptive_moving_average | kaufmans_adaptive_moving_average | kaufmans_adaptive_moving_average | kaufmans_adaptive_moving_average 
----------------------------------+----------------------------------+----------------------------------+----------------------------------
              0.24444444444444446 |                              100 |             -0.24444444444444446 |                             -100
                2.688888888888889 |                              200 |               -2.688888888888889 |                             -200
(2 rows)

-- select kaufmans_adaptive_moving_average(*) (stub function, explain)
--Testcase 326:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average_all(2) from s3 ORDER BY 1;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (kaufmans_adaptive_moving_average_all(2))
   Sort Key: (kaufmans_adaptive_moving_average_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (kaufmans_adaptive_moving_average_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average_all(2) FROM public.s32influx
(9 rows)

-- select kaufmans_adaptive_moving_average(*) (stub function, result)
--Testcase 327:
SELECT * FROM (
SELECT kaufmans_adaptive_moving_average_all(2) from s3
) as t ORDER BY 1;
                                  kaufmans_adaptive_moving_average_all                                  
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,0.24444444444444446,100,-0.24444444444444446,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,2.688888888888889,200,-2.688888888888889,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select kaufmans_adaptive_moving_average(regex) (stub function, explain)
--Testcase 328:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2))
   Sort Key: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select kaufmans_adaptive_moving_average(regex) (stub function, result)
--Testcase 329:
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                        kaufmans_adaptive_moving_average                         
---------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,0.24444444444444446,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,2.688888888888889,,,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select kaufmans_adaptive_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 330:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                           QUERY PLAN                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (kaufmans_adaptive_moving_average_all(2)), tag1
   Sort Key: (kaufmans_adaptive_moving_average_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (kaufmans_adaptive_moving_average_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select kaufmans_adaptive_moving_average(*) (stub function and group by tag only) (result)
--Testcase 331:
SELECT kaufmans_adaptive_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                  kaufmans_adaptive_moving_average_all                                  
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,0.24444444444444446,100,-0.24444444444444446,-100,/pgspider_svr1/influxdb_svr/)
(1 row)

-- select kaufmans_adaptive_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 332:
EXPLAIN VERBOSE
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                    QUERY PLAN                                                                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2)), tag1
   Sort Key: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.kaufmans_adaptive_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select kaufmans_adaptive_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 333:
SELECT kaufmans_adaptive_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                        kaufmans_adaptive_moving_average                         
---------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,0.24444444444444446,,,-100,/pgspider_svr1/influxdb_svr/)
(1 row)

--Testcase 334:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average(value1, 2),triple_exponential_moving_average(value2, 2),triple_exponential_moving_average(value3, 2),triple_exponential_moving_average(value4, 2) FROM s3 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (triple_exponential_moving_average(value1, 2)), (triple_exponential_moving_average(value2, 2)), (triple_exponential_moving_average(value3, 2)), (triple_exponential_moving_average(value4, 2))
   Sort Key: (triple_exponential_moving_average(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (triple_exponential_moving_average(value1, 2)), (triple_exponential_moving_average(value2, 2)), (triple_exponential_moving_average(value3, 2)), (triple_exponential_moving_average(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average(value1, 2), public.triple_exponential_moving_average(value2, 2), public.triple_exponential_moving_average(value3, 2), public.triple_exponential_moving_average(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average(value1, 2), public.triple_exponential_moving_average(value2, 2), public.triple_exponential_moving_average(value3, 2), public.triple_exponential_moving_average(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 335:
SELECT triple_exponential_moving_average(value1, 2),triple_exponential_moving_average(value2, 2),triple_exponential_moving_average(value3, 2),triple_exponential_moving_average(value4, 2) FROM s3 ORDER BY 1;
 triple_exponential_moving_average | triple_exponential_moving_average | triple_exponential_moving_average | triple_exponential_moving_average 
-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------
                0.1962962962962963 |                               100 |               -0.1962962962962963 |                              -100
               0.30000000000000004 |                               100 |              -0.30000000000000004 |                              -100
                2.1592592592592585 |                               200 |               -2.1592592592592585 |                              -200
                3.3000000000000007 |                               200 |               -3.3000000000000007 |                              -200
(4 rows)

--Testcase 336:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average(value1, 2, 2),triple_exponential_moving_average(value2, 2, 2),triple_exponential_moving_average(value3, 2, 2),triple_exponential_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                                    QUERY PLAN                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (triple_exponential_moving_average(value1, 2, 2)), (triple_exponential_moving_average(value2, 2, 2)), (triple_exponential_moving_average(value3, 2, 2)), (triple_exponential_moving_average(value4, 2, 2))
   Sort Key: (triple_exponential_moving_average(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (triple_exponential_moving_average(value1, 2, 2)), (triple_exponential_moving_average(value2, 2, 2)), (triple_exponential_moving_average(value3, 2, 2)), (triple_exponential_moving_average(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average(value1, 2, 2), public.triple_exponential_moving_average(value2, 2, 2), public.triple_exponential_moving_average(value3, 2, 2), public.triple_exponential_moving_average(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average(value1, 2, 2), public.triple_exponential_moving_average(value2, 2, 2), public.triple_exponential_moving_average(value3, 2, 2), public.triple_exponential_moving_average(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 337:
SELECT triple_exponential_moving_average(value1, 2, 2),triple_exponential_moving_average(value2, 2, 2),triple_exponential_moving_average(value3, 2, 2),triple_exponential_moving_average(value4, 2, 2) FROM s3 ORDER BY 1;
 triple_exponential_moving_average | triple_exponential_moving_average | triple_exponential_moving_average | triple_exponential_moving_average 
-----------------------------------+-----------------------------------+-----------------------------------+-----------------------------------
               0.30000000000000004 |                               100 |              -0.30000000000000004 |                              -100
                3.3000000000000007 |                               200 |               -3.3000000000000007 |                              -200
(2 rows)

-- select triple_exponential_moving_average(*) (stub function, explain)
--Testcase 338:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average_all(2) from s3 ORDER BY 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (triple_exponential_moving_average_all(2))
   Sort Key: (triple_exponential_moving_average_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (triple_exponential_moving_average_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average_all(2) FROM public.s32influx
(9 rows)

-- select triple_exponential_moving_average(*) (stub function, result)
--Testcase 339:
SELECT * FROM (
SELECT triple_exponential_moving_average_all(2) from s3
) as t ORDER BY 1;
                                 triple_exponential_moving_average_all                                  
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1962962962962963,100,-0.1962962962962963,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.30000000000000004,100,-0.30000000000000004,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.1592592592592585,200,-2.1592592592592585,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.3000000000000007,200,-3.3000000000000007,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select triple_exponential_moving_average(regex) (stub function, explain)
--Testcase 340:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (triple_exponential_moving_average('/value[1,4]/'::text, 2))
   Sort Key: (triple_exponential_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (triple_exponential_moving_average('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_moving_average('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select triple_exponential_moving_average(regex) (stub function, result)
--Testcase 341:
SELECT triple_exponential_moving_average('/value[1,4]/',2) from s3 ORDER BY 1;
                        triple_exponential_moving_average                        
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1962962962962963,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.30000000000000004,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.1592592592592585,,,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3.3000000000000007,,,-200,/pgspider_svr2/influxdb_svr/)
(4 rows)

-- select triple_exponential_moving_average(*) (stub function and group by tag only) (explain)
--Testcase 342:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                           QUERY PLAN                                                                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (triple_exponential_moving_average_all(2)), tag1
   Sort Key: (triple_exponential_moving_average_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (triple_exponential_moving_average_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_moving_average_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_moving_average_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select triple_exponential_moving_average(*) (stub function and group by tag only) (result)
--Testcase 343:
SELECT triple_exponential_moving_average_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                 triple_exponential_moving_average_all                                  
--------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1962962962962963,100,-0.1962962962962963,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.30000000000000004,100,-0.30000000000000004,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.1592592592592585,200,-2.1592592592592585,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

-- select triple_exponential_moving_average(regex) (stub function and group by tag only) (explain)
--Testcase 344:
EXPLAIN VERBOSE
SELECT triple_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                    QUERY PLAN                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (triple_exponential_moving_average('/value[1,4]/'::text, 2)), tag1
   Sort Key: (triple_exponential_moving_average('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (triple_exponential_moving_average('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_moving_average('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select triple_exponential_moving_average(regex) (stub function and group by tag only) (result)
--Testcase 345:
SELECT triple_exponential_moving_average('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                        triple_exponential_moving_average                        
---------------------------------------------------------------------------------
 (1970-01-01T00:00:01Z,,0.1962962962962963,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.30000000000000004,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2.1592592592592585,,,-200,/pgspider_svr2/influxdb_svr/)
(3 rows)

--Testcase 346:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative(value1, 2),triple_exponential_derivative(value2, 2),triple_exponential_derivative(value3, 2),triple_exponential_derivative(value4, 2) FROM s3 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (triple_exponential_derivative(value1, 2)), (triple_exponential_derivative(value2, 2)), (triple_exponential_derivative(value3, 2)), (triple_exponential_derivative(value4, 2))
   Sort Key: (triple_exponential_derivative(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (triple_exponential_derivative(value1, 2)), (triple_exponential_derivative(value2, 2)), (triple_exponential_derivative(value3, 2)), (triple_exponential_derivative(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative(value1, 2), public.triple_exponential_derivative(value2, 2), public.triple_exponential_derivative(value3, 2), public.triple_exponential_derivative(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative(value1, 2), public.triple_exponential_derivative(value2, 2), public.triple_exponential_derivative(value3, 2), public.triple_exponential_derivative(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 347:
SELECT triple_exponential_derivative(value1, 2),triple_exponential_derivative(value2, 2),triple_exponential_derivative(value3, 2),triple_exponential_derivative(value4, 2) FROM s3 ORDER BY 1;
 triple_exponential_derivative | triple_exponential_derivative | triple_exponential_derivative | triple_exponential_derivative 
-------------------------------+-------------------------------+-------------------------------+-------------------------------
             45.71428571428569 |                             0 |             45.71428571428569 |                             0
             45.71428571428569 |                             0 |             45.71428571428569 |                             0
(2 rows)

--Testcase 348:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative(value1, 2, 2),triple_exponential_derivative(value2, 2, 2),triple_exponential_derivative(value3, 2, 2),triple_exponential_derivative(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (triple_exponential_derivative(value1, 2, 2)), (triple_exponential_derivative(value2, 2, 2)), (triple_exponential_derivative(value3, 2, 2)), (triple_exponential_derivative(value4, 2, 2))
   Sort Key: (triple_exponential_derivative(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (triple_exponential_derivative(value1, 2, 2)), (triple_exponential_derivative(value2, 2, 2)), (triple_exponential_derivative(value3, 2, 2)), (triple_exponential_derivative(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative(value1, 2, 2), public.triple_exponential_derivative(value2, 2, 2), public.triple_exponential_derivative(value3, 2, 2), public.triple_exponential_derivative(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative(value1, 2, 2), public.triple_exponential_derivative(value2, 2, 2), public.triple_exponential_derivative(value3, 2, 2), public.triple_exponential_derivative(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 349:
SELECT triple_exponential_derivative(value1, 2, 2),triple_exponential_derivative(value2, 2, 2),triple_exponential_derivative(value3, 2, 2),triple_exponential_derivative(value4, 2, 2) FROM s3 ORDER BY 1;
 triple_exponential_derivative | triple_exponential_derivative | triple_exponential_derivative | triple_exponential_derivative 
-------------------------------+-------------------------------+-------------------------------+-------------------------------
             45.71428571428569 |                             0 |             45.71428571428569 |                             0
             45.71428571428569 |                             0 |             45.71428571428569 |                             0
(2 rows)

-- select triple_exponential_derivative(*) (stub function, explain)
--Testcase 350:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative_all(2) from s3 ORDER BY 1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (triple_exponential_derivative_all(2))
   Sort Key: (triple_exponential_derivative_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (triple_exponential_derivative_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative_all(2) FROM public.s32influx
(9 rows)

-- select triple_exponential_derivative(*) (stub function, result)
--Testcase 351:
SELECT * FROM (
SELECT triple_exponential_derivative_all(2) from s3
) as t ORDER BY 1;
                              triple_exponential_derivative_all                               
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,45.71428571428569,0,45.71428571428569,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,45.71428571428569,0,45.71428571428569,0,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select triple_exponential_derivative(regex) (stub function, explain)
--Testcase 352:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative('/value[1,4]/',2) from s3 ORDER BY 1;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (triple_exponential_derivative('/value[1,4]/'::text, 2))
   Sort Key: (triple_exponential_derivative('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (triple_exponential_derivative('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.triple_exponential_derivative('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select triple_exponential_derivative(regex) (stub function, result)
--Testcase 353:
SELECT triple_exponential_derivative('/value[1,4]/',2) from s3 ORDER BY 1;
                       triple_exponential_derivative                        
----------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,45.71428571428569,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,45.71428571428569,,,0,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select triple_exponential_derivative(*) (stub function and group by tag only) (explain)
--Testcase 354:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                         QUERY PLAN                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (triple_exponential_derivative_all(2)), tag1
   Sort Key: (triple_exponential_derivative_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (triple_exponential_derivative_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_derivative_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_derivative_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select triple_exponential_derivative(*) (stub function and group by tag only) (result)
--Testcase 355:
SELECT triple_exponential_derivative_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                              triple_exponential_derivative_all                               
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,45.71428571428569,0,45.71428571428569,0,/pgspider_svr1/influxdb_svr/)
(1 row)

-- select triple_exponential_derivative(regex) (stub function and group by tag only) (explain)
--Testcase 356:
EXPLAIN VERBOSE
SELECT triple_exponential_derivative('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (triple_exponential_derivative('/value[1,4]/'::text, 2)), tag1
   Sort Key: (triple_exponential_derivative('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (triple_exponential_derivative('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_derivative('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.triple_exponential_derivative('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select triple_exponential_derivative(regex) (stub function and group by tag only) (result)
--Testcase 357:
SELECT triple_exponential_derivative('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                       triple_exponential_derivative                        
----------------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,45.71428571428569,,,0,/pgspider_svr1/influxdb_svr/)
(1 row)

--Testcase 358:
EXPLAIN VERBOSE
SELECT relative_strength_index(value1, 2),relative_strength_index(value2, 2),relative_strength_index(value3, 2),relative_strength_index(value4, 2) FROM s3 ORDER BY 1;
                                                                                                          QUERY PLAN                                                                                                           
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (relative_strength_index(value1, 2)), (relative_strength_index(value2, 2)), (relative_strength_index(value3, 2)), (relative_strength_index(value4, 2))
   Sort Key: (relative_strength_index(s3.value1, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (relative_strength_index(value1, 2)), (relative_strength_index(value2, 2)), (relative_strength_index(value3, 2)), (relative_strength_index(value4, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index(value1, 2), public.relative_strength_index(value2, 2), public.relative_strength_index(value3, 2), public.relative_strength_index(value4, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index(value1, 2), public.relative_strength_index(value2, 2), public.relative_strength_index(value3, 2), public.relative_strength_index(value4, 2) FROM public.s32influx
(9 rows)

--Testcase 359:
SELECT relative_strength_index(value1, 2),relative_strength_index(value2, 2),relative_strength_index(value3, 2),relative_strength_index(value4, 2) FROM s3 ORDER BY 1;
 relative_strength_index | relative_strength_index | relative_strength_index | relative_strength_index 
-------------------------+-------------------------+-------------------------+-------------------------
                     100 |                     100 |                       0 |                       0
                     100 |                     100 |                       0 |                       0
(2 rows)

--Testcase 360:
EXPLAIN VERBOSE
SELECT relative_strength_index(value1, 2, 2),relative_strength_index(value2, 2, 2),relative_strength_index(value3, 2, 2),relative_strength_index(value4, 2, 2) FROM s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (relative_strength_index(value1, 2, 2)), (relative_strength_index(value2, 2, 2)), (relative_strength_index(value3, 2, 2)), (relative_strength_index(value4, 2, 2))
   Sort Key: (relative_strength_index(s3.value1, 2, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (relative_strength_index(value1, 2, 2)), (relative_strength_index(value2, 2, 2)), (relative_strength_index(value3, 2, 2)), (relative_strength_index(value4, 2, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index(value1, 2, 2), public.relative_strength_index(value2, 2, 2), public.relative_strength_index(value3, 2, 2), public.relative_strength_index(value4, 2, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index(value1, 2, 2), public.relative_strength_index(value2, 2, 2), public.relative_strength_index(value3, 2, 2), public.relative_strength_index(value4, 2, 2) FROM public.s32influx
(9 rows)

--Testcase 361:
SELECT relative_strength_index(value1, 2, 2),relative_strength_index(value2, 2, 2),relative_strength_index(value3, 2, 2),relative_strength_index(value4, 2, 2) FROM s3 ORDER BY 1;
 relative_strength_index | relative_strength_index | relative_strength_index | relative_strength_index 
-------------------------+-------------------------+-------------------------+-------------------------
                     100 |                     100 |                       0 |                       0
                     100 |                     100 |                       0 |                       0
(2 rows)

-- select relative_strength_index(*) (stub function, explain)
--Testcase 362:
EXPLAIN VERBOSE
SELECT relative_strength_index_all(2) from s3 ORDER BY 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (relative_strength_index_all(2))
   Sort Key: (relative_strength_index_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (relative_strength_index_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index_all(2) FROM public.s32influx
(9 rows)

-- select relative_strength_index(*) (stub function, result)
--Testcase 363:
SELECT * FROM (
SELECT relative_strength_index_all(2) from s3
) as t ORDER BY 1;
                   relative_strength_index_all                    
------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,100,100,0,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,100,100,0,0,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select relative_strength_index(regex) (stub function, explain)
--Testcase 364:
EXPLAIN VERBOSE
SELECT relative_strength_index('/value[1,4]/',2) from s3 ORDER BY 1;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (relative_strength_index('/value[1,4]/'::text, 2))
   Sort Key: (relative_strength_index('/value[1,4]/'::text, 2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (relative_strength_index('/value[1,4]/'::text, 2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select relative_strength_index(regex) (stub function, result)
--Testcase 365:
SELECT relative_strength_index('/value[1,4]/',2) from s3 ORDER BY 1;
                   relative_strength_index                    
--------------------------------------------------------------
 (1970-01-01T00:00:02Z,,100,,,0,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:05Z,,100,,,0,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select relative_strength_index(*) (stub function and group by tag only) (explain)
--Testcase 366:
EXPLAIN VERBOSE
SELECT relative_strength_index_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                      QUERY PLAN                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (relative_strength_index_all(2)), tag1
   Sort Key: (relative_strength_index_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (relative_strength_index_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.relative_strength_index_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.relative_strength_index_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select relative_strength_index(*) (stub function and group by tag only) (result)
--Testcase 367:
SELECT relative_strength_index_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                   relative_strength_index_all                    
------------------------------------------------------------------
 (1970-01-01T00:00:02Z,,100,100,0,0,/pgspider_svr1/influxdb_svr/)
(1 row)

-- select relative_strength_index(regex) (stub function and group by tag only) (explain)
--Testcase 368:
EXPLAIN VERBOSE
SELECT relative_strength_index('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                               QUERY PLAN                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (relative_strength_index('/value[1,4]/'::text, 2)), tag1
   Sort Key: (relative_strength_index('/value[1,4]/'::text, 2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (relative_strength_index('/value[1,4]/'::text, 2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.relative_strength_index('/value[1,4]/'::text, 2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.relative_strength_index('/value[1,4]/'::text, 2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select relative_strength_index(regex) (stub function and group by tag only) (result)
--Testcase 369:
SELECT relative_strength_index('/value[1,4]/',2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                   relative_strength_index                    
--------------------------------------------------------------
 (1970-01-01T00:00:02Z,,100,,,0,/pgspider_svr1/influxdb_svr/)
(1 row)

-- select relative_strength_index(*) (stub function, expose data, explain)
--Testcase 370:
EXPLAIN VERBOSE
SELECT (relative_strength_index_all(2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((relative_strength_index_all(2)))::s3)."time"), ((((relative_strength_index_all(2)))::s3).tag1), ((((relative_strength_index_all(2)))::s3).value1), ((((relative_strength_index_all(2)))::s3).value2), ((((relative_strength_index_all(2)))::s3).value3), ((((relative_strength_index_all(2)))::s3).value4), ((((relative_strength_index_all(2)))::s3).__spd_url)
   Sort Key: ((((relative_strength_index_all(2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((relative_strength_index_all(2)))::s3)."time", (((relative_strength_index_all(2)))::s3).tag1, (((relative_strength_index_all(2)))::s3).value1, (((relative_strength_index_all(2)))::s3).value2, (((relative_strength_index_all(2)))::s3).value3, (((relative_strength_index_all(2)))::s3).value4, (((relative_strength_index_all(2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index_all(2) FROM public.s32influx
(9 rows)

-- select relative_strength_index(*) (stub function, expose data, result)
--Testcase 371:
SELECT * FROM (
SELECT (relative_strength_index_all(2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:02+09 |      |    100 |    100 |      0 |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    100 |    100 |      0 |      0 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- select relative_strength_index(regex) (stub function, expose data, explain)
--Testcase 372:
EXPLAIN VERBOSE
SELECT (relative_strength_index('/value[1,4]/',2)::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3)."time"), ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3).tag1), ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value1), ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value2), ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value3), ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value4), ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3).__spd_url)
   Sort Key: ((((relative_strength_index('/value[1,4]/'::text, 2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((relative_strength_index('/value[1,4]/'::text, 2)))::s3)."time", (((relative_strength_index('/value[1,4]/'::text, 2)))::s3).tag1, (((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value1, (((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value2, (((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value3, (((relative_strength_index('/value[1,4]/'::text, 2)))::s3).value4, (((relative_strength_index('/value[1,4]/'::text, 2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index('/value[1,4]/'::text, 2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.relative_strength_index('/value[1,4]/'::text, 2) FROM public.s32influx
(9 rows)

-- select relative_strength_index(regex) (stub function, expose data, result)
--Testcase 373:
SELECT * FROM (
SELECT (relative_strength_index('/value[1,4]/',2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:02+09 |      |    100 |        |        |      0 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:05+09 |      |    100 |        |        |      0 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- select integral (stub agg function, explain)
--Testcase 374:
EXPLAIN VERBOSE
SELECT integral(value1),integral(value2),integral(value3),integral(value4) FROM s3 ORDER BY 1;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (integral(value1)), (integral(value2)), (integral(value3)), (integral(value4))
   Sort Key: (integral(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (integral(value1)), (integral(value2)), (integral(value3)), (integral(value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1), public.integral(value2), public.integral(value3), public.integral(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1), public.integral(value2), public.integral(value3), public.integral(value4) FROM public.s32influx
(13 rows)

-- select integral (stub agg function, result)
--Testcase 375:
SELECT integral(value1),integral(value2),integral(value3),integral(value4) FROM s3 ORDER BY 1;
     integral      | integral |      integral      | integral 
-------------------+----------+--------------------+----------
 4.800000000000001 |      600 | -4.800000000000001 |     -600
(1 row)

--Testcase 376:
EXPLAIN VERBOSE
SELECT integral(value1, interval '1s'),integral(value2, interval '1s'),integral(value3, interval '1s'),integral(value4, interval '1s') FROM s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (integral(value1, '@ 1 sec'::interval)), (integral(value2, '@ 1 sec'::interval)), (integral(value3, '@ 1 sec'::interval)), (integral(value4, '@ 1 sec'::interval))
   Sort Key: (integral(s3.value1, '@ 1 sec'::interval))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (integral(value1, '@ 1 sec'::interval)), (integral(value2, '@ 1 sec'::interval)), (integral(value3, '@ 1 sec'::interval)), (integral(value4, '@ 1 sec'::interval))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1, '@ 1 sec'::interval), public.integral(value2, '@ 1 sec'::interval), public.integral(value3, '@ 1 sec'::interval), public.integral(value4, '@ 1 sec'::interval) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1, '@ 1 sec'::interval), public.integral(value2, '@ 1 sec'::interval), public.integral(value3, '@ 1 sec'::interval), public.integral(value4, '@ 1 sec'::interval) FROM public.s32influx
(13 rows)

-- select integral (stub agg function, result)
--Testcase 377:
SELECT integral(value1, interval '1s'),integral(value2, interval '1s'),integral(value3, interval '1s'),integral(value4, interval '1s') FROM s3 ORDER BY 1;
     integral      | integral |      integral      | integral 
-------------------+----------+--------------------+----------
 4.800000000000001 |      600 | -4.800000000000001 |     -600
(1 row)

-- select integral (stub agg function, raise exception if not expected type)
--SELECT integral(value1::numeric),integral(value2::numeric),integral(value3::numeric),integral(value4::numeric) FROM s3 ORDER BY 1;
-- select integral (stub agg function and group by influx_time() and tag) (explain)
--Testcase 378:
EXPLAIN VERBOSE
SELECT integral("value1"),influx_time(time, interval '1s'),tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Sort  (cost=3931.55..3932.05 rows=200 width=48)
   Output: (integral(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (integral(s3.value1))
   ->  HashAggregate  (cost=3871.91..3923.91 rows=200 width=48)
         Output: integral(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: influx_time(s3."time", '@ 1 sec'::interval), s3.tag1
         ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=48)
               Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx
(12 rows)

-- select integral (stub agg function and group by influx_time() and tag) (result)
--Testcase 379:
SELECT integral("value1"),influx_time(time, interval '1s'),tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select integral (stub agg function and group by influx_time() and tag) (explain)
--Testcase 380:
EXPLAIN VERBOSE
SELECT integral("value1", interval '1s'),influx_time(time, interval '1s'),tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=3931.55..3932.05 rows=200 width=48)
   Output: (integral(value1, '@ 1 sec'::interval)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (integral(s3.value1, '@ 1 sec'::interval))
   ->  HashAggregate  (cost=3871.91..3923.91 rows=200 width=48)
         Output: integral(value1, '@ 1 sec'::interval), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: influx_time(s3."time", '@ 1 sec'::interval), s3.tag1
         ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=48)
               Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx
(12 rows)

-- select integral (stub agg function and group by influx_time() and tag) (result)
--Testcase 381:
SELECT integral("value1", interval '1s'),influx_time(time, interval '1s'),tag1 FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select integral (stub agg function and group by tag only) (result)
--Testcase 382:
SELECT tag1,integral("value1") FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 tag1 |      integral      
------+--------------------
 a    |                0.4
 b    | 1.6500000000000001
(2 rows)

-- select integral (stub agg function and other aggs) (result)
--Testcase 383:
SELECT sum("value1"),integral("value1"),count("value1") FROM s3 ORDER BY 1;
        sum        |     integral      | count 
-------------------+-------------------+-------
 7.199999999999999 | 4.800000000000001 |     6
(1 row)

-- select integral (stub agg function and group by tag only) (result)
--Testcase 384:
SELECT tag1,integral("value1", interval '1s') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 tag1 |      integral      
------+--------------------
 a    |                0.4
 b    | 1.6500000000000001
(2 rows)

-- select integral (stub agg function and other aggs) (result)
--Testcase 385:
SELECT sum("value1"),integral("value1", interval '1s'),count("value1") FROM s3 ORDER BY 1;
        sum        |     integral      | count 
-------------------+-------------------+-------
 7.199999999999999 | 4.800000000000001 |     6
(1 row)

-- select integral over join query (explain)
--Testcase 386:
EXPLAIN VERBOSE
SELECT integral(t1.value1), integral(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1204.56..1204.57 rows=1 width=16)
   Output: (integral(t1.value1)), (integral(t2.value1))
   Sort Key: (integral(t1.value1))
   ->  Aggregate  (cost=1204.54..1204.55 rows=1 width=16)
         Output: integral(t1.value1), integral(t2.value1)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=16)
               Output: t1.value1, t2.value1
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select integral over join query (result, stub call error)
--Testcase 387:
SELECT integral(t1.value1), integral(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub integral_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision) line 3 at RAISE
-- select integral over join query (explain)
--Testcase 388:
EXPLAIN VERBOSE
SELECT integral(t1.value1, interval '1s'), integral(t2.value1, interval '1s') FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1204.56..1204.57 rows=1 width=16)
   Output: (integral(t1.value1, '@ 1 sec'::interval)), (integral(t2.value1, '@ 1 sec'::interval))
   Sort Key: (integral(t1.value1, '@ 1 sec'::interval))
   ->  Aggregate  (cost=1204.54..1204.55 rows=1 width=16)
         Output: integral(t1.value1, '@ 1 sec'::interval), integral(t2.value1, '@ 1 sec'::interval)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=16)
               Output: t1.value1, t2.value1
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select integral over join query (result, stub call error)
--Testcase 389:
SELECT integral(t1.value1, interval '1s'), integral(t2.value1, interval '1s') FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub integral_sfunc(double precision, float8, interval) is called
CONTEXT:  PL/pgSQL function integral_sfunc(double precision,double precision,interval) line 3 at RAISE
-- select integral with having (explain)
--Testcase 390:
EXPLAIN VERBOSE
SELECT integral(value1) FROM s3 HAVING integral(value1) > 100 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (integral(value1))
   Sort Key: (integral(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (integral(value1))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1) FROM public.s32influx
(13 rows)

-- select integral with having (explain, not pushdown, stub call error)
--Testcase 391:
SELECT integral(value1) FROM s3 HAVING integral(value1) > 100 ORDER BY 1;
 integral 
----------
(0 rows)

-- select integral with having (explain)
--Testcase 392:
EXPLAIN VERBOSE
SELECT integral(value1, interval '1s') FROM s3 HAVING integral(value1, interval '1s') > 100 ORDER BY 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (integral(value1, '@ 1 sec'::interval))
   Sort Key: (integral(s3.value1, '@ 1 sec'::interval))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (integral(value1, '@ 1 sec'::interval))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1, '@ 1 sec'::interval) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.integral(value1, '@ 1 sec'::interval) FROM public.s32influx
(13 rows)

-- select integral with having (explain, not pushdown, stub call error)
--Testcase 393:
SELECT integral(value1, interval '1s') FROM s3 HAVING integral(value1, interval '1s') > 100 ORDER BY 1;
 integral 
----------
(0 rows)

-- select integral(*) (stub agg function, explain)
--Testcase 394:
EXPLAIN VERBOSE
SELECT integral_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (integral_all(*))
   Sort Key: (integral_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: integral_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select integral(*) (stub agg function, result)
--Testcase 395:
SELECT integral_all(*) from s3 ORDER BY 1;
ERROR:  stub integral_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function integral_all_sfunc(text) line 3 at RAISE
-- select integral(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 396:
EXPLAIN VERBOSE
SELECT integral_all(*) FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort  (cost=3931.55..3932.05 rows=200 width=72)
   Output: (integral_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (integral_all(*))
   ->  HashAggregate  (cost=3871.91..3923.91 rows=200 width=72)
         Output: integral_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: influx_time(s3."time", '@ 1 sec'::interval), s3.tag1
         ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=40)
               Output: influx_time("time", '@ 1 sec'::interval), tag1
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT "time", tag1 FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT "time", tag1 FROM public.s32influx
(12 rows)

-- select integral(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 397:
SELECT integral_all(*) FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select integral(*) (stub agg function and group by tag only) (explain)
--Testcase 398:
EXPLAIN VERBOSE
SELECT integral_all(*) FROM s3 WHERE value1 > 0.3 GROUP BY tag1 ORDER BY 1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Sort  (cost=935.18..935.68 rows=200 width=64)
   Output: (integral_all(*)), tag1
   Sort Key: (integral_all(*))
   ->  HashAggregate  (cost=925.54..927.54 rows=200 width=64)
         Output: integral_all(*), tag1
         Group Key: s3.tag1
         ->  Foreign Scan on public.s3  (cost=200.00..350.84 rows=2276 width=32)
               Output: tag1
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT tag1, value1 FROM public.s31influx WHERE ((value1 > 0.3::double precision))
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT tag1, value1 FROM public.s32influx WHERE ((value1 > 0.3::double precision))
(12 rows)

-- select integral(*) (stub agg function and group by tag only) (result)
--Testcase 399:
SELECT integral_all(*) FROM s3 WHERE value1 > 0.3 GROUP BY tag1 ORDER BY 1;
ERROR:  stub integral_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function integral_all_sfunc(text) line 3 at RAISE
-- select integral(*) (stub agg function, expose data, explain)
--Testcase 400:
EXPLAIN VERBOSE
SELECT (integral_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((integral_all(*))::s3)."time"), (((integral_all(*))::s3).tag1), (((integral_all(*))::s3).value1), (((integral_all(*))::s3).value2), (((integral_all(*))::s3).value3), (((integral_all(*))::s3).value4), (((integral_all(*))::s3).__spd_url)
   Sort Key: (((integral_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((integral_all(*))::s3)."time", ((integral_all(*))::s3).tag1, ((integral_all(*))::s3).value1, ((integral_all(*))::s3).value2, ((integral_all(*))::s3).value3, ((integral_all(*))::s3).value4, ((integral_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select integral(*) (stub agg function, expose data, result)
--Testcase 401:
SELECT (integral_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub integral_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function integral_all_sfunc(text) line 3 at RAISE
-- select integral(regex) (stub agg function, explain)
--Testcase 402:
EXPLAIN VERBOSE
SELECT integral('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (integral('/value[1,4]/'::text))
   Sort Key: (integral('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: integral('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select integral(regex) (stub agg function, result)
--Testcase 403:
SELECT integral('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub integral_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function integral_sfunc(text,text) line 3 at RAISE
-- select integral(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 404:
EXPLAIN VERBOSE
SELECT integral('/^v.*/') FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort  (cost=3931.55..3932.05 rows=200 width=72)
   Output: (integral('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (integral('/^v.*/'::text))
   ->  HashAggregate  (cost=3871.91..3923.91 rows=200 width=72)
         Output: integral('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: influx_time(s3."time", '@ 1 sec'::interval), s3.tag1
         ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=40)
               Output: influx_time("time", '@ 1 sec'::interval), tag1
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT "time", tag1 FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT "time", tag1 FROM public.s32influx
(12 rows)

-- select integral(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 405:
SELECT integral('/^v.*/') FROM s3 GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select integral(regex) (stub agg function and group by tag only) (explain)
--Testcase 406:
EXPLAIN VERBOSE
SELECT integral('/value[1,4]/') FROM s3 WHERE value1 > 0.3 GROUP BY tag1 ORDER BY 1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Sort  (cost=935.18..935.68 rows=200 width=64)
   Output: (integral('/value[1,4]/'::text)), tag1
   Sort Key: (integral('/value[1,4]/'::text))
   ->  HashAggregate  (cost=925.54..927.54 rows=200 width=64)
         Output: integral('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Foreign Scan on public.s3  (cost=200.00..350.84 rows=2276 width=32)
               Output: tag1
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT tag1, value1 FROM public.s31influx WHERE ((value1 > 0.3::double precision))
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT tag1, value1 FROM public.s32influx WHERE ((value1 > 0.3::double precision))
(12 rows)

-- select integral(regex) (stub agg function and group by tag only) (result)
--Testcase 407:
SELECT integral('/value[1,4]/') FROM s3 WHERE value1 > 0.3 GROUP BY tag1 ORDER BY 1;
ERROR:  stub integral_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function integral_sfunc(text,text) line 3 at RAISE
-- select integral(regex) (stub agg function, expose data, explain)
--Testcase 408:
EXPLAIN VERBOSE
SELECT (integral('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                            QUERY PLAN                                                                                                                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((integral('/value[1,4]/'::text))::s3)."time"), (((integral('/value[1,4]/'::text))::s3).tag1), (((integral('/value[1,4]/'::text))::s3).value1), (((integral('/value[1,4]/'::text))::s3).value2), (((integral('/value[1,4]/'::text))::s3).value3), (((integral('/value[1,4]/'::text))::s3).value4), (((integral('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((integral('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((integral('/value[1,4]/'::text))::s3)."time", ((integral('/value[1,4]/'::text))::s3).tag1, ((integral('/value[1,4]/'::text))::s3).value1, ((integral('/value[1,4]/'::text))::s3).value2, ((integral('/value[1,4]/'::text))::s3).value3, ((integral('/value[1,4]/'::text))::s3).value4, ((integral('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select integral(regex) (stub agg function, expose data, result)
--Testcase 409:
SELECT (integral('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub integral_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function integral_sfunc(text,text) line 3 at RAISE
-- select mean (stub agg function, explain)
--Testcase 410:
EXPLAIN VERBOSE
SELECT mean(value1),mean(value2),mean(value3),mean(value4) FROM s3 ORDER BY 1;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (mean(value1)), (mean(value2)), (mean(value3)), (mean(value4))
   Sort Key: (mean(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (mean(value1)), (mean(value2)), (mean(value3)), (mean(value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.mean(value1), public.mean(value2), public.mean(value3), public.mean(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.mean(value1), public.mean(value2), public.mean(value3), public.mean(value4) FROM public.s32influx
(13 rows)

-- select mean (stub agg function, result)
--Testcase 411:
SELECT mean(value1),mean(value2),mean(value3),mean(value4) FROM s3 ORDER BY 1;
 mean | mean | mean | mean 
------+------+------+------
  2.4 |  300 | -2.4 | -300
(1 row)

-- select mean (stub agg function, raise exception if not expected type)
--SELECT mean(value1::numeric),mean(value2::numeric),mean(value3::numeric),mean(value4::numeric) FROM s3 ORDER BY 1;
-- select mean (stub agg function and group by influx_time() and tag) (explain)
--Testcase 412:
EXPLAIN VERBOSE
SELECT mean("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=48)
   Output: (mean(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (mean(s3.value1))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=48)
         Output: mean(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=48)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1, value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=48)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select mean (stub agg function and group by influx_time() and tag) (result)
--Testcase 413:
SELECT mean("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select mean (stub agg function and group by tag only) (result)
--Testcase 414:
SELECT tag1,mean("value1") FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 tag1 |        mean         
------+---------------------
 a    | 0.20000000000000004
 b    |  1.6500000000000001
(2 rows)

-- select mean (stub agg function and other aggs) (result)
--Testcase 415:
SELECT sum("value1"),mean("value1"),count("value1") FROM s3 ORDER BY 1;
        sum        | mean | count 
-------------------+------+-------
 7.199999999999999 |  2.4 |     6
(1 row)

-- select mean over join query (explain)
--Testcase 416:
EXPLAIN VERBOSE
SELECT mean(t1.value1), mean(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1204.56..1204.57 rows=1 width=16)
   Output: (mean(t1.value1)), (mean(t2.value1))
   Sort Key: (mean(t1.value1))
   ->  Aggregate  (cost=1204.54..1204.55 rows=1 width=16)
         Output: mean(t1.value1), mean(t2.value1)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=16)
               Output: t1.value1, t2.value1
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select mean over join query (result, stub call error)
--Testcase 417:
SELECT mean(t1.value1), mean(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub mean_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function mean_sfunc(double precision,double precision) line 3 at RAISE
-- select mean with having (explain)
--Testcase 418:
EXPLAIN VERBOSE
SELECT mean(value1) FROM s3 HAVING mean(value1) > 100 ORDER BY 1;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (mean(value1))
   Sort Key: (mean(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (mean(value1))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.mean(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.mean(value1) FROM public.s32influx
(13 rows)

-- select mean with having (explain, not pushdown, stub call error)
--Testcase 419:
SELECT mean(value1) FROM s3 HAVING mean(value1) > 100 ORDER BY 1;
 mean 
------
(0 rows)

-- select mean(*) (stub agg function, explain)
--Testcase 420:
EXPLAIN VERBOSE
SELECT mean_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (mean_all(*))
   Sort Key: (mean_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: mean_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select mean(*) (stub agg function, result)
--Testcase 421:
SELECT mean_all(*) from s3 ORDER BY 1;
ERROR:  stub mean_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function mean_all_sfunc(text) line 3 at RAISE
-- select mean(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 422:
EXPLAIN VERBOSE
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (mean_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (mean_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: mean_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select mean(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 423:
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select mean(*) (stub agg function and group by tag only) (explain)
--Testcase 424:
EXPLAIN VERBOSE
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (mean_all(*)), tag1
   Sort Key: (mean_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: mean_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select mean(*) (stub agg function and group by tag only) (result)
--Testcase 425:
SELECT mean_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub mean_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function mean_all_sfunc(text) line 3 at RAISE
-- select mean(*) (stub agg function, expose data, explain)
--Testcase 426:
EXPLAIN VERBOSE
SELECT (mean_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((mean_all(*))::s3)."time"), (((mean_all(*))::s3).tag1), (((mean_all(*))::s3).value1), (((mean_all(*))::s3).value2), (((mean_all(*))::s3).value3), (((mean_all(*))::s3).value4), (((mean_all(*))::s3).__spd_url)
   Sort Key: (((mean_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((mean_all(*))::s3)."time", ((mean_all(*))::s3).tag1, ((mean_all(*))::s3).value1, ((mean_all(*))::s3).value2, ((mean_all(*))::s3).value3, ((mean_all(*))::s3).value4, ((mean_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select mean(*) (stub agg function, expose data, result)
--Testcase 427:
SELECT (mean_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub mean_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function mean_all_sfunc(text) line 3 at RAISE
-- select mean(regex) (stub agg function, explain)
--Testcase 428:
EXPLAIN VERBOSE
SELECT mean('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (mean('/value[1,4]/'::text))
   Sort Key: (mean('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: mean('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select mean(regex) (stub agg function, result)
--Testcase 429:
SELECT mean('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub mean_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function mean_sfunc(text,text) line 3 at RAISE
-- select mean(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 430:
EXPLAIN VERBOSE
SELECT mean('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (mean('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (mean('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: mean('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select mean(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 431:
SELECT mean('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select mean(regex) (stub agg function and group by tag only) (explain)
--Testcase 432:
EXPLAIN VERBOSE
SELECT mean('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (mean('/value[1,4]/'::text)), tag1
   Sort Key: (mean('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: mean('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select mean(regex) (stub agg function and group by tag only) (result)
--Testcase 433:
SELECT mean('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub mean_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function mean_sfunc(text,text) line 3 at RAISE
-- select mean(regex) (stub agg function, expose data, explain)
--Testcase 434:
EXPLAIN VERBOSE
SELECT (mean('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                              QUERY PLAN                                                                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((mean('/value[1,4]/'::text))::s3)."time"), (((mean('/value[1,4]/'::text))::s3).tag1), (((mean('/value[1,4]/'::text))::s3).value1), (((mean('/value[1,4]/'::text))::s3).value2), (((mean('/value[1,4]/'::text))::s3).value3), (((mean('/value[1,4]/'::text))::s3).value4), (((mean('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((mean('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((mean('/value[1,4]/'::text))::s3)."time", ((mean('/value[1,4]/'::text))::s3).tag1, ((mean('/value[1,4]/'::text))::s3).value1, ((mean('/value[1,4]/'::text))::s3).value2, ((mean('/value[1,4]/'::text))::s3).value3, ((mean('/value[1,4]/'::text))::s3).value4, ((mean('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select mean(regex) (stub agg function, expose data, result)
--Testcase 435:
SELECT (mean('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub mean_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function mean_sfunc(text,text) line 3 at RAISE
-- select median (stub agg function, explain)
--Testcase 436:
EXPLAIN VERBOSE
SELECT median(value1),median(value2),median(value3),median(value4) FROM s3 ORDER BY 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (median(value1)), (median(value2)), (median(value3)), (median(value4))
   Sort Key: (median(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (median(value1)), (median(value2)), (median(value3)), (median(value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.median(value1), public.median(value2), public.median(value3), public.median(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.median(value1), public.median(value2), public.median(value3), public.median(value4) FROM public.s32influx
(13 rows)

-- select median (stub agg function, result)
--Testcase 437:
SELECT median(value1),median(value2),median(value3),median(value4) FROM s3 ORDER BY 1;
       median       | median |       median        | median 
--------------------+--------+---------------------+--------
 2.4000000000000004 |    300 | -2.4000000000000004 |   -300
(1 row)

-- select median (stub agg function, raise exception if not expected type)
--SELECT median(value1::numeric),median(value2::numeric),median(value3::numeric),median(value4::numeric) FROM s3 ORDER BY 1;
-- select median (stub agg function and group by influx_time() and tag) (explain)
--Testcase 438:
EXPLAIN VERBOSE
SELECT median("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=48)
   Output: (median(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (median(s3.value1))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=48)
         Output: median(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=48)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1, value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=48)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select median (stub agg function and group by influx_time() and tag) (result)
--Testcase 439:
SELECT median("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select median (stub agg function and group by tag only) (result)
--Testcase 440:
SELECT tag1,median("value1") FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 tag1 |       median       
------+--------------------
 a    |                0.2
 b    | 1.6500000000000001
(2 rows)

-- select median (stub agg function and other aggs) (result)
--Testcase 441:
SELECT sum("value1"),median("value1"),count("value1") FROM s3 ORDER BY 1;
        sum        |       median       | count 
-------------------+--------------------+-------
 7.199999999999999 | 2.4000000000000004 |     6
(1 row)

-- select median over join query (explain)
--Testcase 442:
EXPLAIN VERBOSE
SELECT median(t1.value1), median(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1204.56..1204.57 rows=1 width=16)
   Output: (median(t1.value1)), (median(t2.value1))
   Sort Key: (median(t1.value1))
   ->  Aggregate  (cost=1204.54..1204.55 rows=1 width=16)
         Output: median(t1.value1), median(t2.value1)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=16)
               Output: t1.value1, t2.value1
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select median over join query (result, stub call error)
--Testcase 443:
SELECT median(t1.value1), median(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub median_sfunc(double precision, float8) is called
CONTEXT:  PL/pgSQL function median_sfunc(double precision,double precision) line 3 at RAISE
-- select median with having (explain)
--Testcase 444:
EXPLAIN VERBOSE
SELECT median(value1) FROM s3 HAVING median(value1) > 100 ORDER BY 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (median(value1))
   Sort Key: (median(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (median(value1))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.median(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.median(value1) FROM public.s32influx
(13 rows)

-- select median with having (explain, not pushdown, stub call error)
--Testcase 445:
SELECT median(value1) FROM s3 HAVING median(value1) > 100 ORDER BY 1;
 median 
--------
(0 rows)

-- select median(*) (stub agg function, explain)
--Testcase 446:
EXPLAIN VERBOSE
SELECT median_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (median_all(*))
   Sort Key: (median_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: median_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select median(*) (stub agg function, result)
--Testcase 447:
SELECT median_all(*) from s3 ORDER BY 1;
ERROR:  stub median_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function median_all_sfunc(text) line 3 at RAISE
-- select median(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 448:
EXPLAIN VERBOSE
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (median_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (median_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: median_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select median(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 449:
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select median(*) (stub agg function and group by tag only) (explain)
--Testcase 450:
EXPLAIN VERBOSE
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (median_all(*)), tag1
   Sort Key: (median_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: median_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select median(*) (stub agg function and group by tag only) (result)
--Testcase 451:
SELECT median_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub median_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function median_all_sfunc(text) line 3 at RAISE
-- select median(*) (stub agg function, expose data, explain)
--Testcase 452:
EXPLAIN VERBOSE
SELECT (median_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((median_all(*))::s3)."time"), (((median_all(*))::s3).tag1), (((median_all(*))::s3).value1), (((median_all(*))::s3).value2), (((median_all(*))::s3).value3), (((median_all(*))::s3).value4), (((median_all(*))::s3).__spd_url)
   Sort Key: (((median_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((median_all(*))::s3)."time", ((median_all(*))::s3).tag1, ((median_all(*))::s3).value1, ((median_all(*))::s3).value2, ((median_all(*))::s3).value3, ((median_all(*))::s3).value4, ((median_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select median(*) (stub agg function, expose data, result)
--Testcase 453:
SELECT (median_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub median_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function median_all_sfunc(text) line 3 at RAISE
-- select median(regex) (stub agg function, explain)
--Testcase 454:
EXPLAIN VERBOSE
SELECT median('/^v.*/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (median('/^v.*/'::text))
   Sort Key: (median('/^v.*/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: median('/^v.*/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select median(regex) (stub agg function, result)
--Testcase 455:
SELECT  median('/^v.*/') from s3 ORDER BY 1;
ERROR:  stub median_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function median_sfunc(text,text) line 3 at RAISE
-- select median(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 456:
EXPLAIN VERBOSE
SELECT median('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (median('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (median('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: median('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select median(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 457:
SELECT median('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select median(regex) (stub agg function and group by tag only) (explain)
--Testcase 458:
EXPLAIN VERBOSE
SELECT median('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (median('/value[1,4]/'::text)), tag1
   Sort Key: (median('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: median('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select median(regex) (stub agg function and group by tag only) (result)
--Testcase 459:
SELECT median('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub median_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function median_sfunc(text,text) line 3 at RAISE
-- select median(regex) (stub agg function, expose data, explain)
--Testcase 460:
EXPLAIN VERBOSE
SELECT (median('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((median('/value[1,4]/'::text))::s3)."time"), (((median('/value[1,4]/'::text))::s3).tag1), (((median('/value[1,4]/'::text))::s3).value1), (((median('/value[1,4]/'::text))::s3).value2), (((median('/value[1,4]/'::text))::s3).value3), (((median('/value[1,4]/'::text))::s3).value4), (((median('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((median('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((median('/value[1,4]/'::text))::s3)."time", ((median('/value[1,4]/'::text))::s3).tag1, ((median('/value[1,4]/'::text))::s3).value1, ((median('/value[1,4]/'::text))::s3).value2, ((median('/value[1,4]/'::text))::s3).value3, ((median('/value[1,4]/'::text))::s3).value4, ((median('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select median(regex) (stub agg function, expose data, result)
--Testcase 461:
SELECT (median('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub median_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function median_sfunc(text,text) line 3 at RAISE
-- select influx_mode (stub agg function, explain)
--Testcase 462:
EXPLAIN VERBOSE
SELECT influx_mode(value1),influx_mode(value2),influx_mode(value3),influx_mode(value4) FROM s3 ORDER BY 1;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=32)
   Output: (influx_mode(value1)), (influx_mode(value2)), (influx_mode(value3)), (influx_mode(value4))
   Sort Key: (influx_mode(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
         Output: (influx_mode(value1)), (influx_mode(value2)), (influx_mode(value3)), (influx_mode(value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_mode(value1), public.influx_mode(value2), public.influx_mode(value3), public.influx_mode(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_mode(value1), public.influx_mode(value2), public.influx_mode(value3), public.influx_mode(value4) FROM public.s32influx
(13 rows)

-- select influx_mode (stub agg function, result)
--Testcase 463:
SELECT influx_mode(value1),influx_mode(value2),influx_mode(value3),influx_mode(value4) FROM s3 ORDER BY 1;
    influx_mode     | influx_mode |     influx_mode     | influx_mode 
--------------------+-------------+---------------------+-------------
 1.2000000000000002 |         300 | -3.5999999999999996 |        -300
(1 row)

-- select influx_mode (stub agg function, raise exception if not expected type)
--SELECT influx_mode(value1::numeric),influx_mode(value2::numeric),influx_mode(value3::numeric),influx_mode(value4::numeric) FROM s3 ORDER BY 1;
-- select influx_mode (stub agg function and group by influx_time() and tag) (explain)
--Testcase 464:
EXPLAIN VERBOSE
SELECT influx_mode("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=48)
   Output: (influx_mode(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_mode(s3.value1))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=48)
         Output: influx_mode(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=48)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1, value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=48)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_mode (stub agg function and group by influx_time() and tag) (result)
--Testcase 465:
SELECT influx_mode("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_mode (stub agg function and group by tag only) (result)
--Testcase 466:
SELECT tag1,influx_mode("value1") FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 tag1 | influx_mode 
------+-------------
 a    |         0.1
 b    |         1.1
(2 rows)

-- select influx_mode (stub agg function and other aggs) (result)
--Testcase 467:
SELECT sum("value1"),influx_mode("value1"),count("value1") FROM s3 ORDER BY 1;
        sum        |    influx_mode     | count 
-------------------+--------------------+-------
 7.199999999999999 | 1.2000000000000002 |     6
(1 row)

-- select influx_mode over join query (explain)
--Testcase 468:
EXPLAIN VERBOSE
SELECT influx_mode(t1.value1), influx_mode(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1204.56..1204.57 rows=1 width=16)
   Output: (influx_mode(t1.value1)), (influx_mode(t2.value1))
   Sort Key: (influx_mode(t1.value1))
   ->  Aggregate  (cost=1204.54..1204.55 rows=1 width=16)
         Output: influx_mode(t1.value1), influx_mode(t2.value1)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=16)
               Output: t1.value1, t2.value1
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select influx_mode over join query (result, stub call error)
--Testcase 469:
SELECT influx_mode(t1.value1), influx_mode(t2.value1) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub influx_mode_sfunc(anyelement, anyelement) is called
CONTEXT:  PL/pgSQL function influx_mode_sfunc(anyelement,anyelement) line 3 at RAISE
-- select influx_mode with having (explain)
--Testcase 470:
EXPLAIN VERBOSE
SELECT influx_mode(value1) FROM s3 HAVING influx_mode(value1) > 100 ORDER BY 1;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (influx_mode(value1))
   Sort Key: (influx_mode(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (influx_mode(value1))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_mode(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_mode(value1) FROM public.s32influx
(13 rows)

-- select influx_mode with having (explain, not pushdown, stub call error)
--Testcase 471:
SELECT influx_mode(value1) FROM s3 HAVING influx_mode(value1) > 100 ORDER BY 1;
 influx_mode 
-------------
(0 rows)

-- select influx_mode(*) (stub agg function, explain)
--Testcase 472:
EXPLAIN VERBOSE
SELECT influx_mode_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_mode_all(*))
   Sort Key: (influx_mode_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_mode_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_mode(*) (stub agg function, result)
--Testcase 473:
SELECT influx_mode_all(*) from s3 ORDER BY 1;
ERROR:  stub influx_mode_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_mode_all_sfunc(text) line 3 at RAISE
-- select influx_mode(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 474:
EXPLAIN VERBOSE
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_mode_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_mode_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_mode_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_mode(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 475:
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_mode(*) (stub agg function and group by tag only) (explain)
--Testcase 476:
EXPLAIN VERBOSE
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_mode_all(*)), tag1
   Sort Key: (influx_mode_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_mode_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_mode(*) (stub agg function and group by tag only) (result)
--Testcase 477:
SELECT influx_mode_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_mode_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_mode_all_sfunc(text) line 3 at RAISE
-- select influx_mode(*) (stub agg function, expose data, explain)
--Testcase 478:
EXPLAIN VERBOSE
SELECT (influx_mode_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                                  QUERY PLAN                                                                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_mode_all(*))::s3)."time"), (((influx_mode_all(*))::s3).tag1), (((influx_mode_all(*))::s3).value1), (((influx_mode_all(*))::s3).value2), (((influx_mode_all(*))::s3).value3), (((influx_mode_all(*))::s3).value4), (((influx_mode_all(*))::s3).__spd_url)
   Sort Key: (((influx_mode_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_mode_all(*))::s3)."time", ((influx_mode_all(*))::s3).tag1, ((influx_mode_all(*))::s3).value1, ((influx_mode_all(*))::s3).value2, ((influx_mode_all(*))::s3).value3, ((influx_mode_all(*))::s3).value4, ((influx_mode_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_mode(*) (stub agg function, expose data, result)
--Testcase 479:
SELECT (influx_mode_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_mode_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_mode_all_sfunc(text) line 3 at RAISE
-- select influx_mode(regex) (stub function, explain)
--Testcase 480:
EXPLAIN VERBOSE
SELECT influx_mode('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_mode('/value[1,4]/'::text))
   Sort Key: (influx_mode('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_mode('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_mode(regex) (stub function, result)
--Testcase 481:
SELECT influx_mode('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub influx_mode_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_mode_sfunc(text,text) line 3 at RAISE
-- select influx_mode(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 482:
EXPLAIN VERBOSE
SELECT influx_mode('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_mode('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_mode('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_mode('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_mode(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 483:
SELECT influx_mode('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_mode(regex) (stub agg function and group by tag only) (explain)
--Testcase 484:
EXPLAIN VERBOSE
SELECT influx_mode('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_mode('/value[1,4]/'::text)), tag1
   Sort Key: (influx_mode('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_mode('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_mode(regex) (stub agg function and group by tag only) (result)
--Testcase 485:
SELECT influx_mode('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_mode_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_mode_sfunc(text,text) line 3 at RAISE
-- select influx_mode(regex) (stub agg function, expose data, explain)
--Testcase 486:
EXPLAIN VERBOSE
SELECT (influx_mode('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_mode('/value[1,4]/'::text))::s3)."time"), (((influx_mode('/value[1,4]/'::text))::s3).tag1), (((influx_mode('/value[1,4]/'::text))::s3).value1), (((influx_mode('/value[1,4]/'::text))::s3).value2), (((influx_mode('/value[1,4]/'::text))::s3).value3), (((influx_mode('/value[1,4]/'::text))::s3).value4), (((influx_mode('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((influx_mode('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_mode('/value[1,4]/'::text))::s3)."time", ((influx_mode('/value[1,4]/'::text))::s3).tag1, ((influx_mode('/value[1,4]/'::text))::s3).value1, ((influx_mode('/value[1,4]/'::text))::s3).value2, ((influx_mode('/value[1,4]/'::text))::s3).value3, ((influx_mode('/value[1,4]/'::text))::s3).value4, ((influx_mode('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_mode(regex) (stub agg function, expose data, result)
--Testcase 487:
SELECT (influx_mode('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_mode_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_mode_sfunc(text,text) line 3 at RAISE
-- select stddev (agg function, explain)
--Testcase 488:
EXPLAIN VERBOSE
SELECT stddev(value1),stddev(value2),stddev(value3),stddev(value4) FROM s3 ORDER BY 1;
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=80)
   Output: (stddev(value1)), (stddev(value2)), (stddev(value3)), (stddev(value4))
   Sort Key: (stddev(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=80)
         Output: (stddev(value1)), (stddev(value2)), (stddev(value3)), (stddev(value4))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT count(value1), sum(value1), sum((value1 * value1)), count(value2), sum(value2), sum((value2 * value2)), count(value3), sum(value3), sum((value3 * value3)), count(value4), sum(value4), sum((value4 * value4)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT count(value1), sum(value1), sum((value1 * value1)), count(value2), sum(value2), sum((value2 * value2)), count(value3), sum(value3), sum((value3 * value3)), count(value4), sum(value4), sum((value4 * value4)) FROM public.s32influx
(13 rows)

-- select stddev (agg function, result)
--Testcase 489:
SELECT stddev(value1),stddev(value2),stddev(value3),stddev(value4) FROM s3 ORDER BY 1;
       stddev       |      stddev      |       stddev       |      stddev      
--------------------+------------------+--------------------+------------------
 1.2992305415129373 | 54.7722557505166 | 1.2992305415129373 | 54.7722557505166
(1 row)

-- select stddev (agg function and group by influx_time() and tag) (explain)
--Testcase 490:
EXPLAIN VERBOSE
SELECT stddev("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=341.97..342.05 rows=32 width=48)
   Output: (stddev(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (stddev(s3.value1))
   ->  GroupAggregate  (cost=332.43..341.17 rows=32 width=48)
         Output: stddev(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=48)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1, value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=48)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select stddev (agg function and group by influx_time() and tag) (result)
--Testcase 491:
SELECT stddev("value1"),influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select stddev (agg function and group by tag only) (result)
--Testcase 492:
SELECT tag1,stddev("value1") FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 tag1 |       stddev        
------+---------------------
 a    | 0.09999999999999994
 b    |   0.777817459305202
(2 rows)

-- select stddev (agg function and other aggs) (result)
--Testcase 493:
SELECT sum("value1"),stddev("value1"),count("value1") FROM s3 ORDER BY 1;
        sum        |       stddev       | count 
-------------------+--------------------+-------
 7.199999999999999 | 1.2992305415129373 |     6
(1 row)

-- select stddev(*) (stub agg function, explain)
--Testcase 494:
EXPLAIN VERBOSE
SELECT stddev_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (stddev_all(*))
   Sort Key: (stddev_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: stddev_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select stddev(*) (stub agg function, result)
--Testcase 495:
SELECT stddev_all(*) from s3 ORDER BY 1;
ERROR:  stub stddev_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function stddev_all_sfunc(text) line 3 at RAISE
-- select stddev(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 496:
EXPLAIN VERBOSE
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (stddev_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (stddev_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: stddev_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select stddev(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 497:
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select stddev(*) (stub agg function and group by tag only) (explain)
--Testcase 498:
EXPLAIN VERBOSE
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (stddev_all(*)), tag1
   Sort Key: (stddev_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: stddev_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select stddev(*) (stub agg function and group by tag only) (result)
--Testcase 499:
SELECT stddev_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub stddev_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function stddev_all_sfunc(text) line 3 at RAISE
-- select stddev(regex) (stub function, explain)
--Testcase 500:
EXPLAIN VERBOSE
SELECT stddev('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (stddev('/value[1,4]/'::text))
   Sort Key: (stddev('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: stddev('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select stddev(regex) (stub function, result)
--Testcase 501:
SELECT stddev('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub stddev_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function stddev_sfunc(text,text) line 3 at RAISE
-- select stddev(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 502:
EXPLAIN VERBOSE
SELECT stddev('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (stddev('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (stddev('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: stddev('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select stddev(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 503:
SELECT stddev('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select stddev(regex) (stub agg function and group by tag only) (explain)
--Testcase 504:
EXPLAIN VERBOSE
SELECT stddev('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (stddev('/value[1,4]/'::text)), tag1
   Sort Key: (stddev('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: stddev('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select stddev(regex) (stub agg function and group by tag only) (result)
--Testcase 505:
SELECT stddev('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub stddev_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function stddev_sfunc(text,text) line 3 at RAISE
-- select influx_sum(*) (stub agg function, explain)
--Testcase 506:
EXPLAIN VERBOSE
SELECT influx_sum_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_sum_all(*))
   Sort Key: (influx_sum_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_sum_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_sum(*) (stub agg function, result)
--Testcase 507:
SELECT influx_sum_all(*) from s3 ORDER BY 1;
ERROR:  stub influx_sum_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_sum_all_sfunc(text) line 3 at RAISE
-- select influx_sum(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 508:
EXPLAIN VERBOSE
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_sum_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_sum_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_sum_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_sum(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 509:
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_sum(*) (stub agg function and group by tag only) (explain)
--Testcase 510:
EXPLAIN VERBOSE
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_sum_all(*)), tag1
   Sort Key: (influx_sum_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_sum_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_sum(*) (stub agg function and group by tag only) (result)
--Testcase 511:
SELECT influx_sum_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_sum_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_sum_all_sfunc(text) line 3 at RAISE
-- select influx_sum(*) (stub agg function, expose data, explain)
--Testcase 512:
EXPLAIN VERBOSE
SELECT (influx_sum_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_sum_all(*))::s3)."time"), (((influx_sum_all(*))::s3).tag1), (((influx_sum_all(*))::s3).value1), (((influx_sum_all(*))::s3).value2), (((influx_sum_all(*))::s3).value3), (((influx_sum_all(*))::s3).value4), (((influx_sum_all(*))::s3).__spd_url)
   Sort Key: (((influx_sum_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_sum_all(*))::s3)."time", ((influx_sum_all(*))::s3).tag1, ((influx_sum_all(*))::s3).value1, ((influx_sum_all(*))::s3).value2, ((influx_sum_all(*))::s3).value3, ((influx_sum_all(*))::s3).value4, ((influx_sum_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_sum(*) (stub agg function, expose data, result)
--Testcase 513:
SELECT (influx_sum_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_sum_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_sum_all_sfunc(text) line 3 at RAISE
-- select influx_sum(regex) (stub function, explain)
--Testcase 514:
EXPLAIN VERBOSE
SELECT influx_sum('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_sum('/value[1,4]/'::text))
   Sort Key: (influx_sum('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_sum('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_sum(regex) (stub function, result)
--Testcase 515:
SELECT influx_sum('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub influx_sum_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_sum_sfunc(text,text) line 3 at RAISE
-- select influx_sum(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 516:
EXPLAIN VERBOSE
SELECT influx_sum('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_sum('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_sum('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_sum('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_sum(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 517:
SELECT influx_sum('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_sum(regex) (stub agg function and group by tag only) (explain)
--Testcase 518:
EXPLAIN VERBOSE
SELECT influx_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_sum('/value[1,4]/'::text)), tag1
   Sort Key: (influx_sum('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_sum('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_sum(regex) (stub agg function and group by tag only) (result)
--Testcase 519:
SELECT influx_sum('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_sum_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_sum_sfunc(text,text) line 3 at RAISE
-- select influx_sum(regex) (stub agg function, expose data, explain)
--Testcase 520:
EXPLAIN VERBOSE
SELECT (influx_sum('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_sum('/value[1,4]/'::text))::s3)."time"), (((influx_sum('/value[1,4]/'::text))::s3).tag1), (((influx_sum('/value[1,4]/'::text))::s3).value1), (((influx_sum('/value[1,4]/'::text))::s3).value2), (((influx_sum('/value[1,4]/'::text))::s3).value3), (((influx_sum('/value[1,4]/'::text))::s3).value4), (((influx_sum('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((influx_sum('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_sum('/value[1,4]/'::text))::s3)."time", ((influx_sum('/value[1,4]/'::text))::s3).tag1, ((influx_sum('/value[1,4]/'::text))::s3).value1, ((influx_sum('/value[1,4]/'::text))::s3).value2, ((influx_sum('/value[1,4]/'::text))::s3).value3, ((influx_sum('/value[1,4]/'::text))::s3).value4, ((influx_sum('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_sum(regex) (stub agg function, expose data, result)
--Testcase 521:
SELECT (influx_sum('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_sum_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_sum_sfunc(text,text) line 3 at RAISE
-- selector function bottom() (explain)
--Testcase 522:
EXPLAIN VERBOSE
SELECT bottom(value1, 1) FROM s3 ORDER BY 1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=8)
   Output: (bottom(value1, 1))
   Sort Key: (bottom(s3.value1, 1))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=8)
         Output: (bottom(value1, 1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.bottom(value1, 1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.bottom(value1, 1) FROM public.s32influx
(9 rows)

-- selector function bottom() (result)
--Testcase 523:
SELECT bottom(value1, 1) FROM s3 ORDER BY 1;
 bottom 
--------
    0.1
    1.1
(2 rows)

-- selector function bottom() cannot be combined with other functions(explain)
--Testcase 524:
EXPLAIN VERBOSE
SELECT bottom(value1, 1), bottom(value2, 1), bottom(value3, 1), bottom(value4, 1) FROM s3 ORDER BY 1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (bottom(value1, 1)), (bottom(value2, 1)), (bottom(value3, 1)), (bottom(value4, 1))
   Sort Key: (bottom(s3.value1, 1))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (bottom(value1, 1)), (bottom(value2, 1)), (bottom(value3, 1)), (bottom(value4, 1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.bottom(value1, 1), public.bottom(value2, 1), public.bottom(value3, 1), public.bottom(value4, 1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.bottom(value1, 1), public.bottom(value2, 1), public.bottom(value3, 1), public.bottom(value4, 1) FROM public.s32influx
(9 rows)

-- selector function bottom() cannot be combined with other functions(result)
--SELECT bottom(value1, 1), bottom(value2, 1), bottom(value3, 1), bottom(value4, 1) FROM s3 ORDER BY 1;
-- select influx_max(*) (stub agg function, explain)
--Testcase 525:
EXPLAIN VERBOSE
SELECT influx_max_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_max_all(*))
   Sort Key: (influx_max_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_max_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_max(*) (stub agg function, result)
--Testcase 526:
SELECT influx_max_all(*) from s3 ORDER BY 1;
ERROR:  stub influx_max_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_max_all_sfunc(text) line 3 at RAISE
-- select influx_max(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 527:
EXPLAIN VERBOSE
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_max_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_max_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_max_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_max(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 528:
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_max(*) (stub agg function and group by tag only) (explain)
--Testcase 529:
EXPLAIN VERBOSE
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_max_all(*)), tag1
   Sort Key: (influx_max_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_max_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_max(*) (stub agg function and group by tag only) (result)
--Testcase 530:
SELECT influx_max_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_max_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_max_all_sfunc(text) line 3 at RAISE
-- select influx_max(*) (stub agg function, expose data, explain)
--Testcase 531:
EXPLAIN VERBOSE
SELECT (influx_max_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_max_all(*))::s3)."time"), (((influx_max_all(*))::s3).tag1), (((influx_max_all(*))::s3).value1), (((influx_max_all(*))::s3).value2), (((influx_max_all(*))::s3).value3), (((influx_max_all(*))::s3).value4), (((influx_max_all(*))::s3).__spd_url)
   Sort Key: (((influx_max_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_max_all(*))::s3)."time", ((influx_max_all(*))::s3).tag1, ((influx_max_all(*))::s3).value1, ((influx_max_all(*))::s3).value2, ((influx_max_all(*))::s3).value3, ((influx_max_all(*))::s3).value4, ((influx_max_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_max(*) (stub agg function, expose data, result)
--Testcase 532:
SELECT (influx_max_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_max_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_max_all_sfunc(text) line 3 at RAISE
-- select influx_max(regex) (stub function, explain)
--Testcase 533:
EXPLAIN VERBOSE
SELECT influx_max('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_max('/value[1,4]/'::text))
   Sort Key: (influx_max('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_max('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_max(regex) (stub function, result)
--Testcase 534:
SELECT influx_max('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub influx_max_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_max_sfunc(text,text) line 3 at RAISE
-- select influx_max(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 535:
EXPLAIN VERBOSE
SELECT influx_max('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_max('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_max('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_max('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_max(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 536:
SELECT influx_max('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_max(regex) (stub agg function and group by tag only) (explain)
--Testcase 537:
EXPLAIN VERBOSE
SELECT influx_max('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_max('/value[1,4]/'::text)), tag1
   Sort Key: (influx_max('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_max('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_max(regex) (stub agg function and group by tag only) (result)
--Testcase 538:
SELECT influx_max('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_max_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_max_sfunc(text,text) line 3 at RAISE
-- select influx_max(regex) (stub agg function, expose data, explain)
--Testcase 539:
EXPLAIN VERBOSE
SELECT (influx_max('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_max('/value[1,4]/'::text))::s3)."time"), (((influx_max('/value[1,4]/'::text))::s3).tag1), (((influx_max('/value[1,4]/'::text))::s3).value1), (((influx_max('/value[1,4]/'::text))::s3).value2), (((influx_max('/value[1,4]/'::text))::s3).value3), (((influx_max('/value[1,4]/'::text))::s3).value4), (((influx_max('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((influx_max('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_max('/value[1,4]/'::text))::s3)."time", ((influx_max('/value[1,4]/'::text))::s3).tag1, ((influx_max('/value[1,4]/'::text))::s3).value1, ((influx_max('/value[1,4]/'::text))::s3).value2, ((influx_max('/value[1,4]/'::text))::s3).value3, ((influx_max('/value[1,4]/'::text))::s3).value4, ((influx_max('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_max(regex) (stub agg function, expose data, result)
--Testcase 540:
SELECT (influx_max('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_max_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_max_sfunc(text,text) line 3 at RAISE
-- select influx_min(*) (stub agg function, explain)
--Testcase 541:
EXPLAIN VERBOSE
SELECT influx_min_all(*) from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_min_all(*))
   Sort Key: (influx_min_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_min_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_min(*) (stub agg function, result)
--Testcase 542:
SELECT influx_min_all(*) from s3 ORDER BY 1;
ERROR:  stub influx_min_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_min_all_sfunc(text) line 3 at RAISE
-- select influx_min(*) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 543:
EXPLAIN VERBOSE
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_min_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_min_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_min_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_min(*) (stub agg function and group by influx_time() and tag) (result)
--Testcase 544:
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_min(*) (stub agg function and group by tag only) (explain)
--Testcase 545:
EXPLAIN VERBOSE
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_min_all(*)), tag1
   Sort Key: (influx_min_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_min_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_min(*) (stub agg function and group by tag only) (result)
--Testcase 546:
SELECT influx_min_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_min_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_min_all_sfunc(text) line 3 at RAISE
-- select influx_min(*) (stub agg function, expose data, explain)
--Testcase 547:
EXPLAIN VERBOSE
SELECT (influx_min_all(*)::s3).* from s3 ORDER BY 1;
                                                                                                                              QUERY PLAN                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_min_all(*))::s3)."time"), (((influx_min_all(*))::s3).tag1), (((influx_min_all(*))::s3).value1), (((influx_min_all(*))::s3).value2), (((influx_min_all(*))::s3).value3), (((influx_min_all(*))::s3).value4), (((influx_min_all(*))::s3).__spd_url)
   Sort Key: (((influx_min_all(*))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_min_all(*))::s3)."time", ((influx_min_all(*))::s3).tag1, ((influx_min_all(*))::s3).value1, ((influx_min_all(*))::s3).value2, ((influx_min_all(*))::s3).value3, ((influx_min_all(*))::s3).value4, ((influx_min_all(*))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_min(*) (stub agg function, expose data, result)
--Testcase 548:
SELECT (influx_min_all(*)::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_min_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_min_all_sfunc(text) line 3 at RAISE
-- select influx_min(regex) (stub function, explain)
--Testcase 549:
EXPLAIN VERBOSE
SELECT influx_min('/value[1,4]/') from s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_min('/value[1,4]/'::text))
   Sort Key: (influx_min('/value[1,4]/'::text))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_min('/value[1,4]/'::text)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_min(regex) (stub function, result)
--Testcase 550:
SELECT influx_min('/value[1,4]/') from s3 ORDER BY 1;
ERROR:  stub influx_min_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_min_sfunc(text,text) line 3 at RAISE
-- select influx_min(regex) (stub agg function and group by influx_time() and tag) (explain)
--Testcase 551:
EXPLAIN VERBOSE
SELECT influx_min('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_min('/^v.*/'::text)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_min('/^v.*/'::text))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_min('/^v.*/'::text), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_min(regex) (stub agg function and group by influx_time() and tag) (result)
--Testcase 552:
SELECT influx_min('/^v.*/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select influx_min(regex) (stub agg function and group by tag only) (explain)
--Testcase 553:
EXPLAIN VERBOSE
SELECT influx_min('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_min('/value[1,4]/'::text)), tag1
   Sort Key: (influx_min('/value[1,4]/'::text))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_min('/value[1,4]/'::text), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select influx_min(regex) (stub agg function and group by tag only) (result)
--Testcase 554:
SELECT influx_min('/value[1,4]/') FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_min_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_min_sfunc(text,text) line 3 at RAISE
-- select influx_min(regex) (stub agg function, expose data, explain)
--Testcase 555:
EXPLAIN VERBOSE
SELECT (influx_min('/value[1,4]/')::s3).* from s3 ORDER BY 1;
                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=12370.34..12370.34 rows=1 width=104)
   Output: (((influx_min('/value[1,4]/'::text))::s3)."time"), (((influx_min('/value[1,4]/'::text))::s3).tag1), (((influx_min('/value[1,4]/'::text))::s3).value1), (((influx_min('/value[1,4]/'::text))::s3).value2), (((influx_min('/value[1,4]/'::text))::s3).value3), (((influx_min('/value[1,4]/'::text))::s3).value4), (((influx_min('/value[1,4]/'::text))::s3).__spd_url)
   Sort Key: (((influx_min('/value[1,4]/'::text))::s3)."time")
   ->  Aggregate  (cost=12370.28..12370.33 rows=1 width=104)
         Output: ((influx_min('/value[1,4]/'::text))::s3)."time", ((influx_min('/value[1,4]/'::text))::s3).tag1, ((influx_min('/value[1,4]/'::text))::s3).value1, ((influx_min('/value[1,4]/'::text))::s3).value2, ((influx_min('/value[1,4]/'::text))::s3).value3, ((influx_min('/value[1,4]/'::text))::s3).value4, ((influx_min('/value[1,4]/'::text))::s3).__spd_url
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select influx_min(regex) (stub agg function, expose data, result)
--Testcase 556:
SELECT (influx_min('/value[1,4]/')::s3).* from s3 ORDER BY 1;
ERROR:  stub influx_min_sfunc(text, text) is called
CONTEXT:  PL/pgSQL function influx_min_sfunc(text,text) line 3 at RAISE
-- selector function percentile() (explain)
--Testcase 557:
EXPLAIN VERBOSE
SELECT percentile(value1, 50), percentile(value2, 60), percentile(value3, 25), percentile(value4, 33) FROM s3 ORDER BY 1;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (percentile(value1, 50)), (percentile(value2, 60)), (percentile(value3, 25)), (percentile(value4, 33))
   Sort Key: (percentile(s3.value1, 50))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (percentile(value1, 50)), (percentile(value2, 60)), (percentile(value3, 25)), (percentile(value4, 33))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile(value1, 50), public.percentile(value2, 60), public.percentile(value3, 25), public.percentile(value4, 33) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile(value1, 50), public.percentile(value2, 60), public.percentile(value3, 25), public.percentile(value4, 33) FROM public.s32influx
(9 rows)

-- selector function percentile() (result)
--Testcase 558:
SELECT * FROM (
SELECT percentile(value1, 50), percentile(value2, 60), percentile(value3, 25), percentile(value4, 33) FROM s3
) as t ORDER BY 1, 2, 3, 4;
 percentile | percentile | percentile | percentile 
------------+------------+------------+------------
        0.2 |        100 |       -0.3 |       -100
        2.2 |        200 |       -3.3 |       -200
(2 rows)

-- selector function percentile() (explain)
--Testcase 559:
EXPLAIN VERBOSE
SELECT percentile(value1, 1.5), percentile(value2, 6.7), percentile(value3, 20.5), percentile(value4, 75.2) FROM s3 ORDER BY 1, 2, 3, 4;
                                                                                                                         QUERY PLAN                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (percentile(value1, '1.5'::double precision)), (percentile(value2, '6.7'::double precision)), (percentile(value3, '20.5'::double precision)), (percentile(value4, '75.2'::double precision))
   Sort Key: (percentile(s3.value1, '1.5'::double precision)), (percentile(s3.value2, '6.7'::double precision)), (percentile(s3.value3, '20.5'::double precision)), (percentile(s3.value4, '75.2'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (percentile(value1, '1.5'::double precision)), (percentile(value2, '6.7'::double precision)), (percentile(value3, '20.5'::double precision)), (percentile(value4, '75.2'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile(value1, 1.5::double precision), public.percentile(value2, 6.7::double precision), public.percentile(value3, 20.5::double precision), public.percentile(value4, 75.2::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile(value1, 1.5::double precision), public.percentile(value2, 6.7::double precision), public.percentile(value3, 20.5::double precision), public.percentile(value4, 75.2::double precision) FROM public.s32influx
(9 rows)

-- selector function percentile() (result)
--Testcase 560:
SELECT percentile(value1, 1.5), percentile(value2, 6.7), percentile(value3, 20.5), percentile(value4, 75.2) FROM s3 ORDER BY 1, 2, 3, 4;
 percentile | percentile | percentile | percentile 
------------+------------+------------+------------
            |            |       -3.3 |       -200
            |            |       -0.3 |       -100
(2 rows)

-- select percentile(*, int) (stub function, explain)
--Testcase 561:
EXPLAIN VERBOSE
SELECT percentile_all(50) from s3 ORDER BY 1;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (percentile_all(50))
   Sort Key: (percentile_all(50))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (percentile_all(50))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile_all(50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile_all(50) FROM public.s32influx
(9 rows)

-- select percentile(*, int) (stub function, result)
--Testcase 562:
SELECT * FROM (
SELECT percentile_all(50) from s3
) as t ORDER BY 1;
                             percentile_all                             
------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.2,100,-0.2,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:00Z,,2.2,200,-2.2,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select percentile(*, float8) (stub function, explain)
--Testcase 563:
EXPLAIN VERBOSE
SELECT percentile_all(70.5) from s3 ORDER BY 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (percentile_all('70.5'::double precision))
   Sort Key: (percentile_all('70.5'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (percentile_all('70.5'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile_all(70.5::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile_all(70.5::double precision) FROM public.s32influx
(9 rows)

-- select percentile(*, float8) (stub function, result)
--Testcase 564:
SELECT percentile_all(70.5) from s3 ORDER BY 1;
                             percentile_all                             
------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.2,100,-0.2,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:00Z,,2.2,200,-2.2,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select percentile(*, int) (stub function and group by influx_time() and tag) (explain)
--Testcase 565:
EXPLAIN VERBOSE
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.49..349.57 rows=32 width=72)
   Output: (percentile_all(50)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (percentile_all(50))
   ->  Group  (cost=332.43..348.69 rows=32 width=72)
         Output: percentile_all(50), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select percentile(*, int) (stub function and group by influx_time() and tag) (result)
--Testcase 566:
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select percentile(*, float8) (stub function and group by influx_time() and tag) (explain)
--Testcase 567:
EXPLAIN VERBOSE
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.49..349.57 rows=32 width=72)
   Output: (percentile_all('70.5'::double precision)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (percentile_all('70.5'::double precision))
   ->  Group  (cost=332.43..348.69 rows=32 width=72)
         Output: percentile_all('70.5'::double precision), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select percentile(*, float8) (stub function and group by influx_time() and tag) (result)
--Testcase 568:
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select percentile(*, int) (stub function and group by tag only) (explain)
--Testcase 569:
EXPLAIN VERBOSE
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (percentile_all(50)), tag1
   Sort Key: (percentile_all(50))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (percentile_all(50)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.percentile_all(50), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.percentile_all(50), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select percentile(*, int) (stub function and group by tag only) (result)
--Testcase 570:
SELECT percentile_all(50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                             percentile_all                             
------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.2,100,-0.2,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:00Z,,1.1,200,-2.2,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select percentile(*, float8) (stub function and group by tag only) (explain)
--Testcase 571:
EXPLAIN VERBOSE
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                          QUERY PLAN                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (percentile_all('70.5'::double precision)), tag1
   Sort Key: (percentile_all('70.5'::double precision))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (percentile_all('70.5'::double precision)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.percentile_all(70.5::double precision), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.percentile_all(70.5::double precision), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select percentile(*, float8) (stub function and group by tag only) (result)
--Testcase 572:
SELECT percentile_all(70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                             percentile_all                             
------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.2,100,-0.2,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:00Z,,1.1,200,-2.2,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select percentile(*, int) (stub function, expose data, explain)
--Testcase 573:
EXPLAIN VERBOSE
SELECT (percentile_all(50)::s3).* from s3 ORDER BY 1, 2, 3, 4;
                                                                                                                                         QUERY PLAN                                                                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((percentile_all(50)))::s3)."time"), ((((percentile_all(50)))::s3).tag1), ((((percentile_all(50)))::s3).value1), ((((percentile_all(50)))::s3).value2), ((((percentile_all(50)))::s3).value3), ((((percentile_all(50)))::s3).value4), ((((percentile_all(50)))::s3).__spd_url)
   Sort Key: ((((percentile_all(50)))::s3)."time"), ((((percentile_all(50)))::s3).tag1), ((((percentile_all(50)))::s3).value1), ((((percentile_all(50)))::s3).value2)
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((percentile_all(50)))::s3)."time", (((percentile_all(50)))::s3).tag1, (((percentile_all(50)))::s3).value1, (((percentile_all(50)))::s3).value2, (((percentile_all(50)))::s3).value3, (((percentile_all(50)))::s3).value4, (((percentile_all(50)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile_all(50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile_all(50) FROM public.s32influx
(9 rows)

-- select percentile(*, int) (stub function, expose data, result)
--Testcase 574:
SELECT * FROM (
SELECT (percentile_all(50)::s3).* from s3
) as t ORDER BY 1, 2, 3, 4;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.2 |    100 |   -0.2 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:00+09 |      |    2.2 |    200 |   -2.2 |   -200 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- select percentile(*, int) (stub function, expose data, explain)
--Testcase 575:
EXPLAIN VERBOSE
SELECT (percentile_all(70.5)::s3).* from s3 ORDER BY 1, 2, 3, 4;
                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((percentile_all('70.5'::double precision)))::s3)."time"), ((((percentile_all('70.5'::double precision)))::s3).tag1), ((((percentile_all('70.5'::double precision)))::s3).value1), ((((percentile_all('70.5'::double precision)))::s3).value2), ((((percentile_all('70.5'::double precision)))::s3).value3), ((((percentile_all('70.5'::double precision)))::s3).value4), ((((percentile_all('70.5'::double precision)))::s3).__spd_url)
   Sort Key: ((((percentile_all('70.5'::double precision)))::s3)."time"), ((((percentile_all('70.5'::double precision)))::s3).tag1), ((((percentile_all('70.5'::double precision)))::s3).value1), ((((percentile_all('70.5'::double precision)))::s3).value2)
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((percentile_all('70.5'::double precision)))::s3)."time", (((percentile_all('70.5'::double precision)))::s3).tag1, (((percentile_all('70.5'::double precision)))::s3).value1, (((percentile_all('70.5'::double precision)))::s3).value2, (((percentile_all('70.5'::double precision)))::s3).value3, (((percentile_all('70.5'::double precision)))::s3).value4, (((percentile_all('70.5'::double precision)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile_all(70.5::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile_all(70.5::double precision) FROM public.s32influx
(9 rows)

-- select percentile(*, int) (stub function, expose data, result)
--Testcase 576:
SELECT * FROM (
SELECT (percentile_all(70.5)::s3).* from s3
) as t ORDER BY 1, 2, 3, 4;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.2 |    100 |   -0.2 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:00+09 |      |    2.2 |    200 |   -2.2 |   -200 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- select percentile(regex) (stub function, explain)
--Testcase 577:
EXPLAIN VERBOSE
SELECT percentile('/value[1,4]/', 50) from s3 ORDER BY 1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (percentile('/value[1,4]/'::text, 50))
   Sort Key: (percentile('/value[1,4]/'::text, 50))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (percentile('/value[1,4]/'::text, 50))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 50) FROM public.s32influx
(9 rows)

-- select percentile(regex) (stub function, result)
--Testcase 578:
SELECT percentile('/value[1,4]/', 50) from s3 ORDER BY 1;
                           percentile                            
-----------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.2,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:00Z,,2.2,,,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select percentile(regex) (stub function and group by influx_time() and tag) (explain)
--Testcase 579:
EXPLAIN VERBOSE
SELECT percentile('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.49..349.57 rows=32 width=72)
   Output: (percentile('/^v.*/'::text, 50)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (percentile('/^v.*/'::text, 50))
   ->  Group  (cost=332.43..348.69 rows=32 width=72)
         Output: percentile('/^v.*/'::text, 50), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select percentile(regex) (stub function and group by influx_time() and tag) (result)
--Testcase 580:
SELECT percentile('/^v.*/', 50) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select percentile(regex) (stub function and group by tag only) (explain)
--Testcase 581:
EXPLAIN VERBOSE
SELECT percentile('/value[1,4]/', 70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                                   QUERY PLAN                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (percentile('/value[1,4]/'::text, '70.5'::double precision)), tag1
   Sort Key: (percentile('/value[1,4]/'::text, '70.5'::double precision))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (percentile('/value[1,4]/'::text, '70.5'::double precision)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 70.5::double precision), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 70.5::double precision), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select percentile(regex) (stub function and group by tag only) (result)
--Testcase 582:
SELECT percentile('/value[1,4]/', 70.5) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                           percentile                            
-----------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.2,,,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:00Z,,1.1,,,-200,/pgspider_svr2/influxdb_svr/)
(2 rows)

-- select percentile(regex) (stub function, expose data, explain)
--Testcase 583:
EXPLAIN VERBOSE
SELECT (percentile('/value[1,4]/', 50)::s3).* from s3 ORDER BY 1, 2, 3, 4;
                                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((percentile('/value[1,4]/'::text, 50)))::s3)."time"), ((((percentile('/value[1,4]/'::text, 50)))::s3).tag1), ((((percentile('/value[1,4]/'::text, 50)))::s3).value1), ((((percentile('/value[1,4]/'::text, 50)))::s3).value2), ((((percentile('/value[1,4]/'::text, 50)))::s3).value3), ((((percentile('/value[1,4]/'::text, 50)))::s3).value4), ((((percentile('/value[1,4]/'::text, 50)))::s3).__spd_url)
   Sort Key: ((((percentile('/value[1,4]/'::text, 50)))::s3)."time"), ((((percentile('/value[1,4]/'::text, 50)))::s3).tag1), ((((percentile('/value[1,4]/'::text, 50)))::s3).value1), ((((percentile('/value[1,4]/'::text, 50)))::s3).value2)
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((percentile('/value[1,4]/'::text, 50)))::s3)."time", (((percentile('/value[1,4]/'::text, 50)))::s3).tag1, (((percentile('/value[1,4]/'::text, 50)))::s3).value1, (((percentile('/value[1,4]/'::text, 50)))::s3).value2, (((percentile('/value[1,4]/'::text, 50)))::s3).value3, (((percentile('/value[1,4]/'::text, 50)))::s3).value4, (((percentile('/value[1,4]/'::text, 50)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 50) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 50) FROM public.s32influx
(9 rows)

-- select percentile(regex) (stub function, expose data, result)
--Testcase 584:
SELECT * FROM (
SELECT (percentile('/value[1,4]/', 50)::s3).* from s3
) as t ORDER BY 1, 2, 3, 4;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.2 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:00+09 |      |    2.2 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- select percentile(regex) (stub function, expose data, explain)
--Testcase 585:
EXPLAIN VERBOSE
SELECT (percentile('/value[1,4]/', 70.5)::s3).* from s3 ORDER BY 1, 2, 3, 4;
                                                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3)."time"), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).tag1), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value1), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value2), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value3), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value4), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).__spd_url)
   Sort Key: ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3)."time"), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).tag1), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value1), ((((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value2)
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3)."time", (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).tag1, (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value1, (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value2, (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value3, (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).value4, (((percentile('/value[1,4]/'::text, '70.5'::double precision)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 70.5::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.percentile('/value[1,4]/'::text, 70.5::double precision) FROM public.s32influx
(9 rows)

-- select percentile(regex) (stub function, expose data, result)
--Testcase 586:
SELECT * FROM (
SELECT (percentile('/value[1,4]/', 70.5)::s3).* from s3
) as t ORDER BY 1, 2, 3, 4;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |    0.2 |        |        |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:00+09 |      |    2.2 |        |        |   -200 | /pgspider_svr2/influxdb_svr/
(2 rows)

-- selector function top(field_key,N) (explain)
--Testcase 587:
EXPLAIN VERBOSE
SELECT top(value1, 1) FROM s3 ORDER BY 1;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=8)
   Output: (top(value1, 1))
   Sort Key: (top(s3.value1, 1))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=8)
         Output: (top(value1, 1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.top(value1, 1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.top(value1, 1) FROM public.s32influx
(9 rows)

-- selector function top(field_key,N) (result)
--Testcase 588:
SELECT top(value1, 1) FROM s3 ORDER BY 1;
 top 
-----
 0.3
 3.3
(2 rows)

-- selector function top(field_key,tag_key(s),N) (explain)
--Testcase 589:
EXPLAIN VERBOSE
SELECT top(value1, tag1, 1) FROM s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=8)
   Output: (top(value1, tag1, 1))
   Sort Key: (top(s3.value1, s3.tag1, 1))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=8)
         Output: (top(value1, tag1, 1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.top(value1, tag1, 1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.top(value1, tag1, 1) FROM public.s32influx
(9 rows)

-- selector function top(field_key,tag_key(s),N) (result)
--Testcase 590:
SELECT top(value1, tag1, 1) FROM s3 ORDER BY 1;
 top 
-----
 0.3
 3.3
(2 rows)

-- selector function top() cannot be combined with other functions(explain)
--Testcase 591:
EXPLAIN VERBOSE
SELECT top(value1, 1), top(value2, 1), top(value3, 1), top(value4, 1) FROM s3 ORDER BY 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=7685.49..7702.55 rows=6826 width=32)
   Output: (top(value1, 1)), (top(value2, 1)), (top(value3, 1)), (top(value4, 1))
   Sort Key: (top(s3.value1, 1))
   ->  Foreign Scan on public.s3  (cost=200.00..7250.78 rows=6826 width=32)
         Output: (top(value1, 1)), (top(value2, 1)), (top(value3, 1)), (top(value4, 1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.top(value1, 1), public.top(value2, 1), public.top(value3, 1), public.top(value4, 1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.top(value1, 1), public.top(value2, 1), public.top(value3, 1), public.top(value4, 1) FROM public.s32influx
(9 rows)

-- selector function top() cannot be combined with other functions(result)
--SELECT top(value1, 1), top(value2, 1), top(value3, 1), top(value4, 1) FROM s3 ORDER BY 1;
-- select acos (builtin function, explain)
--Testcase 592:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM s3 ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (acos(value1)), (acos((value2)::double precision)), (acos(value3)), (acos((value4)::double precision))
   Sort Key: (acos(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (acos(value1)), (acos((value2)::double precision)), (acos(value3)), (acos((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM public.s32influx
(9 rows)

-- select acos (builtin function, result)
--Testcase 593:
SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM s3 ORDER BY 1;
        acos        | acos |        acos        | acos 
--------------------+------+--------------------+------
  1.266103672779499 |      | 1.8754889808102941 |     
 1.3694384060045657 |      | 1.7721542475852274 |     
 1.4706289056333368 |      | 1.6709637479564563 |     
                    |      |                    |     
                    |      |                    |     
                    |      |                    |     
(6 rows)

-- select acos (builtin function, not pushdown constraints, explain)
--Testcase 594:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM s3 WHERE to_hex(value2) = '64' ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=459.76..459.85 rows=34 width=32)
   Output: (acos(value1)), (acos((value2)::double precision)), (acos(value3)), (acos((value4)::double precision))
   Sort Key: (acos(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..458.90 rows=34 width=32)
         Output: (acos(value1)), (acos((value2)::double precision)), (acos(value3)), (acos((value4)::double precision))
         Filter: ((to_hex(s3.value2) = '64'::text) AND (to_hex(s3.value2) = '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT acos(value1), acos(value2), acos(value3), acos(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT acos(value1), acos(value2), acos(value3), acos(value4), value2 FROM public.s32influx
(10 rows)

-- select acos (builtin function, not pushdown constraints, result)
--Testcase 595:
SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM s3 WHERE to_hex(value2) = '64' ORDER BY 1;
        acos        | acos |        acos        | acos 
--------------------+------+--------------------+------
  1.266103672779499 |      | 1.8754889808102941 |     
 1.3694384060045657 |      | 1.7721542475852274 |     
 1.4706289056333368 |      | 1.6709637479564563 |     
(3 rows)

-- select acos (builtin function, pushdown constraints, explain)
--Testcase 596:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (acos(value1)), (acos((value2)::double precision)), (acos(value3)), (acos((value4)::double precision))
   Sort Key: (acos(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (acos(value1)), (acos((value2)::double precision)), (acos(value3)), (acos((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select acos (builtin function, pushdown constraints, result)
--Testcase 597:
SELECT acos(value1), acos(value2), acos(value3), acos(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
        acos        | acos |        acos        | acos 
--------------------+------+--------------------+------
  1.266103672779499 |      | 1.8754889808102941 |     
 1.3694384060045657 |      | 1.7721542475852274 |     
 1.4706289056333368 |      | 1.6709637479564563 |     
(3 rows)

-- select acos as nest function with agg (pushdown, explain)
--Testcase 598:
EXPLAIN VERBOSE
SELECT sum(value3),acos(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (acos((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), acos((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select acos as nest function with agg (pushdown, result)
--Testcase 599:
SELECT sum(value3),acos(sum(value3)) FROM s3 ORDER BY 1;
ERROR:  input is out of range
-- select acos as nest with log2 (pushdown, explain)
--Testcase 600:
EXPLAIN VERBOSE
SELECT acos(log2(value1)),acos(log2(1/value1)) FROM s3;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (acos(log2(value1))), (acos(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT acos(public.log2(value1)), acos(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT acos(public.log2(value1)), acos(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select acos as nest with log2 (pushdown, result)
--Testcase 601:
SELECT * FROM (
SELECT acos(log2(value1)),acos(log2(1/value1)) FROM s3
) as t ORDER BY 1, 2;
        acos        |        acos        
--------------------+--------------------
 1.4328557728353513 | 1.7087368807544419
                    |                   
                    |                   
                    |                   
                    |                   
                    |                   
(6 rows)

-- select acos with non pushdown func and explicit constant (explain)
--Testcase 602:
EXPLAIN VERBOSE
SELECT acos(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (acos(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (acos(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (acos(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT acos(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT acos(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select acos with non pushdown func and explicit constant (result)
--Testcase 603:
SELECT * FROM (
SELECT acos(value3), pi(), 4.1 FROM s3
) as t ORDER BY 1;
        acos        |        pi         | ?column? 
--------------------+-------------------+----------
 1.6709637479564563 | 3.141592653589793 |      4.1
 1.7721542475852274 | 3.141592653589793 |      4.1
 1.8754889808102941 | 3.141592653589793 |      4.1
                    | 3.141592653589793 |      4.1
                    | 3.141592653589793 |      4.1
                    | 3.141592653589793 |      4.1
(6 rows)

-- select acos with order by (explain)
--Testcase 604:
EXPLAIN VERBOSE
SELECT value1, acos(1-value1) FROM s3 ORDER BY acos(1-value1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (acos(('1'::double precision - value1)))
   Sort Key: (acos(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (acos(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, acos((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, acos((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select acos with order by (result)
--Testcase 605:
SELECT value1, acos(1-value1) FROM s3 ORDER BY acos(1-value1);
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681179626236
    0.2 |  0.6435011087932843
    0.3 |  0.7953988301841436
    1.1 |  1.6709637479564565
    2.2 |                    
    3.3 |                    
(6 rows)

-- select acos with order by index (result)
--Testcase 606:
SELECT value1, acos(1-value1) FROM s3 ORDER BY 2,1;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681179626236
    0.2 |  0.6435011087932843
    0.3 |  0.7953988301841436
    1.1 |  1.6709637479564565
    2.2 |                    
    3.3 |                    
(6 rows)

-- select acos with order by index (result)
--Testcase 607:
SELECT value1, acos(1-value1) FROM s3 ORDER BY 1,2;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681179626236
    0.2 |  0.6435011087932843
    0.3 |  0.7953988301841436
    1.1 |  1.6709637479564565
    2.2 |                    
    3.3 |                    
(6 rows)

-- select acos and as
--Testcase 608:
SELECT acos(value3) as acos1 FROM s3 ORDER BY 1;
       acos1        
--------------------
 1.6709637479564563
 1.7721542475852274
 1.8754889808102941
                   
                   
                   
(6 rows)

-- select acos(*) (stub function, explain)
--Testcase 609:
EXPLAIN VERBOSE
SELECT acos_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (acos_all())
   Sort Key: (acos_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (acos_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.acos_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.acos_all() FROM public.s32influx
(9 rows)

-- select acos(*) (stub function, result)
--Testcase 610:
SELECT * FROM (
SELECT acos_all() from s3
) as t ORDER BY 1;
                                           acos_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,1.4706289056333368,,1.6709637479564563,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,1.3694384060045657,,1.7721542475852274,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1.266103672779499,,1.8754889808102941,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,,,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,,,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,,,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select acos(*) (stub function and group by tag only) (explain)
--Testcase 611:
EXPLAIN VERBOSE
SELECT acos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (acos_all()), tag1
   Sort Key: (acos_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (acos_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.acos_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.acos_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select acos(*) (stub function and group by tag only) (result)
--Testcase 612:
SELECT acos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                           acos_all                                           
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,1.4706289056333368,,1.6709637479564563,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,1.3694384060045657,,1.7721542475852274,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1.266103672779499,,1.8754889808102941,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,,,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,,,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select acos(*) (stub function, expose data, explain)
--Testcase 613:
EXPLAIN VERBOSE
SELECT (acos_all()::s3).* from s3 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((acos_all()))::s3)."time"), ((((acos_all()))::s3).tag1), ((((acos_all()))::s3).value1), ((((acos_all()))::s3).value2), ((((acos_all()))::s3).value3), ((((acos_all()))::s3).value4), ((((acos_all()))::s3).__spd_url)
   Sort Key: ((((acos_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((acos_all()))::s3)."time", (((acos_all()))::s3).tag1, (((acos_all()))::s3).value1, (((acos_all()))::s3).value2, (((acos_all()))::s3).value3, (((acos_all()))::s3).value4, (((acos_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.acos_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.acos_all() FROM public.s32influx
(9 rows)

-- select acos(*) (stub function, expose data, result)
--Testcase 614:
SELECT * FROM (
SELECT (acos_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1       | value2 |       value3       | value4 |          __spd_url           
------------------------+------+--------------------+--------+--------------------+--------+------------------------------
 1970-01-01 09:00:00+09 |      | 1.4706289056333368 |        | 1.6709637479564563 |        | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      | 1.3694384060045657 |        | 1.7721542475852274 |        | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |  1.266103672779499 |        | 1.8754889808102941 |        | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |                    |        |                    |        | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                    |        |                    |        | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |                    |        |                    |        | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select asin (builtin function, explain)
--Testcase 615:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM s3 ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (asin(value1)), (asin((value2)::double precision)), (asin(value3)), (asin((value4)::double precision))
   Sort Key: (asin(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (asin(value1)), (asin((value2)::double precision)), (asin(value3)), (asin((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM public.s32influx
(9 rows)

-- select asin (builtin function, result)
--Testcase 616:
SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM s3 ORDER BY 1;
        asin         | asin |         asin         | asin 
---------------------+------+----------------------+------
  0.1001674211615598 |      |  -0.1001674211615598 |     
 0.20135792079033082 |      | -0.20135792079033082 |     
  0.3046926540153975 |      |  -0.3046926540153975 |     
                     |      |                      |     
                     |      |                      |     
                     |      |                      |     
(6 rows)

-- select asin (builtin function, not pushdown constraints, explain)
--Testcase 617:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM s3 WHERE to_hex(value2) = '64' ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=459.76..459.85 rows=34 width=32)
   Output: (asin(value1)), (asin((value2)::double precision)), (asin(value3)), (asin((value4)::double precision))
   Sort Key: (asin(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..458.90 rows=34 width=32)
         Output: (asin(value1)), (asin((value2)::double precision)), (asin(value3)), (asin((value4)::double precision))
         Filter: ((to_hex(s3.value2) = '64'::text) AND (to_hex(s3.value2) = '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT asin(value1), asin(value2), asin(value3), asin(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT asin(value1), asin(value2), asin(value3), asin(value4), value2 FROM public.s32influx
(10 rows)

-- select asin (builtin function, not pushdown constraints, result)
--Testcase 618:
SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM s3 WHERE to_hex(value2) = '64' ORDER BY 1;
        asin         | asin |         asin         | asin 
---------------------+------+----------------------+------
  0.1001674211615598 |      |  -0.1001674211615598 |     
 0.20135792079033082 |      | -0.20135792079033082 |     
  0.3046926540153975 |      |  -0.3046926540153975 |     
(3 rows)

-- select asin (builtin function, pushdown constraints, explain)
--Testcase 619:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (asin(value1)), (asin((value2)::double precision)), (asin(value3)), (asin((value4)::double precision))
   Sort Key: (asin(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (asin(value1)), (asin((value2)::double precision)), (asin(value3)), (asin((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select asin (builtin function, pushdown constraints, result)
--Testcase 620:
SELECT asin(value1), asin(value2), asin(value3), asin(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
        asin         | asin |         asin         | asin 
---------------------+------+----------------------+------
  0.1001674211615598 |      |  -0.1001674211615598 |     
 0.20135792079033082 |      | -0.20135792079033082 |     
  0.3046926540153975 |      |  -0.3046926540153975 |     
(3 rows)

-- select asin as nest function with agg (pushdown, explain)
--Testcase 621:
EXPLAIN VERBOSE
SELECT sum(value3),asin(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (asin((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), asin((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select asin as nest function with agg (pushdown, result)
--Testcase 622:
SELECT sum(value3),asin(sum(value3)) FROM s3 ORDER BY 1;
ERROR:  input is out of range
-- select asin as nest with log2 (pushdown, explain)
--Testcase 623:
EXPLAIN VERBOSE
SELECT asin(log2(value1)),asin(log2(1/value1)) FROM s3;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (asin(log2(value1))), (asin(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT asin(public.log2(value1)), asin(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT asin(public.log2(value1)), asin(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select asin as nest with log2 (pushdown, result)
--Testcase 624:
SELECT * FROM (
SELECT asin(log2(value1)),asin(log2(1/value1)) FROM s3
) as t ORDER BY 1;
        asin         |         asin         
---------------------+----------------------
 0.13794055395954533 | -0.13794055395954527
                     |                     
                     |                     
                     |                     
                     |                     
                     |                     
(6 rows)

-- select asin with non pushdown func and explicit constant (explain)
--Testcase 625:
EXPLAIN VERBOSE
SELECT asin(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (asin(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (asin(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (asin(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT asin(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT asin(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select asin with non pushdown func and explicit constant (result)
--Testcase 626:
SELECT asin(value3), pi(), 4.1 FROM s3 ORDER BY 1;
         asin         |        pi         | ?column? 
----------------------+-------------------+----------
  -0.3046926540153975 | 3.141592653589793 |      4.1
 -0.20135792079033082 | 3.141592653589793 |      4.1
  -0.1001674211615598 | 3.141592653589793 |      4.1
                      | 3.141592653589793 |      4.1
                      | 3.141592653589793 |      4.1
                      | 3.141592653589793 |      4.1
(6 rows)

-- select asin with order by (explain)
--Testcase 627:
EXPLAIN VERBOSE
SELECT value1, asin(1-value1) FROM s3 ORDER BY asin(1-value1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (asin(('1'::double precision - value1)))
   Sort Key: (asin(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (asin(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, asin((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, asin((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select asin with order by (result)
--Testcase 628:
SELECT value1, asin(1-value1) FROM s3 ORDER BY asin(1-value1);
 value1 |         asin         
--------+----------------------
    1.1 | -0.10016742116155988
    0.3 |    0.775397496610753
    0.2 |   0.9272952180016123
    0.1 |   1.1197695149986342
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin with order by index (result)
--Testcase 629:
SELECT value1, asin(1-value1) FROM s3 ORDER BY 2,1;
 value1 |         asin         
--------+----------------------
    1.1 | -0.10016742116155988
    0.3 |    0.775397496610753
    0.2 |   0.9272952180016123
    0.1 |   1.1197695149986342
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin with order by index (result)
--Testcase 630:
SELECT value1, asin(1-value1) FROM s3 ORDER BY 1,2;
 value1 |         asin         
--------+----------------------
    0.1 |   1.1197695149986342
    0.2 |   0.9272952180016123
    0.3 |    0.775397496610753
    1.1 | -0.10016742116155988
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin and as
--Testcase 631:
SELECT asin(value3) as asin1 FROM s3 ORDER BY 1;
        asin1         
----------------------
  -0.3046926540153975
 -0.20135792079033082
  -0.1001674211615598
                     
                     
                     
(6 rows)

-- select asin(*) (stub function, explain)
--Testcase 632:
EXPLAIN VERBOSE
SELECT asin_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (asin_all())
   Sort Key: (asin_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (asin_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.asin_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.asin_all() FROM public.s32influx
(9 rows)

-- select asin(*) (stub function, result)
--Testcase 633:
SELECT * FROM (
SELECT asin_all() from s3
) as t ORDER BY 1;
                                            asin_all                                             
-------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1001674211615598,,-0.1001674211615598,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.20135792079033082,,-0.20135792079033082,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.3046926540153975,,-0.3046926540153975,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,,,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,,,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,,,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select asin(*) (stub function and group by tag only) (explain)
--Testcase 634:
EXPLAIN VERBOSE
SELECT asin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (asin_all()), tag1
   Sort Key: (asin_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (asin_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.asin_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.asin_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select asin(*) (stub function and group by tag only) (result)
--Testcase 635:
SELECT asin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                            asin_all                                             
-------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.1001674211615598,,-0.1001674211615598,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.20135792079033082,,-0.20135792079033082,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.3046926540153975,,-0.3046926540153975,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,,,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,,,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select asin(*) (stub function, expose data, explain)
--Testcase 636:
EXPLAIN VERBOSE
SELECT (asin_all()::s3).* from s3 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((asin_all()))::s3)."time"), ((((asin_all()))::s3).tag1), ((((asin_all()))::s3).value1), ((((asin_all()))::s3).value2), ((((asin_all()))::s3).value3), ((((asin_all()))::s3).value4), ((((asin_all()))::s3).__spd_url)
   Sort Key: ((((asin_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((asin_all()))::s3)."time", (((asin_all()))::s3).tag1, (((asin_all()))::s3).value1, (((asin_all()))::s3).value2, (((asin_all()))::s3).value3, (((asin_all()))::s3).value4, (((asin_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.asin_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.asin_all() FROM public.s32influx
(9 rows)

-- select asin(*) (stub function, expose data, result)
--Testcase 637:
SELECT * FROM (
SELECT (asin_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |       value1        | value2 |        value3        | value4 |          __spd_url           
------------------------+------+---------------------+--------+----------------------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |  0.1001674211615598 |        |  -0.1001674211615598 |        | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      | 0.20135792079033082 |        | -0.20135792079033082 |        | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |  0.3046926540153975 |        |  -0.3046926540153975 |        | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |                     |        |                      |        | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |                     |        |                      |        | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |                     |        |                      |        | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select atan (builtin function, explain)
--Testcase 638:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM s3 ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (atan(value1)), (atan((value2)::double precision)), (atan(value3)), (atan((value4)::double precision))
   Sort Key: (atan(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (atan(value1)), (atan((value2)::double precision)), (atan(value3)), (atan((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM public.s32influx
(9 rows)

-- select atan (builtin function, result)
--Testcase 639:
SELECT * FROM (
SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM s3
) as t ORDER BY 1;
        atan         |        atan        |         atan         |        atan         
---------------------+--------------------+----------------------+---------------------
 0.09966865249116204 | 1.5607966601082313 | -0.09966865249116204 | -1.5607966601082313
 0.19739555984988078 | 1.5607966601082313 | -0.19739555984988078 | -1.5607966601082313
  0.2914567944778671 | 1.5607966601082313 |  -0.2914567944778671 | -1.5607966601082313
  0.8329812666744317 | 1.5657963684609382 |  -0.8329812666744317 | -1.5657963684609382
  1.1441688336680205 | 1.5657963684609382 |  -1.1441688336680205 | -1.5657963684609382
  1.2765617616837088 | 1.5657963684609382 |  -1.2765617616837088 | -1.5657963684609382
(6 rows)

-- select atan (builtin function, not pushdown constraints, explain)
--Testcase 640:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (atan(value1)), (atan((value2)::double precision)), (atan(value3)), (atan((value4)::double precision))
   Sort Key: (atan(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (atan(value1)), (atan((value2)::double precision)), (atan(value3)), (atan((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan(value1), atan(value2), atan(value3), atan(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan(value1), atan(value2), atan(value3), atan(value4), value2 FROM public.s32influx
(10 rows)

-- select atan (builtin function, not pushdown constraints, result)
--Testcase 641:
SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
        atan        |        atan        |        atan         |        atan         
--------------------+--------------------+---------------------+---------------------
 0.8329812666744317 | 1.5657963684609382 | -0.8329812666744317 | -1.5657963684609382
 1.1441688336680205 | 1.5657963684609382 | -1.1441688336680205 | -1.5657963684609382
 1.2765617616837088 | 1.5657963684609382 | -1.2765617616837088 | -1.5657963684609382
(3 rows)

-- select atan (builtin function, pushdown constraints, explain)
--Testcase 642:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (atan(value1)), (atan((value2)::double precision)), (atan(value3)), (atan((value4)::double precision))
   Sort Key: (atan(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (atan(value1)), (atan((value2)::double precision)), (atan(value3)), (atan((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select atan (builtin function, pushdown constraints, result)
--Testcase 643:
SELECT atan(value1), atan(value2), atan(value3), atan(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
        atan         |        atan        |         atan         |        atan         
---------------------+--------------------+----------------------+---------------------
 0.09966865249116204 | 1.5607966601082313 | -0.09966865249116204 | -1.5607966601082313
 0.19739555984988078 | 1.5607966601082313 | -0.19739555984988078 | -1.5607966601082313
  0.2914567944778671 | 1.5607966601082313 |  -0.2914567944778671 | -1.5607966601082313
(3 rows)

-- select atan as nest function with agg (pushdown, explain)
--Testcase 644:
EXPLAIN VERBOSE
SELECT sum(value3),atan(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (atan((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), atan((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select atan as nest function with agg (pushdown, result)
--Testcase 645:
SELECT sum(value3),atan(sum(value3)) FROM s3 ORDER BY 1;
        sum         |        atan         
--------------------+---------------------
 -7.199999999999999 | -1.4327903031373772
(1 row)

-- select atan as nest with log2 (pushdown, explain)
--Testcase 646:
EXPLAIN VERBOSE
SELECT atan(log2(value1)),atan(log2(1/value1)) FROM s3;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (atan(log2(value1))), (atan(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT atan(public.log2(value1)), atan(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT atan(public.log2(value1)), atan(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select atan as nest with log2 (pushdown, result)
--Testcase 647:
SELECT * FROM (
SELECT atan(log2(value1)),atan(log2(1/value1)) FROM s3
) as t ORDER BY 1;
        atan         |         atan         
---------------------+----------------------
  -1.278394850250925 |    1.278394850250925
 -1.1641274254270142 |   1.1641274254270142
 -1.0484236379153637 |   1.0484236379153637
 0.13664662085466017 | -0.13664662085466012
  0.8496386749711663 |  -0.8496386749711662
   1.044791373608735 |   -1.044791373608735
(6 rows)

-- select atan with non pushdown func and explicit constant (explain)
--Testcase 648:
EXPLAIN VERBOSE
SELECT atan(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (atan(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (atan(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (atan(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select atan with non pushdown func and explicit constant (result)
--Testcase 649:
SELECT atan(value3), pi(), 4.1 FROM s3 ORDER BY 1;
         atan         |        pi         | ?column? 
----------------------+-------------------+----------
  -1.2765617616837088 | 3.141592653589793 |      4.1
  -1.1441688336680205 | 3.141592653589793 |      4.1
  -0.8329812666744317 | 3.141592653589793 |      4.1
  -0.2914567944778671 | 3.141592653589793 |      4.1
 -0.19739555984988078 | 3.141592653589793 |      4.1
 -0.09966865249116204 | 3.141592653589793 |      4.1
(6 rows)

-- select atan with order by (explain)
--Testcase 650:
EXPLAIN VERBOSE
SELECT value1, atan(1-value1) FROM s3 ORDER BY atan(1-value1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (atan(('1'::double precision - value1)))
   Sort Key: (atan(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (atan(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, atan((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, atan((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select atan with order by (result)
--Testcase 651:
SELECT value1, atan(1-value1) FROM s3 ORDER BY atan(1-value1);
 value1 |         atan         
--------+----------------------
    3.3 |  -1.1606689862534056
    2.2 |  -0.8760580505981934
    1.1 | -0.09966865249116212
    0.3 |   0.6107259643892086
    0.2 |   0.6747409422235526
    0.1 |   0.7328151017865066
(6 rows)

-- select atan with order by index (result)
--Testcase 652:
SELECT value1, atan(1-value1) FROM s3 ORDER BY 2,1;
 value1 |         atan         
--------+----------------------
    3.3 |  -1.1606689862534056
    2.2 |  -0.8760580505981934
    1.1 | -0.09966865249116212
    0.3 |   0.6107259643892086
    0.2 |   0.6747409422235526
    0.1 |   0.7328151017865066
(6 rows)

-- select atan with order by index (result)
--Testcase 653:
SELECT value1, atan(1-value1) FROM s3 ORDER BY 1,2;
 value1 |         atan         
--------+----------------------
    0.1 |   0.7328151017865066
    0.2 |   0.6747409422235526
    0.3 |   0.6107259643892086
    1.1 | -0.09966865249116212
    2.2 |  -0.8760580505981934
    3.3 |  -1.1606689862534056
(6 rows)

-- select atan and as
--Testcase 654:
SELECT * FROM (
SELECT atan(value3) as atan1 FROM s3
) as t ORDER BY 1;
        atan1         
----------------------
  -1.2765617616837088
  -1.1441688336680205
  -0.8329812666744317
  -0.2914567944778671
 -0.19739555984988078
 -0.09966865249116204
(6 rows)

-- select atan(*) (stub function, explain)
--Testcase 655:
EXPLAIN VERBOSE
SELECT atan_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (atan_all())
   Sort Key: (atan_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (atan_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.atan_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.atan_all() FROM public.s32influx
(9 rows)

-- select atan(*) (stub function, result)
--Testcase 656:
SELECT * FROM (
SELECT atan_all() from s3
) as t ORDER BY 1;
                                                               atan_all                                                               
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.09966865249116204,1.5607966601082313,-0.09966865249116204,-1.5607966601082313,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.19739555984988078,1.5607966601082313,-0.19739555984988078,-1.5607966601082313,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.2914567944778671,1.5607966601082313,-0.2914567944778671,-1.5607966601082313,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.8329812666744317,1.5657963684609382,-0.8329812666744317,-1.5657963684609382,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1441688336680205,1.5657963684609382,-1.1441688336680205,-1.5657963684609382,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.2765617616837088,1.5657963684609382,-1.2765617616837088,-1.5657963684609382,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select atan(*) (stub function and group by tag only) (explain)
--Testcase 657:
EXPLAIN VERBOSE
SELECT atan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (atan_all()), tag1
   Sort Key: (atan_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (atan_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.atan_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.atan_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select atan(*) (stub function and group by tag only) (result)
--Testcase 658:
SELECT atan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                               atan_all                                                               
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.09966865249116204,1.5607966601082313,-0.09966865249116204,-1.5607966601082313,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.19739555984988078,1.5607966601082313,-0.19739555984988078,-1.5607966601082313,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.2914567944778671,1.5607966601082313,-0.2914567944778671,-1.5607966601082313,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.8329812666744317,1.5657963684609382,-0.8329812666744317,-1.5657963684609382,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,1.1441688336680205,1.5657963684609382,-1.1441688336680205,-1.5657963684609382,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select atan(*) (stub function, expose data, explain)
--Testcase 659:
EXPLAIN VERBOSE
SELECT (atan_all()::s3).* from s3 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((atan_all()))::s3)."time"), ((((atan_all()))::s3).tag1), ((((atan_all()))::s3).value1), ((((atan_all()))::s3).value2), ((((atan_all()))::s3).value3), ((((atan_all()))::s3).value4), ((((atan_all()))::s3).__spd_url)
   Sort Key: ((((atan_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((atan_all()))::s3)."time", (((atan_all()))::s3).tag1, (((atan_all()))::s3).value1, (((atan_all()))::s3).value2, (((atan_all()))::s3).value3, (((atan_all()))::s3).value4, (((atan_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.atan_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.atan_all() FROM public.s32influx
(9 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--SELECT asin_all(), acos_all(), atan_all() FROM s3 ORDER BY 1;
-- select atan2 (builtin function, explain)
--Testcase 660:
EXPLAIN VERBOSE
SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM s3 ORDER BY 1;
                                                                                             QUERY PLAN                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=996.01..1013.07 rows=6826 width=32)
   Output: (atan2(value1, (value2)::double precision)), (atan2((value2)::double precision, value3)), (atan2(value3, (value4)::double precision)), (atan2((value4)::double precision, value1))
   Sort Key: (atan2(s3.value1, (s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..561.30 rows=6826 width=32)
         Output: (atan2(value1, (value2)::double precision)), (atan2((value2)::double precision, value3)), (atan2(value3, (value4)::double precision)), (atan2((value4)::double precision, value1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM public.s32influx
(9 rows)

-- select atan2 (builtin function, result)
--Testcase 661:
SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM s3 ORDER BY 1;
         atan2         |       atan2        |        atan2        |        atan2        
-----------------------+--------------------+---------------------+---------------------
 0.0009999996666668668 | 1.5717963264615635 |  -3.140592653923126 | -1.5697963271282296
 0.0019999973333397333 | 1.5727963241282363 | -3.1395926562564536 | -1.5687963294615568
 0.0029999910000485996 | 1.5737963177949452 | -3.1385926625897445 |  -1.567796335794848
  0.005499944542673214 | 1.5762962713375697 |   -3.13609270904712 | -1.5652963822522235
  0.010999556365540751 | 1.5817958831604373 | -3.1305930972242524 | -1.5597967704293558
  0.016498502869548654 | 1.5872948296644451 | -3.1250941507202445 |  -1.554297823925348
(6 rows)

-- select atan2 (builtin function, not pushdown constraints, explain)
--Testcase 662:
EXPLAIN VERBOSE
SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                                                             QUERY PLAN                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1027.05..1044.03 rows=6792 width=32)
   Output: (atan2(value1, (value2)::double precision)), (atan2((value2)::double precision, value3)), (atan2(value3, (value4)::double precision)), (atan2((value4)::double precision, value1))
   Sort Key: (atan2(s3.value1, (s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..594.75 rows=6792 width=32)
         Output: (atan2(value1, (value2)::double precision)), (atan2((value2)::double precision, value3)), (atan2(value3, (value4)::double precision)), (atan2((value4)::double precision, value1))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1), value2 FROM public.s32influx
(10 rows)

-- select atan2 (builtin function, not pushdown constraints, result)
--Testcase 663:
SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
        atan2         |       atan2        |        atan2        |        atan2        
----------------------+--------------------+---------------------+---------------------
 0.005499944542673214 | 1.5762962713375697 |   -3.13609270904712 | -1.5652963822522235
 0.010999556365540751 | 1.5817958831604373 | -3.1305930972242524 | -1.5597967704293558
 0.016498502869548654 | 1.5872948296644451 | -3.1250941507202445 |  -1.554297823925348
(3 rows)

-- select atan2 (builtin function, pushdown constraints, explain)
--Testcase 664:
EXPLAIN VERBOSE
SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                                                             QUERY PLAN                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1009.30..1026.28 rows=6792 width=32)
   Output: (atan2(value1, (value2)::double precision)), (atan2((value2)::double precision, value3)), (atan2(value3, (value4)::double precision)), (atan2((value4)::double precision, value1))
   Sort Key: (atan2(s3.value1, (s3.value2)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..577.00 rows=6792 width=32)
         Output: (atan2(value1, (value2)::double precision)), (atan2((value2)::double precision, value3)), (atan2(value3, (value4)::double precision)), (atan2((value4)::double precision, value1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select atan2 (builtin function, pushdown constraints, result)
--Testcase 665:
SELECT atan2(value1, value2), atan2(value2, value3), atan2(value3, value4), atan2(value4, value1) FROM s3 WHERE value2 != 200 ORDER BY 1;
         atan2         |       atan2        |        atan2        |        atan2        
-----------------------+--------------------+---------------------+---------------------
 0.0009999996666668668 | 1.5717963264615635 |  -3.140592653923126 | -1.5697963271282296
 0.0019999973333397333 | 1.5727963241282363 | -3.1395926562564536 | -1.5687963294615568
 0.0029999910000485996 | 1.5737963177949452 | -3.1385926625897445 |  -1.567796335794848
(3 rows)

-- select atan2 as nest function with agg (pushdown, explain)
--Testcase 666:
EXPLAIN VERBOSE
SELECT sum(value3), sum(value4),atan2(sum(value3), sum(value3)) FROM s3 ORDER BY 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=48)
   Output: (sum(value3)), (sum(value4)), (atan2((sum(value3)), (sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=48)
         Output: (sum(value3)), (sum(value4)), atan2((sum(value3)), (sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3), sum(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3), sum(value4) FROM public.s32influx
(13 rows)

-- select atan2 as nest function with agg (pushdown, result)
--Testcase 667:
SELECT sum(value3), sum(value4),atan2(sum(value3), sum(value3)) FROM s3 ORDER BY 1;
        sum         | sum  |       atan2        
--------------------+------+--------------------
 -7.199999999999999 | -900 | -2.356194490192345
(1 row)

-- select atan2 as nest with log2 (pushdown, explain)
--Testcase 668:
EXPLAIN VERBOSE
SELECT atan2(log2(value1), log2(value1)),atan2(log2(1/value1), log2(1/value1)) FROM s3;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..7319.04 rows=6826 width=16)
   Output: (atan2(log2(value1), log2(value1))), (atan2(log2(('1'::double precision / value1)), log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT atan2(public.log2(value1), public.log2(value1)), atan2(public.log2((1::double precision / value1)), public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT atan2(public.log2(value1), public.log2(value1)), atan2(public.log2((1::double precision / value1)), public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select atan2 as nest with log2 (pushdown, result)
--Testcase 669:
SELECT * FROM (
SELECT atan2(log2(value1), log2(value1)),atan2(log2(1/value1), log2(1/value1)) FROM s3
) as t ORDER BY 1;
       atan2        |       atan2        
--------------------+--------------------
 -2.356194490192345 | 0.7853981633974483
 -2.356194490192345 | 0.7853981633974483
 -2.356194490192345 | 0.7853981633974483
 0.7853981633974483 | -2.356194490192345
 0.7853981633974483 | -2.356194490192345
 0.7853981633974483 | -2.356194490192345
(6 rows)

-- select atan2 with non pushdown func and explicit constant (explain)
--Testcase 670:
EXPLAIN VERBOSE
SELECT atan2(value3, value4), pi(), 4.1 FROM s3 ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=48)
   Output: (atan2(value3, (value4)::double precision)), '3.141592653589793'::double precision, 4.1
   Sort Key: (atan2(s3.value3, (s3.value4)::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=48)
         Output: (atan2(value3, (value4)::double precision)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT atan2(value3, value4), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT atan2(value3, value4), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select atan2 with non pushdown func and explicit constant (result)
--Testcase 671:
SELECT atan2(value3, value4), pi(), 4.1 FROM s3 ORDER BY 1;
        atan2        |        pi         | ?column? 
---------------------+-------------------+----------
  -3.140592653923126 | 3.141592653589793 |      4.1
 -3.1395926562564536 | 3.141592653589793 |      4.1
 -3.1385926625897445 | 3.141592653589793 |      4.1
   -3.13609270904712 | 3.141592653589793 |      4.1
 -3.1305930972242524 | 3.141592653589793 |      4.1
 -3.1250941507202445 | 3.141592653589793 |      4.1
(6 rows)

-- select atan2 with order by (explain)
--Testcase 672:
EXPLAIN VERBOSE
SELECT value1, atan2(1-value1, 1-value2) FROM s3 ORDER BY atan2(1-value1, 1-value2);
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Sort  (cost=927.75..944.81 rows=6826 width=16)
   Output: value1, (atan2(('1'::double precision - value1), ((1 - value2))::double precision))
   Sort Key: (atan2(('1'::double precision - s3.value1), ((1 - s3.value2))::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..493.04 rows=6826 width=16)
         Output: value1, (atan2(('1'::double precision - value1), ((1 - value2))::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, atan2((1::double precision - value1), (1 - value2)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, atan2((1::double precision - value1), (1 - value2)) FROM public.s32influx
(9 rows)

-- select atan2 with order by (result)
--Testcase 673:
SELECT value1, atan2(1-value1, 1-value2) FROM s3 ORDER BY atan2(1-value1, 1-value2);
 value1 |        atan2        
--------+---------------------
    1.1 |  -3.141090141069277
    2.2 | -3.1355625759253205
    3.3 |  -3.130035379243216
    0.1 |  3.1325019949247332
    0.2 |  3.1335120213928933
    0.3 |  3.1345220643486456
(6 rows)

-- select atan2 with order by index (result)
--Testcase 674:
SELECT value1, atan2(1-value1, 1-value2) FROM s3 ORDER BY 2,1;
 value1 |        atan2        
--------+---------------------
    1.1 |  -3.141090141069277
    2.2 | -3.1355625759253205
    3.3 |  -3.130035379243216
    0.1 |  3.1325019949247332
    0.2 |  3.1335120213928933
    0.3 |  3.1345220643486456
(6 rows)

-- select atan2 with order by index (result)
--Testcase 675:
SELECT value1, atan2(1-value1, 1-value2) FROM s3 ORDER BY 1,2;
 value1 |        atan2        
--------+---------------------
    0.1 |  3.1325019949247332
    0.2 |  3.1335120213928933
    0.3 |  3.1345220643486456
    1.1 |  -3.141090141069277
    2.2 | -3.1355625759253205
    3.3 |  -3.130035379243216
(6 rows)

-- select atan2 and as
--Testcase 676:
SELECT atan2(value3, value4) as atan21 FROM s3 ORDER BY 1;
       atan21        
---------------------
  -3.140592653923126
 -3.1395926562564536
 -3.1385926625897445
   -3.13609270904712
 -3.1305930972242524
 -3.1250941507202445
(6 rows)

-- select atan2(*) (stub function, explain)
--Testcase 677:
EXPLAIN VERBOSE
SELECT atan2_all(value1) from s3 ORDER BY 1;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (atan2_all(value1))
   Sort Key: (atan2_all(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (atan2_all(value1))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.atan2_all(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.atan2_all(value1) FROM public.s32influx
(9 rows)

-- select atan2(*) (stub function, result)
--Testcase 678:
SELECT * FROM (
SELECT atan2_all(value1) from s3
) as t ORDER BY 1;
                                                             atan2_all                                                              
------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.7853981633974483,1.5697963271282296,-0.7853981633974483,-1.5697963271282296,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.7853981633974483,1.5687963294615568,-0.7853981633974483,-1.5687963294615568,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.7853981633974483,1.567796335794848,-0.7853981633974483,-1.567796335794848,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.7853981633974483,1.5652963822522235,-0.7853981633974483,-1.5652963822522235,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.7853981633974483,1.5597967704293558,-0.7853981633974483,-1.5597967704293558,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,0.7853981633974483,1.554297823925348,-0.7853981633974483,-1.554297823925348,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select ceil (builtin function, explain)
--Testcase 679:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM s3 ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (ceil(value1)), (ceil((value2)::double precision)), (ceil(value3)), (ceil((value4)::double precision))
   Sort Key: (ceil(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (ceil(value1)), (ceil((value2)::double precision)), (ceil(value3)), (ceil((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM public.s32influx
(9 rows)

-- select ceil (builtin function, result)
--Testcase 680:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM s3 ORDER BY 1;
 ceil | ceil | ceil | ceil 
------+------+------+------
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
    2 |  200 |   -1 | -200
    3 |  200 |   -2 | -200
    4 |  200 |   -3 | -200
(6 rows)

-- select ceil (builtin function, not pushdown constraints, explain)
--Testcase 681:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (ceil(value1)), (ceil((value2)::double precision)), (ceil(value3)), (ceil((value4)::double precision))
   Sort Key: (ceil(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (ceil(value1)), (ceil((value2)::double precision)), (ceil(value3)), (ceil((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), value2 FROM public.s32influx
(10 rows)

-- select ceil (builtin function, not pushdown constraints, result)
--Testcase 682:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
 ceil | ceil | ceil | ceil 
------+------+------+------
    2 |  200 |   -1 | -200
    3 |  200 |   -2 | -200
    4 |  200 |   -3 | -200
(3 rows)

-- select ceil (builtin function, pushdown constraints, explain)
--Testcase 683:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (ceil(value1)), (ceil((value2)::double precision)), (ceil(value3)), (ceil((value4)::double precision))
   Sort Key: (ceil(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (ceil(value1)), (ceil((value2)::double precision)), (ceil(value3)), (ceil((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select ceil (builtin function, pushdown constraints, result)
--Testcase 684:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
 ceil | ceil | ceil | ceil 
------+------+------+------
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
    1 |  100 |   -0 | -100
(3 rows)

-- select ceil as nest function with agg (pushdown, explain)
--Testcase 685:
EXPLAIN VERBOSE
SELECT sum(value3),ceil(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (ceil((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), ceil((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select ceil as nest function with agg (pushdown, result)
--Testcase 686:
SELECT sum(value3),ceil(sum(value3)) FROM s3 ORDER BY 1;
        sum         | ceil 
--------------------+------
 -7.199999999999999 |   -7
(1 row)

-- select ceil as nest with log2 (pushdown, explain)
--Testcase 687:
EXPLAIN VERBOSE
SELECT ceil(log2(value1)),ceil(log2(1/value1)) FROM s3;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (ceil(log2(value1))), (ceil(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT ceil(public.log2(value1)), ceil(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT ceil(public.log2(value1)), ceil(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select ceil as nest with log2 (pushdown, result)
--Testcase 688:
SELECT * FROM (
SELECT ceil(log2(value1)),ceil(log2(1/value1)) FROM s3
) as t ORDER BY 1;
 ceil | ceil 
------+------
   -3 |    4
   -2 |    3
   -1 |    2
    1 |   -0
    2 |   -1
    2 |   -1
(6 rows)

-- select ceil with non pushdown func and explicit constant (explain)
--Testcase 689:
EXPLAIN VERBOSE
SELECT ceil(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (ceil(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (ceil(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (ceil(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ceil(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ceil(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select ceil with non pushdown func and explicit constant (result)
--Testcase 690:
SELECT * FROM (
SELECT ceil(value3), pi(), 4.1 FROM s3
) as t ORDER BY 1;
 ceil |        pi         | ?column? 
------+-------------------+----------
   -3 | 3.141592653589793 |      4.1
   -2 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
(6 rows)

-- select ceil with order by (explain)
--Testcase 691:
EXPLAIN VERBOSE
SELECT value1, ceil(1-value1) FROM s3 ORDER BY ceil(1-value1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (ceil(('1'::double precision - value1)))
   Sort Key: (ceil(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (ceil(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, ceil((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, ceil((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select ceil with order by (result)
--Testcase 692:
SELECT value1, ceil(1-value1) FROM s3 ORDER BY ceil(1-value1);
 value1 | ceil 
--------+------
    3.3 |   -2
    2.2 |   -1
    1.1 |   -0
    0.1 |    1
    0.2 |    1
    0.3 |    1
(6 rows)

-- select ceil with order by index (result)
--Testcase 693:
SELECT value1, ceil(1-value1) FROM s3 ORDER BY 2,1;
 value1 | ceil 
--------+------
    3.3 |   -2
    2.2 |   -1
    1.1 |   -0
    0.1 |    1
    0.2 |    1
    0.3 |    1
(6 rows)

-- select ceil with order by index (result)
--Testcase 694:
SELECT value1, ceil(1-value1) FROM s3 ORDER BY 1,2;
 value1 | ceil 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |   -0
    2.2 |   -1
    3.3 |   -2
(6 rows)

-- select ceil and as
--Testcase 695:
SELECT * FROM (
SELECT ceil(value3) as ceil1 FROM s3
) as t ORDER BY 1;
 ceil1 
-------
    -3
    -2
    -1
    -0
    -0
    -0
(6 rows)

-- select ceil(*) (stub function, explain)
--Testcase 696:
EXPLAIN VERBOSE
SELECT ceil_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (ceil_all())
   Sort Key: (ceil_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (ceil_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.ceil_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.ceil_all() FROM public.s32influx
(9 rows)

-- select ceil(*) (stub function, result)
--Testcase 697:
SELECT * FROM (
SELECT ceil_all() from s3
) as t ORDER BY 1;
                              ceil_all                              
--------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,1,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,1,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,2,200,-1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,3,200,-2,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,4,200,-3,-200,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select ceil(*) (stub function and group by tag only) (explain)
--Testcase 698:
EXPLAIN VERBOSE
SELECT ceil_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (ceil_all()), tag1
   Sort Key: (ceil_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (ceil_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.ceil_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.ceil_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select ceil(*) (stub function and group by tag only) (result)
--Testcase 699:
SELECT ceil_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                              ceil_all                              
--------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,1,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,1,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,2,200,-1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,3,200,-2,-200,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select ceil(*) (stub function, expose data, explain)
--Testcase 700:
EXPLAIN VERBOSE
SELECT (ceil_all()::s3).* from s3 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((ceil_all()))::s3)."time"), ((((ceil_all()))::s3).tag1), ((((ceil_all()))::s3).value1), ((((ceil_all()))::s3).value2), ((((ceil_all()))::s3).value3), ((((ceil_all()))::s3).value4), ((((ceil_all()))::s3).__spd_url)
   Sort Key: ((((ceil_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((ceil_all()))::s3)."time", (((ceil_all()))::s3).tag1, (((ceil_all()))::s3).value1, (((ceil_all()))::s3).value2, (((ceil_all()))::s3).value3, (((ceil_all()))::s3).value4, (((ceil_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.ceil_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.ceil_all() FROM public.s32influx
(9 rows)

-- select ceil(*) (stub function, expose data, result)
--Testcase 701:
SELECT * FROM (
SELECT (ceil_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |      1 |    100 |     -0 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |      1 |    100 |     -0 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |      1 |    100 |     -0 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |      2 |    200 |     -1 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |      3 |    200 |     -2 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |      4 |    200 |     -3 |   -200 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select cos (builtin function, explain)
--Testcase 702:
EXPLAIN VERBOSE
SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM s3 ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (cos(value1)), (cos((value2)::double precision)), (cos(value3)), (cos((value4)::double precision))
   Sort Key: (cos(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (cos(value1)), (cos((value2)::double precision)), (cos(value3)), (cos((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM public.s32influx
(9 rows)

-- select cos (builtin function, result)
--Testcase 703:
SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM s3 ORDER BY 1;
         cos         |         cos         |         cos         |         cos         
---------------------+---------------------+---------------------+---------------------
  -0.987479769908865 | 0.48718767500700594 |  -0.987479769908865 | 0.48718767500700594
 -0.5885011172553458 | 0.48718767500700594 | -0.5885011172553458 | 0.48718767500700594
  0.4535961214255773 | 0.48718767500700594 |  0.4535961214255773 | 0.48718767500700594
   0.955336489125606 |  0.8623188722876839 |   0.955336489125606 |  0.8623188722876839
  0.9800665778412416 |  0.8623188722876839 |  0.9800665778412416 |  0.8623188722876839
  0.9950041652780257 |  0.8623188722876839 |  0.9950041652780257 |  0.8623188722876839
(6 rows)

-- select cos (builtin function, not pushdown constraints, explain)
--Testcase 704:
EXPLAIN VERBOSE
SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (cos(value1)), (cos((value2)::double precision)), (cos(value3)), (cos((value4)::double precision))
   Sort Key: (cos(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (cos(value1)), (cos((value2)::double precision)), (cos(value3)), (cos((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT cos(value1), cos(value2), cos(value3), cos(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT cos(value1), cos(value2), cos(value3), cos(value4), value2 FROM public.s32influx
(10 rows)

-- select cos (builtin function, not pushdown constraints, result)
--Testcase 705:
SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
         cos         |         cos         |         cos         |         cos         
---------------------+---------------------+---------------------+---------------------
  -0.987479769908865 | 0.48718767500700594 |  -0.987479769908865 | 0.48718767500700594
 -0.5885011172553458 | 0.48718767500700594 | -0.5885011172553458 | 0.48718767500700594
  0.4535961214255773 | 0.48718767500700594 |  0.4535961214255773 | 0.48718767500700594
(3 rows)

-- select cos (builtin function, pushdown constraints, explain)
--Testcase 706:
EXPLAIN VERBOSE
SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (cos(value1)), (cos((value2)::double precision)), (cos(value3)), (cos((value4)::double precision))
   Sort Key: (cos(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (cos(value1)), (cos((value2)::double precision)), (cos(value3)), (cos((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select cos (builtin function, pushdown constraints, result)
--Testcase 707:
SELECT cos(value1), cos(value2), cos(value3), cos(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
        cos         |        cos         |        cos         |        cos         
--------------------+--------------------+--------------------+--------------------
  0.955336489125606 | 0.8623188722876839 |  0.955336489125606 | 0.8623188722876839
 0.9800665778412416 | 0.8623188722876839 | 0.9800665778412416 | 0.8623188722876839
 0.9950041652780257 | 0.8623188722876839 | 0.9950041652780257 | 0.8623188722876839
(3 rows)

-- select cos as nest function with agg (pushdown, explain)
--Testcase 708:
EXPLAIN VERBOSE
SELECT sum(value3),cos(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (cos((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), cos((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select cos as nest function with agg (pushdown, result)
--Testcase 709:
SELECT sum(value3),cos(sum(value3)) FROM s3 ORDER BY 1;
        sum         |        cos         
--------------------+--------------------
 -7.199999999999999 | 0.6083513145322552
(1 row)

-- select cos as nest with log2 (pushdown, explain)
--Testcase 710:
EXPLAIN VERBOSE
SELECT cos(log2(value1)),cos(log2(1/value1)) FROM s3;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (cos(log2(value1))), (cos(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT cos(public.log2(value1)), cos(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT cos(public.log2(value1)), cos(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select cos as nest with log2 (pushdown, result)
--Testcase 711:
SELECT * FROM (
SELECT cos(log2(value1)),cos(log2(1/value1)) FROM s3
) as t ORDER BY 1;
         cos          |         cos          
----------------------+----------------------
  -0.9837835835253638 |  -0.9837835835253638
  -0.6824664254067903 |  -0.6824664254067903
 -0.16540560524328635 | -0.16540560524328635
 -0.15108887216909284 | -0.15108887216909284
   0.4198615822391889 |   0.4198615822391891
   0.9905612762159983 |   0.9905612762159983
(6 rows)

-- select cos with non pushdown func and explicit constant (explain)
--Testcase 712:
EXPLAIN VERBOSE
SELECT cos(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (cos(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (cos(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (cos(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT cos(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT cos(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select cos with non pushdown func and explicit constant (result)
--Testcase 713:
SELECT cos(value3), pi(), 4.1 FROM s3 ORDER BY 1;
         cos         |        pi         | ?column? 
---------------------+-------------------+----------
  -0.987479769908865 | 3.141592653589793 |      4.1
 -0.5885011172553458 | 3.141592653589793 |      4.1
  0.4535961214255773 | 3.141592653589793 |      4.1
   0.955336489125606 | 3.141592653589793 |      4.1
  0.9800665778412416 | 3.141592653589793 |      4.1
  0.9950041652780257 | 3.141592653589793 |      4.1
(6 rows)

-- select cos with order by (explain)
--Testcase 714:
EXPLAIN VERBOSE
SELECT value1, cos(1-value1) FROM s3 ORDER BY cos(1-value1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (cos(('1'::double precision - value1)))
   Sort Key: (cos(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (cos(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, cos((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, cos((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select cos with order by (result)
--Testcase 715:
SELECT value1, cos(1-value1) FROM s3 ORDER BY cos(1-value1);
 value1 |        cos         
--------+--------------------
    3.3 | -0.666276021279824
    2.2 | 0.3623577544766734
    0.1 | 0.6216099682706645
    0.2 | 0.6967067093471655
    0.3 | 0.7648421872844884
    1.1 | 0.9950041652780257
(6 rows)

-- select cos with order by index (result)
--Testcase 716:
SELECT value1, cos(1-value1) FROM s3 ORDER BY 2,1;
 value1 |        cos         
--------+--------------------
    3.3 | -0.666276021279824
    2.2 | 0.3623577544766734
    0.1 | 0.6216099682706645
    0.2 | 0.6967067093471655
    0.3 | 0.7648421872844884
    1.1 | 0.9950041652780257
(6 rows)

-- select cos with order by index (result)
--Testcase 717:
SELECT value1, cos(1-value1) FROM s3 ORDER BY 1,2;
 value1 |        cos         
--------+--------------------
    0.1 | 0.6216099682706645
    0.2 | 0.6967067093471655
    0.3 | 0.7648421872844884
    1.1 | 0.9950041652780257
    2.2 | 0.3623577544766734
    3.3 | -0.666276021279824
(6 rows)

-- select cos and as
--Testcase 718:
SELECT cos(value3) as cos1 FROM s3 ORDER BY 1;
        cos1         
---------------------
  -0.987479769908865
 -0.5885011172553458
  0.4535961214255773
   0.955336489125606
  0.9800665778412416
  0.9950041652780257
(6 rows)

-- select cos(*) (stub function, explain)
--Testcase 719:
EXPLAIN VERBOSE
SELECT cos_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (cos_all())
   Sort Key: (cos_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (cos_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.cos_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.cos_all() FROM public.s32influx
(9 rows)

-- select cos(*) (stub function, result)
--Testcase 720:
SELECT * FROM (
SELECT cos_all() from s3
) as t ORDER BY 1;
                                                               cos_all                                                                
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.9950041652780257,0.8623188722876839,0.9950041652780257,0.8623188722876839,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.9800665778412416,0.8623188722876839,0.9800665778412416,0.8623188722876839,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.955336489125606,0.8623188722876839,0.955336489125606,0.8623188722876839,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.4535961214255773,0.48718767500700594,0.4535961214255773,0.48718767500700594,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,-0.5885011172553458,0.48718767500700594,-0.5885011172553458,0.48718767500700594,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,-0.987479769908865,0.48718767500700594,-0.987479769908865,0.48718767500700594,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select cos(*) (stub function and group by tag only) (explain)
--Testcase 721:
EXPLAIN VERBOSE
SELECT cos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (cos_all()), tag1
   Sort Key: (cos_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (cos_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.cos_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.cos_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select cos(*) (stub function and group by tag only) (result)
--Testcase 722:
SELECT cos_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                               cos_all                                                                
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.9950041652780257,0.8623188722876839,0.9950041652780257,0.8623188722876839,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.9800665778412416,0.8623188722876839,0.9800665778412416,0.8623188722876839,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.955336489125606,0.8623188722876839,0.955336489125606,0.8623188722876839,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.4535961214255773,0.48718767500700594,0.4535961214255773,0.48718767500700594,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,-0.5885011172553458,0.48718767500700594,-0.5885011172553458,0.48718767500700594,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select exp (builtin function, explain)
--Testcase 723:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM s3 ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (exp(value1)), (exp((value2)::double precision)), (exp(value3)), (exp((value4)::double precision))
   Sort Key: (exp(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (exp(value1)), (exp((value2)::double precision)), (exp(value3)), (exp((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM public.s32influx
(9 rows)

-- select exp (builtin function, result)
--Testcase 724:
SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM s3 ORDER BY 1;
        exp         |          exp           |         exp          |          exp           
--------------------+------------------------+----------------------+------------------------
 1.1051709180756477 | 2.6881171418161356e+43 |   0.9048374180359595 |  3.720075976020836e-44
 1.2214027581601699 | 2.6881171418161356e+43 |   0.8187307530779819 |  3.720075976020836e-44
 1.3498588075760032 | 2.6881171418161356e+43 |   0.7408182206817179 |  3.720075976020836e-44
 3.0041660239464334 |   7.22597376812575e+86 |   0.3328710836980795 | 1.3838965267367376e-87
  9.025013499434122 |   7.22597376812575e+86 |  0.11080315836233386 | 1.3838965267367376e-87
 27.112638920657883 |   7.22597376812575e+86 | 0.036883167401240015 | 1.3838965267367376e-87
(6 rows)

-- select exp (builtin function, not pushdown constraints, explain)
--Testcase 725:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (exp(value1)), (exp((value2)::double precision)), (exp(value3)), (exp((value4)::double precision))
   Sort Key: (exp(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (exp(value1)), (exp((value2)::double precision)), (exp(value3)), (exp((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT exp(value1), exp(value2), exp(value3), exp(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT exp(value1), exp(value2), exp(value3), exp(value4), value2 FROM public.s32influx
(10 rows)

-- select exp (builtin function, not pushdown constraints, result)
--Testcase 726:
SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
        exp         |         exp          |         exp          |          exp           
--------------------+----------------------+----------------------+------------------------
 3.0041660239464334 | 7.22597376812575e+86 |   0.3328710836980795 | 1.3838965267367376e-87
  9.025013499434122 | 7.22597376812575e+86 |  0.11080315836233386 | 1.3838965267367376e-87
 27.112638920657883 | 7.22597376812575e+86 | 0.036883167401240015 | 1.3838965267367376e-87
(3 rows)

-- select exp (builtin function, pushdown constraints, explain)
--Testcase 727:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (exp(value1)), (exp((value2)::double precision)), (exp(value3)), (exp((value4)::double precision))
   Sort Key: (exp(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (exp(value1)), (exp((value2)::double precision)), (exp(value3)), (exp((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select exp (builtin function, pushdown constraints, result)
--Testcase 728:
SELECT exp(value1), exp(value2), exp(value3), exp(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
        exp         |          exp           |        exp         |          exp          
--------------------+------------------------+--------------------+-----------------------
 1.1051709180756477 | 2.6881171418161356e+43 | 0.9048374180359595 | 3.720075976020836e-44
 1.2214027581601699 | 2.6881171418161356e+43 | 0.8187307530779819 | 3.720075976020836e-44
 1.3498588075760032 | 2.6881171418161356e+43 | 0.7408182206817179 | 3.720075976020836e-44
(3 rows)

-- select exp as nest function with agg (pushdown, explain)
--Testcase 729:
EXPLAIN VERBOSE
SELECT sum(value3),exp(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (exp((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), exp((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select exp as nest function with agg (pushdown, result)
--Testcase 730:
SELECT sum(value3),exp(sum(value3)) FROM s3 ORDER BY 1;
        sum         |          exp          
--------------------+-----------------------
 -7.199999999999999 | 0.0007465858083766799
(1 row)

-- select exp as nest with log2 (pushdown, explain)
--Testcase 731:
EXPLAIN VERBOSE
SELECT exp(log2(value1)),exp(log2(1/value1)) FROM s3;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (exp(log2(value1))), (exp(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT exp(public.log2(value1)), exp(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT exp(public.log2(value1)), exp(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select exp as nest with log2 (pushdown, result)
--Testcase 732:
SELECT * FROM (
SELECT exp(log2(value1)),exp(log2(1/value1)) FROM s3
) as t ORDER BY 1;
         exp          |         exp         
----------------------+---------------------
 0.036083192820787216 |  27.713733786437786
  0.09808428735752978 |  10.195312898128853
  0.17605380962499628 |   5.680081573526024
   1.1474057491358827 |  0.8715312789334596
    3.118972197745508 | 0.32061843985747357
    5.598317042626601 | 0.17862511043690787
(6 rows)

-- select exp with non pushdown func and explicit constant (explain)
--Testcase 733:
EXPLAIN VERBOSE
SELECT exp(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (exp(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (exp(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (exp(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT exp(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT exp(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select exp with non pushdown func and explicit constant (result)
--Testcase 734:
SELECT exp(value3), pi(), 4.1 FROM s3 ORDER BY 1;
         exp          |        pi         | ?column? 
----------------------+-------------------+----------
 0.036883167401240015 | 3.141592653589793 |      4.1
  0.11080315836233386 | 3.141592653589793 |      4.1
   0.3328710836980795 | 3.141592653589793 |      4.1
   0.7408182206817179 | 3.141592653589793 |      4.1
   0.8187307530779819 | 3.141592653589793 |      4.1
   0.9048374180359595 | 3.141592653589793 |      4.1
(6 rows)

-- select exp with order by (explain)
--Testcase 735:
EXPLAIN VERBOSE
SELECT value1, exp(1-value1) FROM s3 ORDER BY exp(1-value1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (exp(('1'::double precision - value1)))
   Sort Key: (exp(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (exp(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, exp((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, exp((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select exp with order by (result)
--Testcase 736:
SELECT value1, exp(1-value1) FROM s3 ORDER BY exp(1-value1);
 value1 |         exp         
--------+---------------------
    3.3 | 0.10025884372280375
    2.2 |   0.301194211912202
    1.1 |  0.9048374180359595
    0.3 |  2.0137527074704766
    0.2 |   2.225540928492468
    0.1 |    2.45960311115695
(6 rows)

-- select exp with order by index (result)
--Testcase 737:
SELECT value1, exp(1-value1) FROM s3 ORDER BY 2,1;
 value1 |         exp         
--------+---------------------
    3.3 | 0.10025884372280375
    2.2 |   0.301194211912202
    1.1 |  0.9048374180359595
    0.3 |  2.0137527074704766
    0.2 |   2.225540928492468
    0.1 |    2.45960311115695
(6 rows)

-- select exp with order by index (result)
--Testcase 738:
SELECT value1, exp(1-value1) FROM s3 ORDER BY 1,2;
 value1 |         exp         
--------+---------------------
    0.1 |    2.45960311115695
    0.2 |   2.225540928492468
    0.3 |  2.0137527074704766
    1.1 |  0.9048374180359595
    2.2 |   0.301194211912202
    3.3 | 0.10025884372280375
(6 rows)

-- select exp and as
--Testcase 739:
SELECT exp(value3) as exp1 FROM s3 ORDER BY 1;
         exp1         
----------------------
 0.036883167401240015
  0.11080315836233386
   0.3328710836980795
   0.7408182206817179
   0.8187307530779819
   0.9048374180359595
(6 rows)

-- select exp(*) (stub function, explain)
--Testcase 740:
EXPLAIN VERBOSE
SELECT exp_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (exp_all())
   Sort Key: (exp_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (exp_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.exp_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.exp_all() FROM public.s32influx
(9 rows)

-- select exp(*) (stub function, result)
--Testcase 741:
SELECT * FROM (
SELECT exp_all() from s3
) as t ORDER BY 1;
                                                                 exp_all                                                                  
------------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,1.1051709180756477,2.6881171418161356e+43,0.9048374180359595,3.720075976020836e-44,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,1.2214027581601699,2.6881171418161356e+43,0.8187307530779819,3.720075976020836e-44,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1.3498588075760032,2.6881171418161356e+43,0.7408182206817179,3.720075976020836e-44,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,3.0041660239464334,7.22597376812575e+86,0.3328710836980795,1.3838965267367376e-87,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,9.025013499434122,7.22597376812575e+86,0.11080315836233386,1.3838965267367376e-87,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,27.112638920657883,7.22597376812575e+86,0.036883167401240015,1.3838965267367376e-87,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select exp(*) (stub function and group by tag only) (explain)
--Testcase 742:
EXPLAIN VERBOSE
SELECT exp_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (exp_all()), tag1
   Sort Key: (exp_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (exp_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.exp_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.exp_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select exp(*) (stub function and group by tag only) (result)
--Testcase 743:
SELECT exp_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                 exp_all                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,1.1051709180756477,2.6881171418161356e+43,0.9048374180359595,3.720075976020836e-44,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,1.2214027581601699,2.6881171418161356e+43,0.8187307530779819,3.720075976020836e-44,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,1.3498588075760032,2.6881171418161356e+43,0.7408182206817179,3.720075976020836e-44,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,3.0041660239464334,7.22597376812575e+86,0.3328710836980795,1.3838965267367376e-87,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,9.025013499434122,7.22597376812575e+86,0.11080315836233386,1.3838965267367376e-87,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--SELECT ceil_all(), cos_all(), exp_all() FROM s3 ORDER BY 1;
-- select floor (builtin function, explain)
--Testcase 744:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM s3 ORDER BY 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (floor(value1)), (floor((value2)::double precision)), (floor(value3)), (floor((value4)::double precision))
   Sort Key: (floor(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (floor(value1)), (floor((value2)::double precision)), (floor(value3)), (floor((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM public.s32influx
(9 rows)

-- select floor (builtin function, result)
--Testcase 745:
SELECT * FROM (
SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM s3
) as t ORDER BY 1, 2, 3, 4;
 floor | floor | floor | floor 
-------+-------+-------+-------
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
     1 |   200 |    -2 |  -200
     2 |   200 |    -3 |  -200
     3 |   200 |    -4 |  -200
(6 rows)

-- select floor (builtin function, not pushdown constraints, explain)
--Testcase 746:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (floor(value1)), (floor((value2)::double precision)), (floor(value3)), (floor((value4)::double precision))
   Sort Key: (floor(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (floor(value1)), (floor((value2)::double precision)), (floor(value3)), (floor((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT floor(value1), floor(value2), floor(value3), floor(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT floor(value1), floor(value2), floor(value3), floor(value4), value2 FROM public.s32influx
(10 rows)

-- select floor (builtin function, not pushdown constraints, result)
--Testcase 747:
SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
 floor | floor | floor | floor 
-------+-------+-------+-------
     1 |   200 |    -2 |  -200
     2 |   200 |    -3 |  -200
     3 |   200 |    -4 |  -200
(3 rows)

-- select floor (builtin function, pushdown constraints, explain)
--Testcase 748:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (floor(value1)), (floor((value2)::double precision)), (floor(value3)), (floor((value4)::double precision))
   Sort Key: (floor(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (floor(value1)), (floor((value2)::double precision)), (floor(value3)), (floor((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select floor (builtin function, pushdown constraints, result)
--Testcase 749:
SELECT floor(value1), floor(value2), floor(value3), floor(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
 floor | floor | floor | floor 
-------+-------+-------+-------
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
     0 |   100 |    -1 |  -100
(3 rows)

-- select floor as nest function with agg (pushdown, explain)
--Testcase 750:
EXPLAIN VERBOSE
SELECT sum(value3),floor(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (floor((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), floor((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select floor as nest function with agg (pushdown, result)
--Testcase 751:
SELECT sum(value3),floor(sum(value3)) FROM s3 ORDER BY 1;
        sum         | floor 
--------------------+-------
 -7.199999999999999 |    -8
(1 row)

-- select floor as nest with log2 (pushdown, explain)
--Testcase 752:
EXPLAIN VERBOSE
SELECT floor(log2(value1)),floor(log2(1/value1)) FROM s3;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (floor(log2(value1))), (floor(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT floor(public.log2(value1)), floor(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT floor(public.log2(value1)), floor(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select floor as nest with log2 (pushdown, result)
--Testcase 753:
SELECT * FROM (
SELECT floor(log2(value1)),floor(log2(1/value1)) FROM s3
) as t ORDER BY 1;
 floor | floor 
-------+-------
    -4 |     3
    -3 |     2
    -2 |     1
     0 |    -1
     1 |    -2
     1 |    -2
(6 rows)

-- select floor with non pushdown func and explicit constant (explain)
--Testcase 754:
EXPLAIN VERBOSE
SELECT floor(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (floor(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (floor(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (floor(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT floor(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT floor(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select floor with non pushdown func and explicit constant (result)
--Testcase 755:
SELECT * FROM (
SELECT floor(value3), pi(), 4.1 FROM s3
) as t ORDER BY 1;
 floor |        pi         | ?column? 
-------+-------------------+----------
    -4 | 3.141592653589793 |      4.1
    -3 | 3.141592653589793 |      4.1
    -2 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
(6 rows)

-- select floor with order by (explain)
--Testcase 756:
EXPLAIN VERBOSE
SELECT value1, floor(1-value1) FROM s3 ORDER BY floor(1-value1);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (floor(('1'::double precision - value1)))
   Sort Key: (floor(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (floor(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, floor((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, floor((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select floor with order by (result)
--Testcase 757:
SELECT value1, floor(1-value1) FROM s3 ORDER BY floor(1-value1);
 value1 | floor 
--------+-------
    3.3 |    -3
    2.2 |    -2
    1.1 |    -1
    0.1 |     0
    0.2 |     0
    0.3 |     0
(6 rows)

-- select floor with order by index (result)
--Testcase 758:
SELECT value1, floor(1-value1) FROM s3 ORDER BY 2,1;
 value1 | floor 
--------+-------
    3.3 |    -3
    2.2 |    -2
    1.1 |    -1
    0.1 |     0
    0.2 |     0
    0.3 |     0
(6 rows)

-- select floor with order by index (result)
--Testcase 759:
SELECT value1, floor(1-value1) FROM s3 ORDER BY 1,2;
 value1 | floor 
--------+-------
    0.1 |     0
    0.2 |     0
    0.3 |     0
    1.1 |    -1
    2.2 |    -2
    3.3 |    -3
(6 rows)

-- select floor and as
--Testcase 760:
SELECT floor(value3) as floor1 FROM s3 ORDER BY 1;
 floor1 
--------
     -4
     -3
     -2
     -1
     -1
     -1
(6 rows)

-- select floor(*) (stub function, explain)
--Testcase 761:
EXPLAIN VERBOSE
SELECT floor_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (floor_all())
   Sort Key: (floor_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (floor_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.floor_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.floor_all() FROM public.s32influx
(9 rows)

-- select floor(*) (stub function, result)
--Testcase 762:
SELECT * FROM (
SELECT floor_all() from s3
) as t ORDER BY 1;
                             floor_all                              
--------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0,100,-1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0,100,-1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0,100,-1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1,200,-2,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2,200,-3,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3,200,-4,-200,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select floor(*) (stub function and group by tag only) (explain)
--Testcase 763:
EXPLAIN VERBOSE
SELECT floor_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (floor_all()), tag1
   Sort Key: (floor_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (floor_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.floor_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.floor_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select floor(*) (stub function and group by tag only) (result)
--Testcase 764:
SELECT floor_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                             floor_all                              
--------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0,100,-1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0,100,-1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0,100,-1,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1,200,-2,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2,200,-3,-200,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select floor(*) (stub function, expose data, explain)
--Testcase 765:
EXPLAIN VERBOSE
SELECT (floor_all()::s3).* from s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((floor_all()))::s3)."time"), ((((floor_all()))::s3).tag1), ((((floor_all()))::s3).value1), ((((floor_all()))::s3).value2), ((((floor_all()))::s3).value3), ((((floor_all()))::s3).value4), ((((floor_all()))::s3).__spd_url)
   Sort Key: ((((floor_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((floor_all()))::s3)."time", (((floor_all()))::s3).tag1, (((floor_all()))::s3).value1, (((floor_all()))::s3).value2, (((floor_all()))::s3).value3, (((floor_all()))::s3).value4, (((floor_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.floor_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.floor_all() FROM public.s32influx
(9 rows)

-- select floor(*) (stub function, expose data, result)
--Testcase 766:
SELECT * FROM (
SELECT (floor_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |      0 |    100 |     -1 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |      0 |    100 |     -1 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |      0 |    100 |     -1 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |      1 |    200 |     -2 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |      2 |    200 |     -3 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |      3 |    200 |     -4 |   -200 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select ln (builtin function, explain)
--Testcase 767:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM s3 ORDER BY 1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (ln(value1)), (ln((value2)::double precision)), (ln(value3)), (ln((value4)::double precision))
   Sort Key: (ln(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (ln(value1)), (ln((value2)::double precision)), (ln(value3)), (ln((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM public.s32influx
(9 rows)

-- select ln (builtin function, result)
--Testcase 768:
SELECT * FROM (
SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM s3
) as t ORDER BY 1, 2, 3, 4;
         ln          |        ln         | ln | ln 
---------------------+-------------------+----+----
 -2.3025850929940455 | 4.605170185988092 |    |   
 -1.6094379124341003 | 4.605170185988092 |    |   
 -1.2039728043259361 | 4.605170185988092 |    |   
 0.09531017980432493 | 5.298317366548036 |    |   
  0.7884573603642703 | 5.298317366548036 |    |   
  1.1939224684724346 | 5.298317366548036 |    |   
(6 rows)

-- select ln (builtin function, not pushdown constraints, explain)
--Testcase 769:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (ln(value1)), (ln((value2)::double precision)), (ln(value3)), (ln((value4)::double precision))
   Sort Key: (ln(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (ln(value1)), (ln((value2)::double precision)), (ln(value3)), (ln((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ln(value1), ln(value2), ln(value3), ln(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ln(value1), ln(value2), ln(value3), ln(value4), value2 FROM public.s32influx
(10 rows)

-- select ln (builtin function, not pushdown constraints, result)
--Testcase 770:
SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
         ln          |        ln         | ln | ln 
---------------------+-------------------+----+----
 0.09531017980432493 | 5.298317366548036 |    |   
  0.7884573603642703 | 5.298317366548036 |    |   
  1.1939224684724346 | 5.298317366548036 |    |   
(3 rows)

-- select ln (builtin function, pushdown constraints, explain)
--Testcase 771:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (ln(value1)), (ln((value2)::double precision)), (ln(value3)), (ln((value4)::double precision))
   Sort Key: (ln(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (ln(value1)), (ln((value2)::double precision)), (ln(value3)), (ln((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select ln (builtin function, pushdown constraints, result)
--Testcase 772:
SELECT ln(value1), ln(value2), ln(value3), ln(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
         ln          |        ln         | ln | ln 
---------------------+-------------------+----+----
 -2.3025850929940455 | 4.605170185988092 |    |   
 -1.6094379124341003 | 4.605170185988092 |    |   
 -1.2039728043259361 | 4.605170185988092 |    |   
(3 rows)

-- select ln as nest function with agg (pushdown, explain)
--Testcase 773:
EXPLAIN VERBOSE
SELECT sum(value3),ln(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (ln((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), ln((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select ln as nest function with agg (pushdown, result)
--Testcase 774:
SELECT sum(value3),ln(sum(value3)) FROM s3 ORDER BY 1;
ERROR:  cannot take logarithm of a negative number
-- select ln as nest with log2 (pushdown, explain)
--Testcase 775:
EXPLAIN VERBOSE
SELECT ln(log2(value1)),ln(log2(1/value1)) FROM s3;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (ln(log2(value1))), (ln(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT ln(public.log2(value1)), ln(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT ln(public.log2(value1)), ln(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select ln as nest with log2 (pushdown, result)
--Testcase 776:
SELECT * FROM (
SELECT ln(log2(value1)),ln(log2(1/value1)) FROM s3
) as t ORDER BY 1;
         ln          |         ln         
---------------------+--------------------
 -1.9841057349316293 |                   
 0.12883596964031102 |                   
  0.5437569991660601 |                   
                     | 1.2005453658296201
                     | 0.8423979159087749
                     |   0.55213967944403
(6 rows)

-- select ln with non pushdown func and explicit constant (explain)
--Testcase 777:
EXPLAIN VERBOSE
SELECT ln(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (ln(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (ln(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (ln(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT ln(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT ln(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select ln with non pushdown func and explicit constant (result)
--Testcase 778:
SELECT ln(value3), pi(), 4.1 FROM s3 ORDER BY 1;
 ln |        pi         | ?column? 
----+-------------------+----------
    | 3.141592653589793 |      4.1
    | 3.141592653589793 |      4.1
    | 3.141592653589793 |      4.1
    | 3.141592653589793 |      4.1
    | 3.141592653589793 |      4.1
    | 3.141592653589793 |      4.1
(6 rows)

-- select ln with order by (explain)
--Testcase 779:
EXPLAIN VERBOSE
SELECT value1, ln(1-value1) FROM s3 ORDER BY ln(1-value1);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (ln(('1'::double precision - value1)))
   Sort Key: (ln(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (ln(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, ln((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, ln((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select ln with order by (result)
--Testcase 780:
SELECT value1, ln(1-value1) FROM s3 ORDER BY ln(1-value1);
 value1 |          ln          
--------+----------------------
    0.3 | -0.35667494393873245
    0.2 |  -0.2231435513142097
    0.1 | -0.10536051565782628
    1.1 |                     
    2.2 |                     
    3.3 |                     
(6 rows)

-- select ln with order by index (result)
--Testcase 781:
SELECT value1, ln(1-value1) FROM s3 ORDER BY 2,1;
 value1 |          ln          
--------+----------------------
    0.3 | -0.35667494393873245
    0.2 |  -0.2231435513142097
    0.1 | -0.10536051565782628
    1.1 |                     
    2.2 |                     
    3.3 |                     
(6 rows)

-- select ln with order by index (result)
--Testcase 782:
SELECT value1, ln(1-value1) FROM s3 ORDER BY 1,2;
 value1 |          ln          
--------+----------------------
    0.1 | -0.10536051565782628
    0.2 |  -0.2231435513142097
    0.3 | -0.35667494393873245
    1.1 |                     
    2.2 |                     
    3.3 |                     
(6 rows)

-- select ln and as
--Testcase 783:
SELECT ln(value1) as ln1 FROM s3 ORDER BY 1;
         ln1         
---------------------
 -2.3025850929940455
 -1.6094379124341003
 -1.2039728043259361
 0.09531017980432493
  0.7884573603642703
  1.1939224684724346
(6 rows)

-- select ln(*) (stub function, explain)
--Testcase 784:
EXPLAIN VERBOSE
SELECT ln_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (ln_all())
   Sort Key: (ln_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (ln_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.ln_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.ln_all() FROM public.s32influx
(9 rows)

-- select ln(*) (stub function, result)
--Testcase 785:
SELECT * FROM (
SELECT ln_all() from s3
) as t ORDER BY 1;
                                            ln_all                                            
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-2.3025850929940455,4.605170185988092,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-1.6094379124341003,4.605170185988092,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-1.2039728043259361,4.605170185988092,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.09531017980432493,5.298317366548036,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.7884573603642703,5.298317366548036,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,1.1939224684724346,5.298317366548036,,,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select ln(*) (stub function and group by tag only) (explain)
--Testcase 786:
EXPLAIN VERBOSE
SELECT ln_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (ln_all()), tag1
   Sort Key: (ln_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (ln_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.ln_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.ln_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select ln(*) (stub function and group by tag only) (result)
--Testcase 787:
SELECT ln_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                            ln_all                                            
----------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,-2.3025850929940455,4.605170185988092,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,-1.6094379124341003,4.605170185988092,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,-1.2039728043259361,4.605170185988092,,,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.09531017980432493,5.298317366548036,,,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.7884573603642703,5.298317366548036,,,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--SELECT ln_all(), floor_all() FROM s3 ORDER BY 1;
-- select pow (builtin function, explain)
--Testcase 788:
EXPLAIN VERBOSE
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 ORDER BY 1;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (pow(value1, '2'::double precision)), (pow((value2)::double precision, '2'::double precision)), (pow(value3, '2'::double precision)), (pow((value4)::double precision, '2'::double precision))
   Sort Key: (pow(s3.value1, '2'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (pow(value1, '2'::double precision)), (pow((value2)::double precision, '2'::double precision)), (pow(value3, '2'::double precision)), (pow((value4)::double precision, '2'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT pow(value1, 2::double precision), pow(value2, 2::double precision), pow(value3, 2::double precision), pow(value4, 2::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT pow(value1, 2::double precision), pow(value2, 2::double precision), pow(value3, 2::double precision), pow(value4, 2::double precision) FROM public.s32influx
(9 rows)

-- select pow (builtin function, result)
--Testcase 789:
SELECT * FROM (
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3
) as t ORDER BY 1, 2, 3, 4;
         pow          |  pow  |         pow          |  pow  
----------------------+-------+----------------------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000
                 0.09 | 10000 |                 0.09 | 10000
   1.2100000000000002 | 40000 |   1.2100000000000002 | 40000
    4.840000000000001 | 40000 |    4.840000000000001 | 40000
   10.889999999999999 | 40000 |   10.889999999999999 | 40000
(6 rows)

-- select pow (builtin function, not pushdown constraints, explain)
--Testcase 790:
EXPLAIN VERBOSE
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (pow(value1, '2'::double precision)), (pow((value2)::double precision, '2'::double precision)), (pow(value3, '2'::double precision)), (pow((value4)::double precision, '2'::double precision))
   Sort Key: (pow(s3.value1, '2'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (pow(value1, '2'::double precision)), (pow((value2)::double precision, '2'::double precision)), (pow(value3, '2'::double precision)), (pow((value4)::double precision, '2'::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT pow(value1, 2::double precision), pow(value2, 2::double precision), pow(value3, 2::double precision), pow(value4, 2::double precision), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT pow(value1, 2::double precision), pow(value2, 2::double precision), pow(value3, 2::double precision), pow(value4, 2::double precision), value2 FROM public.s32influx
(10 rows)

-- select pow (builtin function, not pushdown constraints, result)
--Testcase 791:
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
        pow         |  pow  |        pow         |  pow  
--------------------+-------+--------------------+-------
 1.2100000000000002 | 40000 | 1.2100000000000002 | 40000
  4.840000000000001 | 40000 |  4.840000000000001 | 40000
 10.889999999999999 | 40000 | 10.889999999999999 | 40000
(3 rows)

-- select pow (builtin function, pushdown constraints, explain)
--Testcase 792:
EXPLAIN VERBOSE
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                                                                    QUERY PLAN                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (pow(value1, '2'::double precision)), (pow((value2)::double precision, '2'::double precision)), (pow(value3, '2'::double precision)), (pow((value4)::double precision, '2'::double precision))
   Sort Key: (pow(s3.value1, '2'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (pow(value1, '2'::double precision)), (pow((value2)::double precision, '2'::double precision)), (pow(value3, '2'::double precision)), (pow((value4)::double precision, '2'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT pow(value1, 2::double precision), pow(value2, 2::double precision), pow(value3, 2::double precision), pow(value4, 2::double precision) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT pow(value1, 2::double precision), pow(value2, 2::double precision), pow(value3, 2::double precision), pow(value4, 2::double precision) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select pow (builtin function, pushdown constraints, result)
--Testcase 793:
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE value2 != 200 ORDER BY 1;
         pow          |  pow  |         pow          |  pow  
----------------------+-------+----------------------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000
                 0.09 | 10000 |                 0.09 | 10000
(3 rows)

-- select pow as nest function with agg (pushdown, explain)
--Testcase 794:
EXPLAIN VERBOSE
SELECT sum(value3),pow(sum(value3), 2) FROM s3 ORDER BY 1;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (pow((sum(value3)), '2'::double precision))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), pow((sum(value3)), '2'::double precision)
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select pow as nest function with agg (pushdown, result)
--Testcase 795:
SELECT sum(value3),pow(sum(value3), 2) FROM s3 ORDER BY 1;
        sum         |        pow        
--------------------+-------------------
 -7.199999999999999 | 51.83999999999999
(1 row)

-- select pow as nest with log2 (pushdown, explain)
--Testcase 796:
EXPLAIN VERBOSE
SELECT pow(log2(value1), 2),pow(log2(1/value1), 2) FROM s3;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (pow(log2(value1), '2'::double precision)), (pow(log2(('1'::double precision / value1)), '2'::double precision))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT pow(public.log2(value1), 2::double precision), pow(public.log2((1::double precision / value1)), 2::double precision) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT pow(public.log2(value1), 2::double precision), pow(public.log2((1::double precision / value1)), 2::double precision) FROM public.s32influx
(6 rows)

-- select pow as nest with log2 (pushdown, result)
--Testcase 797:
SELECT * FROM (
SELECT pow(log2(value1), 2),pow(log2(1/value1), 2) FROM s3
) as t ORDER BY 1;
         pow          |         pow          
----------------------+----------------------
 0.018907219043648945 | 0.018907219043648928
   1.2939142665435193 |   1.2939142665435188
    2.966889205457245 |    2.966889205457245
   3.0170494753171613 |   3.0170494753171613
    5.391350077827255 |    5.391350077827255
    11.03520626760198 |    11.03520626760198
(6 rows)

-- select pow with non pushdown func and explicit constant (explain)
--Testcase 798:
EXPLAIN VERBOSE
SELECT pow(value3, 2), pi(), 4.1 FROM s3 ORDER BY 1;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (pow(value3, '2'::double precision)), '3.141592653589793'::double precision, 4.1
   Sort Key: (pow(s3.value3, '2'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (pow(value3, '2'::double precision)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT pow(value3, 2::double precision), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT pow(value3, 2::double precision), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select pow with non pushdown func and explicit constant (result)
--Testcase 799:
SELECT pow(value3, 2), pi(), 4.1 FROM s3 ORDER BY 1;
         pow          |        pi         | ?column? 
----------------------+-------------------+----------
 0.010000000000000002 | 3.141592653589793 |      4.1
  0.04000000000000001 | 3.141592653589793 |      4.1
                 0.09 | 3.141592653589793 |      4.1
   1.2100000000000002 | 3.141592653589793 |      4.1
    4.840000000000001 | 3.141592653589793 |      4.1
   10.889999999999999 | 3.141592653589793 |      4.1
(6 rows)

-- select pow with order by (explain)
--Testcase 800:
EXPLAIN VERBOSE
SELECT value1, pow(1-value1, 2) FROM s3 ORDER BY pow(1-value1, 2);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (pow(('1'::double precision - value1), '2'::double precision))
   Sort Key: (pow(('1'::double precision - s3.value1), '2'::double precision))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (pow(('1'::double precision - value1), '2'::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, pow((1::double precision - value1), 2::double precision) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, pow((1::double precision - value1), 2::double precision) FROM public.s32influx
(9 rows)

-- select pow with order by (result)
--Testcase 801:
SELECT value1, pow(1-value1, 2) FROM s3 ORDER BY pow(1-value1, 2);
 value1 |         pow          
--------+----------------------
    1.1 | 0.010000000000000018
    0.3 |  0.48999999999999994
    0.2 |   0.6400000000000001
    0.1 |                 0.81
    2.2 |   1.4400000000000004
    3.3 |    5.289999999999999
(6 rows)

-- select pow with order by index (result)
--Testcase 802:
SELECT value1, pow(1-value1, 2) FROM s3 ORDER BY 2,1;
 value1 |         pow          
--------+----------------------
    1.1 | 0.010000000000000018
    0.3 |  0.48999999999999994
    0.2 |   0.6400000000000001
    0.1 |                 0.81
    2.2 |   1.4400000000000004
    3.3 |    5.289999999999999
(6 rows)

-- select pow with order by index (result)
--Testcase 803:
SELECT value1, pow(1-value1, 2) FROM s3 ORDER BY 1,2;
 value1 |         pow          
--------+----------------------
    0.1 |                 0.81
    0.2 |   0.6400000000000001
    0.3 |  0.48999999999999994
    1.1 | 0.010000000000000018
    2.2 |   1.4400000000000004
    3.3 |    5.289999999999999
(6 rows)

-- select pow and as
--Testcase 804:
SELECT * FROM (
SELECT pow(value3, 2) as pow1 FROM s3
) as t ORDER BY 1;
         pow1         
----------------------
 0.010000000000000002
  0.04000000000000001
                 0.09
   1.2100000000000002
    4.840000000000001
   10.889999999999999
(6 rows)

-- select pow_all(2) (stub function, explain)
--Testcase 805:
EXPLAIN VERBOSE
SELECT pow_all(2) from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (pow_all(2))
   Sort Key: (pow_all(2))
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (pow_all(2))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.pow_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.pow_all(2) FROM public.s32influx
(9 rows)

-- select pow_all(2) (stub function, result)
--Testcase 806:
SELECT * FROM (
SELECT pow_all(2) from s3
) as t ORDER BY 1;
                                                  pow_all                                                   
------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.010000000000000002,10000,0.010000000000000002,10000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.04000000000000001,10000,0.04000000000000001,10000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09,10000,0.09,10000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.2100000000000002,40000,1.2100000000000002,40000,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,4.840000000000001,40000,4.840000000000001,40000,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,10.889999999999999,40000,10.889999999999999,40000,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select pow_all(2) (stub function and group by tag only) (explain)
--Testcase 807:
EXPLAIN VERBOSE
SELECT pow_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (pow_all(2)), tag1
   Sort Key: (pow_all(2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (pow_all(2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.pow_all(2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.pow_all(2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select pow_all(2) (stub function and group by tag only) (result)
--Testcase 808:
SELECT pow_all(2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                  pow_all                                                   
------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.010000000000000002,10000,0.010000000000000002,10000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.04000000000000001,10000,0.04000000000000001,10000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.09,10000,0.09,10000,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.2100000000000002,40000,1.2100000000000002,40000,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,4.840000000000001,40000,4.840000000000001,40000,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select pow_all(2) (stub function, expose data, explain)
--Testcase 809:
EXPLAIN VERBOSE
SELECT (pow_all(2)::s3).* from s3 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((pow_all(2)))::s3)."time"), ((((pow_all(2)))::s3).tag1), ((((pow_all(2)))::s3).value1), ((((pow_all(2)))::s3).value2), ((((pow_all(2)))::s3).value3), ((((pow_all(2)))::s3).value4), ((((pow_all(2)))::s3).__spd_url)
   Sort Key: ((((pow_all(2)))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((pow_all(2)))::s3)."time", (((pow_all(2)))::s3).tag1, (((pow_all(2)))::s3).value1, (((pow_all(2)))::s3).value2, (((pow_all(2)))::s3).value3, (((pow_all(2)))::s3).value4, (((pow_all(2)))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.pow_all(2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.pow_all(2) FROM public.s32influx
(9 rows)

-- select pow_all(2) (stub function, expose data, result)
--Testcase 810:
SELECT * FROM (
SELECT (pow_all(2)::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 |        value1        | value2 |        value3        | value4 |          __spd_url           
------------------------+------+----------------------+--------+----------------------+--------+------------------------------
 1970-01-01 09:00:00+09 |      | 0.010000000000000002 |  10000 | 0.010000000000000002 |  10000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |  0.04000000000000001 |  10000 |  0.04000000000000001 |  10000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |                 0.09 |  10000 |                 0.09 |  10000 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |   1.2100000000000002 |  40000 |   1.2100000000000002 |  40000 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |    4.840000000000001 |  40000 |    4.840000000000001 |  40000 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |   10.889999999999999 |  40000 |   10.889999999999999 |  40000 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select round (builtin function, explain)
--Testcase 811:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4) FROM s3 ORDER BY 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (round(value1)), (round((value2)::double precision)), (round(value3)), (round((value4)::double precision))
   Sort Key: (round(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (round(value1)), (round((value2)::double precision)), (round(value3)), (round((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT round(value1), round(value2), round(value3), round(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT round(value1), round(value2), round(value3), round(value4) FROM public.s32influx
(9 rows)

-- select round (builtin function, result)
--Testcase 812:
SELECT round(value1), round(value2), round(value3), round(value4) FROM s3 ORDER BY 1;
 round | round | round | round 
-------+-------+-------+-------
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
     1 |   200 |    -1 |  -200
     2 |   200 |    -2 |  -200
     3 |   200 |    -3 |  -200
(6 rows)

-- select round (builtin function, not pushdown constraints, explain)
--Testcase 813:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (round(value1)), (round((value2)::double precision)), (round(value3)), (round((value4)::double precision))
   Sort Key: (round(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (round(value1)), (round((value2)::double precision)), (round(value3)), (round((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT round(value1), round(value2), round(value3), round(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT round(value1), round(value2), round(value3), round(value4), value2 FROM public.s32influx
(10 rows)

-- select round (builtin function, not pushdown constraints, result)
--Testcase 814:
SELECT round(value1), round(value2), round(value3), round(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
 round | round | round | round 
-------+-------+-------+-------
     1 |   200 |    -1 |  -200
     2 |   200 |    -2 |  -200
     3 |   200 |    -3 |  -200
(3 rows)

-- select round (builtin function, pushdown constraints, explain)
--Testcase 815:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (round(value1)), (round((value2)::double precision)), (round(value3)), (round((value4)::double precision))
   Sort Key: (round(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (round(value1)), (round((value2)::double precision)), (round(value3)), (round((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT round(value1), round(value2), round(value3), round(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT round(value1), round(value2), round(value3), round(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select round (builtin function, pushdown constraints, result)
--Testcase 816:
SELECT round(value1), round(value2), round(value3), round(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
 round | round | round | round 
-------+-------+-------+-------
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
     0 |   100 |    -0 |  -100
(3 rows)

-- select round as nest function with agg (pushdown, explain)
--Testcase 817:
EXPLAIN VERBOSE
SELECT sum(value3),round(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (round((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), round((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select round as nest function with agg (pushdown, result)
--Testcase 818:
SELECT sum(value3),round(sum(value3)) FROM s3 ORDER BY 1;
        sum         | round 
--------------------+-------
 -7.199999999999999 |    -7
(1 row)

-- select round as nest with log2 (pushdown, explain)
--Testcase 819:
EXPLAIN VERBOSE
SELECT round(log2(value1)),round(log2(1/value1)) FROM s3;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (round(log2(value1))), (round(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT round(public.log2(value1)), round(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT round(public.log2(value1)), round(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select round as nest with log2 (pushdown, result)
--Testcase 820:
SELECT * FROM (
SELECT round(log2(value1)),round(log2(1/value1)) FROM s3
) as t ORDER BY 1;
 round | round 
-------+-------
    -3 |     3
    -2 |     2
    -2 |     2
     0 |    -0
     1 |    -1
     2 |    -2
(6 rows)

-- select round with non pushdown func and roundlicit constant (explain)
--Testcase 821:
EXPLAIN VERBOSE
SELECT round(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (round(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (round(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (round(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT round(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT round(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select round with non pushdown func and roundlicit constant (result)
--Testcase 822:
SELECT round(value3), pi(), 4.1 FROM s3 ORDER BY 1;
 round |        pi         | ?column? 
-------+-------------------+----------
    -3 | 3.141592653589793 |      4.1
    -2 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
(6 rows)

-- select round with order by (explain)
--Testcase 823:
EXPLAIN VERBOSE
SELECT value1, round(1-value1) FROM s3 ORDER BY round(1-value1);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (round(('1'::double precision - value1)))
   Sort Key: (round(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (round(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, round((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, round((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select round with order by (result)
--Testcase 824:
SELECT value1, round(1-value1) FROM s3 ORDER BY round(1-value1);
 value1 | round 
--------+-------
    3.3 |    -2
    2.2 |    -1
    1.1 |    -0
    0.1 |     1
    0.2 |     1
    0.3 |     1
(6 rows)

-- select round with order by index (result)
--Testcase 825:
SELECT value1, round(1-value1) FROM s3 ORDER BY 2,1;
 value1 | round 
--------+-------
    3.3 |    -2
    2.2 |    -1
    1.1 |    -0
    0.1 |     1
    0.2 |     1
    0.3 |     1
(6 rows)

-- select round with order by index (result)
--Testcase 826:
SELECT value1, round(1-value1) FROM s3 ORDER BY 1,2;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |    -0
    2.2 |    -1
    3.3 |    -2
(6 rows)

-- select round and as
--Testcase 827:
SELECT round(value3) as round1 FROM s3 ORDER BY 1;
 round1 
--------
     -3
     -2
     -1
     -0
     -0
     -0
(6 rows)

-- select round(*) (stub function, explain)
--Testcase 828:
EXPLAIN VERBOSE
SELECT round_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (round_all())
   Sort Key: (round_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (round_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.round_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.round_all() FROM public.s32influx
(9 rows)

-- select round(*) (stub function, result)
--Testcase 829:
SELECT * FROM (
SELECT round_all() from s3
) as t ORDER BY 1;
                             round_all                              
--------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1,200,-1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2,200,-2,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,3,200,-3,-200,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select round(*) (stub function and group by tag only) (explain)
--Testcase 830:
EXPLAIN VERBOSE
SELECT round_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                             QUERY PLAN                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (round_all()), tag1
   Sort Key: (round_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (round_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.round_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.round_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select round(*) (stub function and group by tag only) (result)
--Testcase 831:
SELECT round_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                             round_all                              
--------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0,100,-0,-100,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1,200,-1,-200,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,2,200,-2,-200,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select round(*) (stub function, expose data, explain)
--Testcase 832:
EXPLAIN VERBOSE
SELECT (round_all()::s3).* from s3 ORDER BY 1;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=13043.90..13060.96 rows=6826 width=104)
   Output: ((((round_all()))::s3)."time"), ((((round_all()))::s3).tag1), ((((round_all()))::s3).value1), ((((round_all()))::s3).value2), ((((round_all()))::s3).value3), ((((round_all()))::s3).value4), ((((round_all()))::s3).__spd_url)
   Sort Key: ((((round_all()))::s3)."time")
   ->  Foreign Scan on public.s3  (cost=200.00..12609.19 rows=6826 width=104)
         Output: (((round_all()))::s3)."time", (((round_all()))::s3).tag1, (((round_all()))::s3).value1, (((round_all()))::s3).value2, (((round_all()))::s3).value3, (((round_all()))::s3).value4, (((round_all()))::s3).__spd_url
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.round_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.round_all() FROM public.s32influx
(9 rows)

-- select round(*) (stub function, expose data, result)
--Testcase 833:
SELECT * FROM (
SELECT (round_all()::s3).* from s3
) as t ORDER BY 1;
          time          | tag1 | value1 | value2 | value3 | value4 |          __spd_url           
------------------------+------+--------+--------+--------+--------+------------------------------
 1970-01-01 09:00:00+09 |      |      0 |    100 |     -0 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:01+09 |      |      0 |    100 |     -0 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:02+09 |      |      0 |    100 |     -0 |   -100 | /pgspider_svr1/influxdb_svr/
 1970-01-01 09:00:03+09 |      |      1 |    200 |     -1 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:04+09 |      |      2 |    200 |     -2 |   -200 | /pgspider_svr2/influxdb_svr/
 1970-01-01 09:00:05+09 |      |      3 |    200 |     -3 |   -200 | /pgspider_svr2/influxdb_svr/
(6 rows)

-- select sin (builtin function, explain)
--Testcase 834:
EXPLAIN VERBOSE
SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM s3 ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (sin(value1)), (sin((value2)::double precision)), (sin(value3)), (sin((value4)::double precision))
   Sort Key: (sin(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (sin(value1)), (sin((value2)::double precision)), (sin(value3)), (sin((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM public.s32influx
(9 rows)

-- select sin (builtin function, result)
--Testcase 835:
SELECT * FROM (
SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM s3
) as t ORDER BY 1, 2, 3, 4;
         sin         |         sin         |         sin          |        sin         
---------------------+---------------------+----------------------+--------------------
 -0.1577456941432482 | -0.8732972972139945 |   0.1577456941432482 | 0.8732972972139945
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588
  0.8084964038195901 | -0.8732972972139945 |  -0.8084964038195901 | 0.8732972972139945
  0.8912073600614354 | -0.8732972972139945 |  -0.8912073600614354 | 0.8732972972139945
(6 rows)

-- select sin (builtin function, not pushdown constraints, explain)
--Testcase 836:
EXPLAIN VERBOSE
SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (sin(value1)), (sin((value2)::double precision)), (sin(value3)), (sin((value4)::double precision))
   Sort Key: (sin(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (sin(value1)), (sin((value2)::double precision)), (sin(value3)), (sin((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sin(value1), sin(value2), sin(value3), sin(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sin(value1), sin(value2), sin(value3), sin(value4), value2 FROM public.s32influx
(10 rows)

-- select sin (builtin function, not pushdown constraints, result)
--Testcase 837:
SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
         sin         |         sin         |         sin         |        sin         
---------------------+---------------------+---------------------+--------------------
 -0.1577456941432482 | -0.8732972972139945 |  0.1577456941432482 | 0.8732972972139945
  0.8084964038195901 | -0.8732972972139945 | -0.8084964038195901 | 0.8732972972139945
  0.8912073600614354 | -0.8732972972139945 | -0.8912073600614354 | 0.8732972972139945
(3 rows)

-- select sin (builtin function, pushdown constraints, explain)
--Testcase 838:
EXPLAIN VERBOSE
SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (sin(value1)), (sin((value2)::double precision)), (sin(value3)), (sin((value4)::double precision))
   Sort Key: (sin(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (sin(value1)), (sin((value2)::double precision)), (sin(value3)), (sin((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select sin (builtin function, pushdown constraints, result)
--Testcase 839:
SELECT sin(value1), sin(value2), sin(value3), sin(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
         sin         |         sin         |         sin          |        sin         
---------------------+---------------------+----------------------+--------------------
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588
(3 rows)

-- select sin as nest function with agg (pushdown, explain)
--Testcase 840:
EXPLAIN VERBOSE
SELECT sum(value3),sin(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (sin((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), sin((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select sin as nest function with agg (pushdown, result)
--Testcase 841:
SELECT sum(value3),sin(sum(value3)) FROM s3 ORDER BY 1;
        sum         |         sin         
--------------------+---------------------
 -7.199999999999999 | -0.7936678638491527
(1 row)

-- select sin as nest with log2 (pushdown, explain)
--Testcase 842:
EXPLAIN VERBOSE
SELECT sin(log2(value1)),sin(log2(1/value1)) FROM s3;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (sin(log2(value1))), (sin(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT sin(public.log2(value1)), sin(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT sin(public.log2(value1)), sin(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select sin as nest with log2 (pushdown, result)
--Testcase 843:
SELECT * FROM (
SELECT sin(log2(value1)),sin(log2(1/value1)) FROM s3
) as t ORDER BY 1;
         sin         |         sin          
---------------------+----------------------
  -0.986225626190124 |    0.986225626190124
  -0.730916943429606 |    0.730916943429606
  0.1370706316514691 | -0.13707063165146907
 0.17935958515226794 | -0.17935958515226794
  0.9075881509581342 |   -0.907588150958134
  0.9885201832571107 |  -0.9885201832571107
(6 rows)

-- select sin with non pushdown func and explicit constant (explain)
--Testcase 844:
EXPLAIN VERBOSE
SELECT sin(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (sin(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (sin(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (sin(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT sin(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT sin(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select sin with non pushdown func and explicit constant (result)
--Testcase 845:
SELECT sin(value3), pi(), 4.1 FROM s3 ORDER BY 1;
         sin          |        pi         | ?column? 
----------------------+-------------------+----------
  -0.8912073600614354 | 3.141592653589793 |      4.1
  -0.8084964038195901 | 3.141592653589793 |      4.1
 -0.29552020666133955 | 3.141592653589793 |      4.1
 -0.19866933079506122 | 3.141592653589793 |      4.1
 -0.09983341664682815 | 3.141592653589793 |      4.1
   0.1577456941432482 | 3.141592653589793 |      4.1
(6 rows)

-- select sin with order by (explain)
--Testcase 846:
EXPLAIN VERBOSE
SELECT value1, sin(1-value1) FROM s3 ORDER BY sin(1-value1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (sin(('1'::double precision - value1)))
   Sort Key: (sin(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (sin(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, sin((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, sin((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select sin with order by (result)
--Testcase 847:
SELECT value1, sin(1-value1) FROM s3 ORDER BY sin(1-value1);
 value1 |         sin          
--------+----------------------
    2.2 |  -0.9320390859672264
    3.3 |  -0.7457052121767203
    1.1 | -0.09983341664682824
    0.3 |    0.644217687237691
    0.2 |   0.7173560908995227
    0.1 |   0.7833269096274834
(6 rows)

-- select sin with order by index (result)
--Testcase 848:
SELECT value1, sin(1-value1) FROM s3 ORDER BY 2,1;
 value1 |         sin          
--------+----------------------
    2.2 |  -0.9320390859672264
    3.3 |  -0.7457052121767203
    1.1 | -0.09983341664682824
    0.3 |    0.644217687237691
    0.2 |   0.7173560908995227
    0.1 |   0.7833269096274834
(6 rows)

-- select sin with order by index (result)
--Testcase 849:
SELECT value1, sin(1-value1) FROM s3 ORDER BY 1,2;
 value1 |         sin          
--------+----------------------
    0.1 |   0.7833269096274834
    0.2 |   0.7173560908995227
    0.3 |    0.644217687237691
    1.1 | -0.09983341664682824
    2.2 |  -0.9320390859672264
    3.3 |  -0.7457052121767203
(6 rows)

-- select sin and as
--Testcase 850:
SELECT sin(value3) as sin1 FROM s3 ORDER BY 1;
         sin1         
----------------------
  -0.8912073600614354
  -0.8084964038195901
 -0.29552020666133955
 -0.19866933079506122
 -0.09983341664682815
   0.1577456941432482
(6 rows)

-- select sin(*) (stub function, explain)
--Testcase 851:
EXPLAIN VERBOSE
SELECT sin_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (sin_all())
   Sort Key: (sin_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (sin_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.sin_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.sin_all() FROM public.s32influx
(9 rows)

-- select sin(*) (stub function, result)
--Testcase 852:
SELECT * FROM (
SELECT sin_all() from s3
) as t ORDER BY 1;
                                                               sin_all                                                                
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.09983341664682815,-0.5063656411097588,-0.09983341664682815,0.5063656411097588,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.19866933079506122,-0.5063656411097588,-0.19866933079506122,0.5063656411097588,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.29552020666133955,-0.5063656411097588,-0.29552020666133955,0.5063656411097588,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.8912073600614354,-0.8732972972139945,-0.8912073600614354,0.8732972972139945,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.8084964038195901,-0.8732972972139945,-0.8084964038195901,0.8732972972139945,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,-0.1577456941432482,-0.8732972972139945,0.1577456941432482,0.8732972972139945,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select sin(*) (stub function and group by tag only) (explain)
--Testcase 853:
EXPLAIN VERBOSE
SELECT sin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (sin_all()), tag1
   Sort Key: (sin_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (sin_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.sin_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.sin_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select sin(*) (stub function and group by tag only) (result)
--Testcase 854:
SELECT sin_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                               sin_all                                                                
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.09983341664682815,-0.5063656411097588,-0.09983341664682815,0.5063656411097588,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.19866933079506122,-0.5063656411097588,-0.19866933079506122,0.5063656411097588,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.29552020666133955,-0.5063656411097588,-0.29552020666133955,0.5063656411097588,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,0.8912073600614354,-0.8732972972139945,-0.8912073600614354,0.8732972972139945,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,0.8084964038195901,-0.8732972972139945,-0.8084964038195901,0.8732972972139945,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select tan (builtin function, explain)
--Testcase 855:
EXPLAIN VERBOSE
SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM s3 ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=961.88..978.94 rows=6826 width=32)
   Output: (tan(value1)), (tan((value2)::double precision)), (tan(value3)), (tan((value4)::double precision))
   Sort Key: (tan(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..527.17 rows=6826 width=32)
         Output: (tan(value1)), (tan((value2)::double precision)), (tan(value3)), (tan((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM public.s32influx
(9 rows)

-- select tan (builtin function, result)
--Testcase 856:
SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM s3 ORDER BY 1;
         tan         |         tan         |         tan          |        tan         
---------------------+---------------------+----------------------+--------------------
 -1.3738230567687948 | -1.7925274837903817 |   1.3738230567687948 | 1.7925274837903817
 0.10033467208545055 |  -0.587213915156929 | -0.10033467208545055 |  0.587213915156929
 0.15974574766003222 | -1.7925274837903817 | -0.15974574766003222 | 1.7925274837903817
  0.2027100355086725 |  -0.587213915156929 |  -0.2027100355086725 |  0.587213915156929
 0.30933624960962325 |  -0.587213915156929 | -0.30933624960962325 |  0.587213915156929
  1.9647596572486523 | -1.7925274837903817 |  -1.9647596572486523 | 1.7925274837903817
(6 rows)

-- select tan (builtin function, not pushdown constraints, explain)
--Testcase 857:
EXPLAIN VERBOSE
SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=993.09..1010.07 rows=6792 width=32)
   Output: (tan(value1)), (tan((value2)::double precision)), (tan(value3)), (tan((value4)::double precision))
   Sort Key: (tan(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..560.79 rows=6792 width=32)
         Output: (tan(value1)), (tan((value2)::double precision)), (tan(value3)), (tan((value4)::double precision))
         Filter: ((to_hex(s3.value2) <> '64'::text) AND (to_hex(s3.value2) <> '64'::text))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT tan(value1), tan(value2), tan(value3), tan(value4), value2 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT tan(value1), tan(value2), tan(value3), tan(value4), value2 FROM public.s32influx
(10 rows)

-- select tan (builtin function, not pushdown constraints, result)
--Testcase 858:
SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM s3 WHERE to_hex(value2) != '64' ORDER BY 1;
         tan         |         tan         |         tan          |        tan         
---------------------+---------------------+----------------------+--------------------
 -1.3738230567687948 | -1.7925274837903817 |   1.3738230567687948 | 1.7925274837903817
 0.15974574766003222 | -1.7925274837903817 | -0.15974574766003222 | 1.7925274837903817
  1.9647596572486523 | -1.7925274837903817 |  -1.9647596572486523 | 1.7925274837903817
(3 rows)

-- select tan (builtin function, pushdown constraints, explain)
--Testcase 859:
EXPLAIN VERBOSE
SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=975.34..992.32 rows=6792 width=32)
   Output: (tan(value1)), (tan((value2)::double precision)), (tan(value3)), (tan((value4)::double precision))
   Sort Key: (tan(s3.value1))
   ->  Foreign Scan on public.s3  (cost=200.00..543.05 rows=6792 width=32)
         Output: (tan(value1)), (tan((value2)::double precision)), (tan(value3)), (tan((value4)::double precision))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM public.s31influx WHERE ((value2 <> 200))
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM public.s32influx WHERE ((value2 <> 200))
(9 rows)

-- select tan (builtin function, pushdown constraints, result)
--Testcase 860:
SELECT tan(value1), tan(value2), tan(value3), tan(value4) FROM s3 WHERE value2 != 200 ORDER BY 1;
         tan         |        tan         |         tan          |        tan        
---------------------+--------------------+----------------------+-------------------
 0.10033467208545055 | -0.587213915156929 | -0.10033467208545055 | 0.587213915156929
  0.2027100355086725 | -0.587213915156929 |  -0.2027100355086725 | 0.587213915156929
 0.30933624960962325 | -0.587213915156929 | -0.30933624960962325 | 0.587213915156929
(3 rows)

-- select tan as nest function with agg (pushdown, explain)
--Testcase 861:
EXPLAIN VERBOSE
SELECT sum(value3),tan(sum(value3)) FROM s3 ORDER BY 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=16)
   Output: (sum(value3)), (tan((sum(value3))))
   Sort Key: (sum(s3.value3))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
         Output: (sum(value3)), tan((sum(value3)))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT sum(value3) FROM public.s32influx
(13 rows)

-- select tan as nest function with agg (pushdown, result)
--Testcase 862:
SELECT sum(value3),tan(sum(value3)) FROM s3 ORDER BY 1;
        sum         |        tan         
--------------------+--------------------
 -7.199999999999999 | -1.304620940055636
(1 row)

-- select tan as nest with log2 (pushdown, explain)
--Testcase 863:
EXPLAIN VERBOSE
SELECT tan(log2(value1)),tan(log2(1/value1)) FROM s3;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=200.00..3888.98 rows=6826 width=16)
   Output: (tan(log2(value1))), (tan(log2(('1'::double precision / value1))))
   Node: pgspider_svr1 / Status: Alive
     Remote SQL: SELECT tan(public.log2(value1)), tan(public.log2((1::double precision / value1))) FROM public.s31influx
   Node: pgspider_svr2 / Status: Alive
     Remote SQL: SELECT tan(public.log2(value1)), tan(public.log2((1::double precision / value1))) FROM public.s32influx
(6 rows)

-- select tan as nest with log2 (pushdown, result)
--Testcase 864:
SELECT * FROM (
SELECT tan(log2(value1)),tan(log2(1/value1)) FROM s3
) as t ORDER BY 1, 2;
         tan          |         tan         
----------------------+---------------------
   -6.542640560257786 |   6.542640560257786
 -0.18231609894275463 | 0.18231609894275463
  0.13837673139726087 | -0.1383767313972608
   1.0709932624069183 | -1.0709932624069183
   2.1616365710761665 |  -2.161636571076165
    5.962467987342611 |  -5.962467987342611
(6 rows)

-- select tan with non pushdown func and tanlicit constant (explain)
--Testcase 865:
EXPLAIN VERBOSE
SELECT tan(value3), pi(), 4.1 FROM s3 ORDER BY 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Sort  (cost=876.55..893.62 rows=6826 width=48)
   Output: (tan(value3)), '3.141592653589793'::double precision, 4.1
   Sort Key: (tan(s3.value3))
   ->  Foreign Scan on public.s3  (cost=200.00..441.84 rows=6826 width=48)
         Output: (tan(value3)), '3.141592653589793'::double precision, 4.1
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT tan(value3), 3.141592653589793::double precision, 4.1 FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT tan(value3), 3.141592653589793::double precision, 4.1 FROM public.s32influx
(9 rows)

-- select tan with non pushdown func and tanlicit constant (result)
--Testcase 866:
SELECT tan(value3), pi(), 4.1 FROM s3 ORDER BY 1;
         tan          |        pi         | ?column? 
----------------------+-------------------+----------
  -1.9647596572486523 | 3.141592653589793 |      4.1
 -0.30933624960962325 | 3.141592653589793 |      4.1
  -0.2027100355086725 | 3.141592653589793 |      4.1
 -0.15974574766003222 | 3.141592653589793 |      4.1
 -0.10033467208545055 | 3.141592653589793 |      4.1
   1.3738230567687948 | 3.141592653589793 |      4.1
(6 rows)

-- select tan with order by (explain)
--Testcase 867:
EXPLAIN VERBOSE
SELECT value1, tan(1-value1) FROM s3 ORDER BY tan(1-value1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Sort  (cost=893.62..910.68 rows=6826 width=16)
   Output: value1, (tan(('1'::double precision - value1)))
   Sort Key: (tan(('1'::double precision - s3.value1)))
   ->  Foreign Scan on public.s3  (cost=200.00..458.91 rows=6826 width=16)
         Output: value1, (tan(('1'::double precision - value1)))
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT value1, tan((1::double precision - value1)) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT value1, tan((1::double precision - value1)) FROM public.s32influx
(9 rows)

-- select tan with order by (result)
--Testcase 868:
SELECT value1, tan(1-value1) FROM s3 ORDER BY tan(1-value1);
 value1 |         tan          
--------+----------------------
    2.2 |  -2.5721516221263205
    1.1 | -0.10033467208545063
    0.3 |   0.8422883804630794
    0.2 |   1.0296385570503641
    3.3 |   1.1192136417341327
    0.1 |    1.260158217550339
(6 rows)

-- select tan with order by index (result)
--Testcase 869:
SELECT value1, tan(1-value1) FROM s3 ORDER BY 2,1;
 value1 |         tan          
--------+----------------------
    2.2 |  -2.5721516221263205
    1.1 | -0.10033467208545063
    0.3 |   0.8422883804630794
    0.2 |   1.0296385570503641
    3.3 |   1.1192136417341327
    0.1 |    1.260158217550339
(6 rows)

-- select tan with order by index (result)
--Testcase 870:
SELECT value1, tan(1-value1) FROM s3 ORDER BY 1,2;
 value1 |         tan          
--------+----------------------
    0.1 |    1.260158217550339
    0.2 |   1.0296385570503641
    0.3 |   0.8422883804630794
    1.1 | -0.10033467208545063
    2.2 |  -2.5721516221263205
    3.3 |   1.1192136417341327
(6 rows)

-- select tan and as
--Testcase 871:
SELECT tan(value3) as tan1 FROM s3 ORDER BY 1;
         tan1         
----------------------
  -1.9647596572486523
 -0.30933624960962325
  -0.2027100355086725
 -0.15974574766003222
 -0.10033467208545055
   1.3738230567687948
(6 rows)

-- select tan(*) (stub function, explain)
--Testcase 872:
EXPLAIN VERBOSE
SELECT tan_all() from s3 ORDER BY 1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort  (cost=2565.99..2583.05 rows=6826 width=32)
   Output: (tan_all())
   Sort Key: (tan_all())
   ->  Foreign Scan on public.s3  (cost=200.00..2131.28 rows=6826 width=32)
         Output: (tan_all())
         Node: pgspider_svr1 / Status: Alive
           Remote SQL: SELECT public.tan_all() FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Remote SQL: SELECT public.tan_all() FROM public.s32influx
(9 rows)

-- select tan(*) (stub function, result)
--Testcase 873:
SELECT * FROM (
SELECT tan_all() from s3
) as t ORDER BY 1;
                                                               tan_all                                                                
--------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.10033467208545055,-0.587213915156929,-0.10033467208545055,0.587213915156929,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.2027100355086725,-0.587213915156929,-0.2027100355086725,0.587213915156929,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.30933624960962325,-0.587213915156929,-0.30933624960962325,0.587213915156929,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.9647596572486523,-1.7925274837903817,-1.9647596572486523,1.7925274837903817,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,-1.3738230567687948,-1.7925274837903817,1.3738230567687948,1.7925274837903817,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:05Z,,0.15974574766003222,-1.7925274837903817,-0.15974574766003222,1.7925274837903817,/pgspider_svr2/influxdb_svr/)
(6 rows)

-- select tan(*) (stub function and group by tag only) (explain)
--Testcase 874:
EXPLAIN VERBOSE
SELECT tan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=64)
   Output: (tan_all()), tag1
   Sort Key: (tan_all())
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=64)
         Output: (tan_all()), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.tan_all(), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.tan_all(), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select tan(*) (stub function and group by tag only) (result)
--Testcase 875:
SELECT tan_all() FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                              tan_all                                                               
------------------------------------------------------------------------------------------------------------------------------------
 (1970-01-01T00:00:00Z,,0.10033467208545055,-0.587213915156929,-0.10033467208545055,0.587213915156929,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:01Z,,0.2027100355086725,-0.587213915156929,-0.2027100355086725,0.587213915156929,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:02Z,,0.30933624960962325,-0.587213915156929,-0.30933624960962325,0.587213915156929,/pgspider_svr1/influxdb_svr/)
 (1970-01-01T00:00:03Z,,1.9647596572486523,-1.7925274837903817,-1.9647596572486523,1.7925274837903817,/pgspider_svr2/influxdb_svr/)
 (1970-01-01T00:00:04Z,,-1.3738230567687948,-1.7925274837903817,1.3738230567687948,1.7925274837903817,/pgspider_svr2/influxdb_svr/)
(5 rows)

-- select multiple star functions (do not push down, raise warning and stub error) (result)
--SELECT sin_all(), round_all(), tan_all() FROM s3 ORDER BY 1;
-- select predictors function holt_winters() (explain)
--Testcase 876:
EXPLAIN VERBOSE
SELECT holt_winters(min(value1), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s') ORDER BY 1;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.81..349.89 rows=32 width=16)
   Output: (holt_winters(min(value1), 5, 1)), (influx_time("time", '@ 1 sec'::interval))
   Sort Key: (holt_winters(min(s3.value1), 5, 1))
   ->  GroupAggregate  (cost=332.43..349.01 rows=32 width=16)
         Output: holt_winters(min(value1), 5, 1), (influx_time("time", '@ 1 sec'::interval))
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval))
         ->  Sort  (cost=332.43..332.52 rows=34 width=16)
               Output: (influx_time("time", '@ 1 sec'::interval)), value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval))
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=16)
                     Output: influx_time("time", '@ 1 sec'::interval), value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select predictors function holt_winters() (result)
--Testcase 877:
SELECT holt_winters(min(value1), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s') ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select predictors function holt_winters_with_fit() (explain)
--Testcase 878:
EXPLAIN VERBOSE
SELECT holt_winters_with_fit(min(value1), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s') ORDER BY 1;
                                                                                                        QUERY PLAN                                                                                                         
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=349.81..349.89 rows=32 width=16)
   Output: (holt_winters_with_fit(min(value1), 5, 1)), (influx_time("time", '@ 1 sec'::interval))
   Sort Key: (holt_winters_with_fit(min(s3.value1), 5, 1))
   ->  GroupAggregate  (cost=332.43..349.01 rows=32 width=16)
         Output: holt_winters_with_fit(min(value1), 5, 1), (influx_time("time", '@ 1 sec'::interval))
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval))
         ->  Sort  (cost=332.43..332.52 rows=34 width=16)
               Output: (influx_time("time", '@ 1 sec'::interval)), value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval))
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=16)
                     Output: influx_time("time", '@ 1 sec'::interval), value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select predictors function holt_winters_with_fit() (result)
--Testcase 879:
SELECT holt_winters_with_fit(min(value1), 5, 1) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s') ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select count(*) function of InfluxDB (stub agg function, explain)
--Testcase 880:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 ORDER BY 1;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Sort  (cost=2131.30..2131.31 rows=1 width=32)
   Output: (influx_count_all(*))
   Sort Key: (influx_count_all(*))
   ->  Aggregate  (cost=2131.28..2131.29 rows=1 width=32)
         Output: influx_count_all(*)
         ->  Foreign Scan on public.s3  (cost=200.00..424.78 rows=6826 width=0)
               Node: pgspider_svr1 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s31influx
               Node: pgspider_svr2 / Status: Alive
                 Remote SQL: SELECT NULL FROM public.s32influx
(10 rows)

-- select count(*) function of InfluxDB (stub agg function, result)
--Testcase 881:
SELECT influx_count_all(*) FROM s3 ORDER BY 1;
ERROR:  stub influx_count_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_count_all_sfunc(text) line 3 at RAISE
-- select count(*) function of InfluxDB (stub agg function and group by influx_time() and tag) (explain)
--Testcase 882:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=72)
   Output: (influx_count_all(*)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_count_all(*))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=72)
         Output: influx_count_all(*), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=40)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=40)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select count(*) function of InfluxDB (stub agg function and group by influx_time() and tag) (result)
--Testcase 883:
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select count(*) function of InfluxDB (stub agg function and group by tag only) (explain)
--Testcase 884:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=333.72..333.80 rows=32 width=64)
   Output: (influx_count_all(*)), tag1
   Sort Key: (influx_count_all(*))
   ->  GroupAggregate  (cost=323.93..332.92 rows=32 width=64)
         Output: influx_count_all(*), tag1
         Group Key: s3.tag1
         ->  Sort  (cost=323.93..324.02 rows=34 width=32)
               Output: tag1
               Sort Key: s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..323.07 rows=34 width=32)
                     Output: tag1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select count(*) function of InfluxDB (stub agg function and group by tag only) (result)
--Testcase 885:
SELECT influx_count_all(*) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
ERROR:  stub influx_count_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_count_all_sfunc(text) line 3 at RAISE
-- select count(*) function of InfluxDB over join query (explain)
--Testcase 886:
EXPLAIN VERBOSE
SELECT influx_count_all(*) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort  (cost=915.56..915.57 rows=1 width=32)
   Output: (influx_count_all(*))
   Sort Key: (influx_count_all(*))
   ->  Aggregate  (cost=915.54..915.55 rows=1 width=32)
         Output: influx_count_all(*)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=0)
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=8)
                     Output: t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(20 rows)

-- select count(*) function of InfluxDB over join query (result, stub call error)
--Testcase 887:
SELECT influx_count_all(*) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub influx_count_all_sfunc(text) is called
CONTEXT:  PL/pgSQL function influx_count_all_sfunc(text) line 3 at RAISE
-- select distinct (stub agg function, explain)
--Testcase 888:
EXPLAIN VERBOSE
SELECT influx_distinct(value1) FROM s3 ORDER BY 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (influx_distinct(value1))
   Sort Key: (influx_distinct(s3.value1))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (influx_distinct(value1))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_distinct(value1) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_distinct(value1) FROM public.s32influx
(13 rows)

-- select distinct (stub agg function, result)
--Testcase 889:
SELECT influx_distinct(value1) FROM s3 ORDER BY 1;
 influx_distinct 
-----------------
             7.2
(1 row)

-- select distinct (stub agg function and group by influx_time() and tag) (explain)
--Testcase 890:
EXPLAIN VERBOSE
SELECT influx_distinct(value1), influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=350.31..350.39 rows=32 width=48)
   Output: (influx_distinct(value1)), (influx_time("time", '@ 1 sec'::interval)), tag1
   Sort Key: (influx_distinct(s3.value1))
   ->  GroupAggregate  (cost=332.43..349.51 rows=32 width=48)
         Output: influx_distinct(value1), (influx_time("time", '@ 1 sec'::interval)), tag1
         Group Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
         ->  Sort  (cost=332.43..332.52 rows=34 width=48)
               Output: (influx_time("time", '@ 1 sec'::interval)), tag1, value1
               Sort Key: (influx_time(s3."time", '@ 1 sec'::interval)), s3.tag1
               ->  Foreign Scan on public.s3  (cost=200.00..331.57 rows=34 width=48)
                     Output: influx_time("time", '@ 1 sec'::interval), tag1, value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT "time", tag1, value1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone))
(15 rows)

-- select distinct (stub agg function and group by influx_time() and tag) (result)
--Testcase 891:
SELECT influx_distinct(value1), influx_time(time, interval '1s'),tag1 FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY influx_time(time, interval '1s'), tag1 ORDER BY 1;
ERROR:  stub influx_time(timestamp with time zone, interval) is called
CONTEXT:  PL/pgSQL function influx_time(timestamp with time zone,interval) line 3 at RAISE
-- select distinct (stub agg function and group by tag only) (explain)
--Testcase 892:
EXPLAIN VERBOSE
SELECT influx_distinct(value2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
                                                                                                                   QUERY PLAN                                                                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=40)
   Output: (influx_distinct(value2)), tag1
   Sort Key: (influx_distinct(s3.value2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
         Output: (influx_distinct(value2)), tag1
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_distinct(value2), tag1 FROM public.s31influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_distinct(value2), tag1 FROM public.s32influx WHERE (("time" >= '1970-01-01 09:00:00+09'::timestamp with time zone)) AND (("time" <= '1970-01-01 09:00:04+09'::timestamp with time zone)) GROUP BY 2
(13 rows)

-- select distinct (stub agg function and group by tag only) (result)
--Testcase 893:
SELECT influx_distinct(value2) FROM s3 WHERE time >= to_timestamp(0) and time <= to_timestamp(4) GROUP BY tag1 ORDER BY 1;
 influx_distinct 
-----------------
             100
             200
(2 rows)

-- select distinct over join query (explain)
--Testcase 894:
EXPLAIN VERBOSE
SELECT influx_distinct(t1.value2) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=915.56..915.57 rows=1 width=8)
   Output: (influx_distinct(t1.value2))
   Sort Key: (influx_distinct(t1.value2))
   ->  Aggregate  (cost=915.54..915.55 rows=1 width=8)
         Output: influx_distinct(t1.value2)
         ->  Nested Loop  (cost=400.00..626.54 rows=1156 width=8)
               Output: t1.value2
               ->  Foreign Scan on public.s3 t1  (cost=200.00..306.00 rows=34 width=16)
                     Output: t1.value2, t1.value1
                     Node: pgspider_svr1 / Status: Alive
                       Remote SQL: SELECT value1, value2 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                     Node: pgspider_svr2 / Status: Alive
                       Remote SQL: SELECT value1, value2 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
               ->  Materialize  (cost=200.00..306.17 rows=34 width=8)
                     Output: t2.value1
                     ->  Foreign Scan on public.s3 t2  (cost=200.00..306.00 rows=34 width=8)
                           Output: t2.value1
                           Node: pgspider_svr1 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s31influx WHERE ((value1 = 0.1::double precision))
                           Node: pgspider_svr2 / Status: Alive
                             Remote SQL: SELECT value1 FROM public.s32influx WHERE ((value1 = 0.1::double precision))
(21 rows)

-- select distinct over join query (result, stub call error)
--Testcase 895:
SELECT influx_distinct(t1.value2) FROM s3 t1 INNER JOIN s3 t2 ON (t1.value1 = t2.value1) where t1.value1 = 0.1 ORDER BY 1;
ERROR:  stub influx_distinct_sfunc(anyelement, anyelement) is called
CONTEXT:  PL/pgSQL function influx_distinct_sfunc(anyelement,anyelement) line 3 at RAISE
-- select distinct with having (explain)
--Testcase 896:
EXPLAIN VERBOSE
SELECT influx_distinct(value2) FROM s3 HAVING influx_distinct(value2) > 100 ORDER BY 1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=1 width=8)
   Output: (influx_distinct(value2))
   Sort Key: (influx_distinct(s3.value2))
   ->  Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
         Output: (influx_distinct(value2))
         Node: pgspider_svr1 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_distinct(value2) FROM public.s31influx
         Node: pgspider_svr2 / Status: Alive
           Agg push-down: yes
           Relations: Aggregate on (public.s3)
           Remote SQL: SELECT public.influx_distinct(value2) FROM public.s32influx
(13 rows)

-- select distinct with having (result, not pushdown, stub call error)
--Testcase 897:
SELECT influx_distinct(value2) FROM s3 HAVING influx_distinct(value2) > 100 ORDER BY 1;
 influx_distinct 
-----------------
             300
(1 row)

--Drop all foreign tables
--Testcase 898:
DROP FOREIGN TABLE s3__pgspider_svr1__0;
--Testcase 899:
DROP USER MAPPING FOR CURRENT_USER SERVER pgspider_svr1;
--Testcase 900:
DROP SERVER pgspider_svr1;
--Testcase 901:
DROP FOREIGN TABLE s3__pgspider_svr2__0;
--Testcase 902:
DROP USER MAPPING FOR CURRENT_USER SERVER pgspider_svr2;
--Testcase 903:
DROP SERVER pgspider_svr2;
--Testcase 904:
DROP EXTENSION pgspider_fdw;
--Testcase 905:
DROP FOREIGN TABLE s3;
--Testcase 906:
DROP USER MAPPING FOR CURRENT_USER SERVER pgspider_core_svr;
--Testcase 907:
DROP SERVER pgspider_core_svr;
--Testcase 908:
DROP EXTENSION pgspider_core_fdw;
